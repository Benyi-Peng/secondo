delete database pagerank;
create database pagerank;
open database pagerank;

let Workers = [const rel(tuple([Host: string, Port: int, Config: string, MessageServerPort: int])) value
(
 ("127.0.0.1" 1471 "SecondoConfig.ini" 9898)
 ("127.0.0.1" 1472 "SecondoConfig.ini" 9899)
)];

let WorkerNumber = Workers count;
# = 2

#
# Dampening Factor
#

let D = 0.85;

let PartitionFunction = fun (id: int) (hashvalue(id, WorkerNumber));

#
# Edges of the Graph
#

let LinksPersistent = [const rel(tuple([Source: int, Target: int])) value
(
  (1 3)
  (1 2)
  (2 1)
  (2 5)
  (3 5)
  (4 3)
  (5 1)
  (5 2)
)];
let LinksD = Links feed ddistribute4["LinksD", PartitionFunction(.Source), WorkerNumber , Workers];
let LinksSD = LinksD makeSimple[FALSE, "LinksPersistent"];
let Links = LinksPersistent feed mconsume;


#
# Vertices of the Graph
#

let PagesPersistent = LinksPersistent feed projectextend[;Id: .Source] LinksPersistent feed projectextend[;Id: .Target] concat sort rdup extend[Value: 0.0] consume;
let N = PagesPersistent count;
let Minimum = ((1 - D) / N);

update PagesPersistent := PagesPersistent feed projectextend[Id; Value: 1.0 / N] consume;

let PagesD = PagesPersistent feed ddistribute4["PagesD", PartitionFunction(.Id), WorkerNumber , Workers];
let PagesSD = PagesD makeSimple[FALSE, "PagesPersistent"];
let Pages = PagesPersistent feed mconsume;


#
# Define and share Functions
#

# Add attribute Address to messages based on PartitionFunction()
let AddRoutingAddress = fun (messages: stream(tuple([Id: int, Value: real]))) (messages extend[Address: PartitionFunction(.Id)]);

# Remove attribute Address from incoming messages
let RemoveRoutingAddress = fun (messages: stream(tuple([Id: int, Value: real, Address: int]))) (messages project[Id, Value]);

# Calculate the value of messages sent from a Node (Page) = ItsValue / outdeg
let CalculateBroadcastValue = fun (pages: stream(tuple([Id: int, Value: real])), linksjoining: stream(tuple([Source: int, Target: int]))) (pages linksjoining sortmergejoin[Id, Source] groupby[Id; NewValue: (group feed extract[Value]) / (group feed count) ]);

# Generate a message for each outgoing edge
let GenerateMessages = fun (pages: stream(tuple([Id: int, Value: real])), linksjoining: stream(tuple([Source: int, Target: int]))) (CalculateBroadcastValue(pages, linksjoining) linksjoining feed sortmergejoin[Id, Source] projectextend[; Id: .Target, Value: .NewValue]);

# Calculate the new Value of a Page from the incoming Messages (rel, because it's used in groupby[])
let PageRank = fun (incoming: rel (tuple([Id: int, Value: real]))) (Minimum + D * (incoming feed sum[Value]));

# Given an Id, return the (new) Value for the Messages of the Page of that Id
#let ExtractValue = fun (id: int, messages: stream(tuple([Id: int, Value: real]))) (messages rename[m] filter[.Id_m = id] extract[Value_m]);

# Merge all messages to the same Page together
let Reduce = fun (messages: stream(tuple([Id: int, Value: real]))) (messages sortby[Id] groupby[Id; Value: PageRank(group)]);

# If whats calculated isn't defined (when there's no message for a Page), instead return an alternative value
#let OrElse = fun (subject: real, alternative: real) (ifthenelse(isdefined(subject), subject, alternative));

# In a sense this merges the new values with the current relation
# let UpdateRel = fun (pages: rel (tuple([Id: int, Value: real])), messages: stream(tuple([Id: int, Value: real]))) (pages feed pages updatedirect[Value: OrElse(ExtractValue(.Id, messages), 1.0 - D)] project[Id, Value]);
# let UpdateRelById = fun (pages: rel (tuple([Id: int, Value: real])), messages: stream(tuple([Id: int, Value: real]))) (pages feed addid messages rename[m] mergejoin[Id, Id_m] pages updatedirect2[TID; Value: .Value_m] project[Id, Value]);
# let UpdateRelById = fun (pages: rel (tuple([Id: int, Value: real])), messages: stream(tuple([Id: int, Value: real]))) (pages feed addid projectextend[Id, TID; Value: Minimum] messages rename[m] mergejoin[Id, Id_m] pages updatedirect2[TID; Value: .Value_m] project[Id, Value] Pages feed projectextend[Id; Value: Minimum] concat sortby[Id] groupby[Id; Value: group feed max[Value]]);
# let UpdateRelById = fun (pages: rel (tuple([Id: int, Value: real])), messages: stream(tuple([Id: int, Value: real]))) (pages feed addid project[Id, TID] messages pages feed projectextend[Id; Value: Minimum] concat sortby[Id] groupby[Id; Value: group feed max[Value]] rename[m] mergejoin[Id, Id_m] pages updatedirect2[TID; Value: .Value_m]);
let UpdateRelById = fun (pages: mrel (tuple([Id: int, Value: real])), messages: stream(tuple([Id: int, Value: real]))) (pages mfeed addid project[Id, TID] messages pages mfeed projectextend[Id; Value: Minimum] concat sortby[Id] groupby[Id; Value: group feed max[Value]] rename[m] mergejoin[Id, Id_m] pages mupdatedirect2[TID; Value: .Value_m]);

# Takes messages, maps the new PageRank value to their Page, persists them and generates new messages
let Compute = fun (pages: mrel(tuple([Id: int, Value: real])), links: mrel(tuple([Source: int, Target: int])), messages: stream(tuple([Id: int, Value: real]))) (GenerateMessages(UpdateRelById(pages, Reduce(messages)), links feed));

# Wraps the messages that Compute uses with the Address attribute first
let ComputeRouted = fun (messages: stream(tuple([Id: int, Value: real, Address: int]))) (AddRoutingAddress(Compute(Pages, Links, RemoveRoutingAddress(messages))));

query share("WorkerNumber", TRUE, Workers);
query share("N", TRUE, Workers);
query share("PartitionFunction", TRUE, Workers);
query share("D", TRUE, Workers);
query share("Minimum", TRUE, Workers);

query share("AddRoutingAddress", TRUE, Workers);
query share("RemoveRoutingAddress", TRUE, Workers);
query share("CalculateBroadcastValue", TRUE, Workers);
query share("GenerateMessages", TRUE, Workers);
query share("PageRank", TRUE, Workers);
query share("Reduce", TRUE, Workers);
query share("UpdateRelById", TRUE, Workers);
query share("Compute", TRUE, Workers);
query share("ComputeRouted", TRUE, Workers);

query share("ExtractValue", TRUE, Workers);
query share("OrElse", TRUE, Workers);
