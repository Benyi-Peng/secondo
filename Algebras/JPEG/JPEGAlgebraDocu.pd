/*******************************************************************************
//paragraph [1] title: [{\Large \bf ]	[}]
//paragraph [2] subtitle: [{\bf ]	[}]
//[->] [$\rightarrow $]
//[=>] [$=> $]
//[TOC] [\tableofcontents]
//[newpage] [\newpage]
//[ae] [\"{a}]
//[oe] [\"{o}]
//[ue] [\"{u}]
//[ss] [{\ss}]
//[Ae] [\"{A}]
//[Oe] [\"{O}]
//[Ue] [\"{U}]
//[**] [$**$]


[1] JPEGAlgebra - Secondo-Plugin Module for Basic Support of the Jpeg-Format,
Corresponding Viewer for this Algebra

*/


/**
Ulrich Neumann, Herbert Schoenhammer, Stefan Wich (Viewer) December 2003 to
February 2004

*/


/**
[TOC]

\rule {100 pt}{1 pt} \linebreak

[newpage]

*/

/**
1 Introduction

*/

/**
1.1 Overview

This document is the complete documented source code for the JPEGAlgebra module.

The JPEGAlgebra is one of several allready existing modules which can be easily
plugged in (at compile time) to the ~Secondo~ extensible Database System.
[cf. G[ue]ting and others, 2003, 'Secondo User Guide' and 'Secondo Programmers
Guide' and related documents, available as PDF].

Just one word: The thrilling point about these modules is that nearly every
kind of data for which such a module can be provided can be integrated into the
database. There are no essential limitations from the part of the 'kernel'
Secondo System to the content and capabilities of the modules, called
'Algebras'. The Algebra module determines what to do with the data and how.
On the other hand this all happens under ~one~ consistent interface, so you can
avoid worrying about the (often not trivial) integration of ~different~
interfaces to the different kind of data you are working with.

JPEGAlgebra provides support for dealing with pictures in the well-known Jpeg
file format in the Secondo extensible database system. Especially the de-facto
standard of the ~Independent Software Groups~ 'JFIF'-format is adressed, so that
only very unusual and seldom used JPEG-derivates, which deviate from the
official Jpeg standard, are supposed not to work in all aspects. See the IJG s
documentation for this point.

From the rich set of Jpeg support given in the IJG s ~'libjpeg'~ we could only
implement a very small part for use in Secondo, as a matter of time. If you
want to extend it, you can take our operators and other code as an example for
integration into Secondo / as an algebra part, and you can then look at the
services of libjpeg which will do a lot of work for you.

Our own code uses libjpeg to ~read~ in Jpeg images from files (supported by the
Secondo System (kernel)), ~save~ and retrieve them from the database ( and also
save then to files again).

Moreover (and not provided by libjpeg) we compute the ~distribution of color-
component-values~ or, for grayscale images, the ~distribution of brightness
values~ for one image.

A bit more application oriented is the ~comparison~ of these color or brightness
distributions for two jpeg-pictures or for one jpeg picture and a stream of
other jpeg pictures. Clearly, this serves for retrieval purposes, if for
example the database object name is not known and/or you have a relation or if
the database object name is not speaking enough for the pattern you are looking
for. See RelationAlgebra for query possibilities. Certainly, these comparison
facilities regarding jpeg color distributions are offered to you as operators.

From the vaste pool of possible operations on jpegs we also provide support for
~cutting~ a part of a jpeg image loaded, or, derived from this to cut the whole
image into a sequence of image-part-rectangles (technically: a stream). We call
this ~'tiles'~. For the cut operator you can specify the origin coordinates in
the source image and dimension of the cut. The 'tiles' are of equal size in
pixels, which you can specify for the x- and y-direction. If there results a
rest on the right and/or bottom edges, it is thrown away instead of refusing
your wish for the tiles size.

A third operator yielding a modified jpeg image is a very simple implementation
of reducing image quality in favour of small, network-friendly size. We called
this ~'downsize'~. It simply uses a libjpeg service: jpeg\_set\_quality. The
interesting point here is an the programming side: it reuses the architecture
and service-methods allready defined in class JPEGSourceMgr for the cut-support.
One of the main purposes of this class is code reuse. This is also interesting
for you as a pure user: if you wish further features they promise to be
impemented faster.

Throughout the the documented code and especially for class JPEGSourceMgr you
can find more considerations on code architecture and reuse.

If you just want to know how to use it see the example files in the appendix
and tho following subsections 'SOS-Signature', 'Usage'.

Besides our main operators mentioned above there are some others whoose main
purpose was to help us in the development process. They are left here because
you might them find useful in some situations. These are:

~savejpegto~, ~show~, ~demo~, ~col\_d\_test~, where the ~demo~ operator was
also meant to demonstrate usage and advantages of JPEGSourceMgr for infos not
contained per default in our JPEG datastructure. For examples see the respective
comments in the code subsections or online with 'list operators'.

There is also an operator ~jreadinfo~. But this is not provided primarily for
direct usage. It is used togehter with the data structure ~jinfo~ for the viewer
who needs the images to be associated with additional info. Our standard
attributes of JPEG are included there. Perhaps you find it useful for other
purposes as for the viewer, so we didn't hide it. For more about jinfo and
jreadinfo, see the respective code subsections.

*/


/*******************************************************************************
//paragraph [1] title: [{\Large \bf ]	[}]
//paragraph [2] subtitle: [{\bf ]	[}]
//[->] [$\rightarrow $]
//[=>] [$=> $]
//[TOC] [\tableofcontents]
//[newpage] [\newpage]


[1] JPEGAlgebra (and JPEG): Header-File

February 06, 2004  Neumann (formatting 1, Object c'str + d'str + tracing
corrected)

February 02   2004   Neumann (Std-c'str for use in CastJINFO(), formatting)

January 21,  2004  Schoenhammer (Type jinfo)

January  14    2004  Schoenhammer (color-/brightness-distribution, testing),
                     Neumann (integration in JPEGSourceMgr, general revision)

January  08/09 2004  Neumann (JPEGSourceMgr: libjpeg w/o file; OO-Separation of
Interfaces)

        ( ... formerly included in JPEGAlgebra.cpp: )

December 31, 2003  Neumann (extensions, 'defined', some error-tests, 'alpha'--)

December 30, 2003  Schoenhammer (InJPEG-WorkAround)

December 29, 2003  Neumann (first revision)

prior to
December 24, 2003  Schoenhammer

*/

/*******************************************************************************
\rule {100 pt}{1 pt} \linebreak

*******************************************************************************/

/*
1 JPEGAlgebra: Defines, includes, typedefs

*/

using namespace std;

#include "Algebra.h"
#include "NestedList.h"
#include "QueryProcessor.h"
#include "StandardTypes.h"
#include "StandardAttribute.h"
#include "FLOB.h"
#include "Base64.h"
#include "../Relation-C++/RelationAlgebra.h"

// out-comment to disable object-tracing-outputs
//#define DEBUGJPEG

#include "JPEGSourceMgr.h"

#ifndef JPEGALGEBRA_H
#define JPEGALGEBRA_H

// Color-Space:       0,   1,    2,              3
enum colorS { grayscale, rgb, cmyk, colS_undefined };

// marker-values for (yet) invalid member values
#define NUMCOMPS_INVALID    -1
#define COLORSPACE_INVALID  colS_undefined
#define HEIGHT_INVALID      777777
#define WIDTH_INVALID       777777
#define COMPLEVEL_INVALID   -1
#define COMMENT_INVALID     "Jpeg-Comment has not been scanned."

/*
2 Type Constructor ~jpeg~

2.1 Data Structure - Class ~JPEG~

*/
class JPEG : public StandardAttribute
{
/**
[2] Class JPEGSourceMgr as a 'friend'

Instead of putting here in JPEG everything, we separate JPEGLib-C-Code from
DB-related C++ Code found here,making the interface to libjpeg more flexible
and easing a possible existence of libjpeg-Parsing-results *independent* from
this JPEG-Object here.

This also leads to Extensibility: without changing size and data-element-count
and / or types of the 'root-object', we can later decide to access further
information available from the libjpeg-cinfo structure by defining new methods
and / or members in JPEGSourceMgr. These would not be local or totally global.

*/
  friend class JPEGSourceMgr;
  friend ostream& operator<<( ostream& o, JPEG& jp );

  public:

/**
Constructors and destructors

*/
  JPEG() {              // standard constructor
    src          = 0;
    srcConnected = false;
    destructing  = false;
    ++numJpegsAlive;
    ++jpegCounter;
      
    #ifdef DEBUGJPEG
    cout << "\nStd-c'str JPEG(). alive (w/o casts): " << numJpegsAlive
       << "   c'str-calls: " << jpegCounter <<  "   including casts: "
       << castJPEGs << endl;
    #endif
  };

  JPEG( const int size );
  ~JPEG();
    

/**
Methods

*/
  // public methods

  // Enabling usage as relation attribute type:
  bool      IsDefined() const;
  void      SetDefined( bool Defined);
  void      Destroy(); // support-fn() for consistency of FLOB-states.
  size_t    HashValue();
  void      CopyFrom(StandardAttribute* right);
  int       Compare(Attribute * arg);
  bool      Adjacent(Attribute * arg);
  JPEG*     Clone();
  ostream&  Print( ostream &os );
  int       NumOfFLOBs();
  FLOB *    GetFLOB(const int i);

  // member access functions: Get__ / Is__
  bool    IsColoured();
  int     GetWidth();
  size_t  GetHeight();
  int     GetCompLevel();
  string  GetComment();
  bool    GetAllPictureBytes(char *& buffer); // also reserves buffers mem
  /** Get cinfo from source. Not recommended. Evades consistency checks! */
  struct  jpeg_decompress_struct* Get_cinfo();
  bool CInfoValid();
  double  GetBrightnessValue (int brightnessValue, int dummy = 0);
          /* dummy-parameter is for having same signature */
  double  GetRGBValue (int colorIndex, int colorNumber);
  double  GetCMYKValue (int colorIndex, int colorNumber);
  colorS  GetColorSpace(); // overloaded for comfortability
  int     GetColorSpace(int dummy_int);  
  string  GetColorSpace(string dummy); 
  int     Get_num_components(); // get # of color components (per pixel)
  static int GetNumAlive(); // number of JPEGs currently existing, not
                            // managed by Secondo-System

  // ...: Set__

  // initialization
  bool  InitializeJPEG(); // finishes work of c'str including init() of SourceMgr
  void  InitializeBrightnessDistribution();
  void  InitializeRGBDistribution();
  void  InitializeCMYKDistribution();
  void  DropSrcMgr(); // Discard associated JPEGSourceMgr

  // IO-Functions
  void  Encode  ( string& textBytes );   // for IO to Secondo System
  void  Decode  ( string& textBytes );   

  // Usage for operator-implementations (supporting value mapping etc.)
  bool  SaveToFile ( char *fileName ); // IO to OS-file
  bool  Show       ();                 // devel. + test: calls ImageMagic ...
  bool  Demo       ();                 // ... of JPEGSourceMgr-usage

  // (helper fn()s for database-specific operations / for Secondo-operators)
  bool  ColDTest   ();
  bool  CompBright (JPEG* injpeg, double dist);
  bool  CompRgb    (JPEG* injpeg, double rgbdist);
  bool  CompRgb    (JPEG* injpeg, double rdist, double gdist, double bdist);
  bool  Cut        (JPEG * outjpeg, int x, int y, int xdist, int ydist);
  bool  DownSize   (JPEG * outjpeg, int quality);
  bool  Tile(JPEG * outjpeg, int x, int y, int xdist, int ydist);

  // (for Operations on 'picture'(-raster) etc. ->JPEGSourceMgrs 'services')

 private: // Private methods
  void DisconnectFromSrc  (); // notify src(-Mgr) if destructor called

/**
 Attributes

*/    
 private: // Private attributes

  JPEGSourceMgr* src; // does all detailed work related to libjpeg
  bool    defined;    // trace validity of JPEG (also on a semantical level)
  FLOB    picture;  
  bool    canDelete;
  size_t  height;
  size_t  width;
  bool    coloured;    
  int     compLevel;    // not yet supported
  string  comment;      // only partially supported by now
  bool    destructing;  // for DisconnectFromSrc()
  colorS  colorSpace;  
  int     numComponents;  //0: gray, 3 or 4: color

  bool brightnessDcomputed;   // set true with computation by src (-manager)
  bool rgbDcomputed;          // with these flags C/B-distributions only
  bool cmykDcomputed;         //  need to be computed if used

  double brightnessDistribution[256];    //for grayscale. 
  double rgbDistribution       [256][3]; //for RGB; index 0=R, 1=G, 2=B
  double cmykDistribution      [256][4]; //for CMYK; index 0=C, 1=M, 2=Y, 3=K

 public: // Public attributes

  bool srcConnected; // valid JPEGSourceMgr connected? dynamically set

  // for object tracing:
  static int numJpegsAlive;  // #(constructed-destructed) _by_JPEGAlgebra_
                             // memory of the cast ones managed by Secondo
  static int jpegCounter;    // # c'str'd in JPEGAlgebra-lifetime (with casts)

  static int castJPEGs;
  static int clonedJPEGs;
  static int createdJPEGs;
  static int closedJPEGs;
  static int deletedJPEGs;
 
};
/**
[newpage]

*/

/*
3 Type Constructor ~JINFO~

3.1 Data Structure - Class ~JINFO~

*/
class JINFO: public StandardAttribute
{

 public:

/*
Declaration Part with definition of the DataStructure and of the operators.

*/
  JINFO(){}  // Std.-C'str (needed for CastINFO())


/*
Constructor-Declaration

*/
  JINFO ( const bool defined,
          const int inHeight, const int inWidth,
          bool inColoured, int inCS, int inNumComp, ListExpr inPict );
/*
Destructor-Declaration

*/
  ~JINFO();
/*
Declaration of the class-methods.

*/
  int           GetHeight         ();
  int           GetWidth          ();
  bool          IsColoured        ();
  int           Get_num_components();
  colorS        GetColorSpace();
  void          GetcDistribution  ( double outDistr [256][4] );
  void          SetcDistribution  ( int compIndex, int comp, double value );
  ListExpr      GetPictureList    ();
  void          Set               ( const bool D,       const int inHeight,
                                    const int  inWidth, bool      inColoured,
                                    int        inCS,    int       inNumComp,
                                    ListExpr   inPict);

/*
The following virtual classes are needed to use ~JINFO~ as an
attribute type in tuple definitions.

*/
  int           Compare   (Attribute * arg);
  bool          Adjacent  (Attribute * arg);
  JINFO*        Clone     ();
  bool          IsDefined () const;
  void          SetDefined( bool Defined );
  int           Sizeof    () const;
  size_t        HashValue ();
  void          CopyFrom  (StandardAttribute* right);
  ostream&      Print     ( ostream &os );

/*
Private Attributes of the class ~JINFO~.

*/
 private:
  bool     defined;
  int      height;
  int      width;
  bool     coloured;
  colorS   colorSpace;
  int      numComponents;
  double   cDistribution[256][4];
  ListExpr picture;
};

#endif
/*******************************************************************************
//[newpage] [\newpage]

\rule {100 pt}{1 pt} \linebreak

[newpage]

*/
/*******************************************************************************
//paragraph [1] title: [{\Large \bf ]	[}]
//paragraph [2] subtitle: [{\bf ]	[}]
//[->] [$\rightarrow $]
//[=>] [$=> $]
//[TOC] [\tableofcontents]



[1] JPEGAlgebra (and JPEG): Implementation File

February 09, 2004  Neumann (corrections in object destruction)

February 06, 2004  Neumann (formatting, object tracing, c'str + d'str corrected)

February 02   2004   Neumann (correction: CastJINFO uses Std-c'str, formatting)

February 01   2004   Schoenhammer (jreadinfo overloaded to work with streams)

January 31    2004   Schoenhammer (working with streams in compbrightdist,
                                   comprgbdist)

January 26-27 2004   Schoenhammer (correct Methods compBright, compRGB)

January 20-23 2004   Schoenhammer (class JPEG: Methods compBright, compRGB,
                                   class JINFO, operator jreadinfo)

January 22, 2004 Schoenhammer (JINFO, jreadinfo)

January  14    2004  Schoenhammer (color-/brightness-distribution, testing),
                     Neumann (integration in JPEGSourceMgr, general revision)

January  08/09 2004  Neumann (JPEGSourceMgr: libjpeg w/o file; OO-Separation of
Interfaces)

        ( ... formerly including in JPEGAlgebra.h: )

December 31, 2003  Neumann (extensions, 'defined', some error-tests, 'alpha'--)

December 30, 2003  Schoenhammer (InJPEG-WorkAround)

December 29, 2003  Neumann (first revision)

prior to
December 24, 2003  Schoenhammer


*******************************************************************************/
/*******************************************************************************
\rule {100 pt}{1 pt} \linebreak

*******************************************************************************/


#include "JPEGAlgebra.h"

extern NestedList* nl;
extern QueryProcessor *qp;

bool jpegAlgGlobalError; // Global flag: any error occurred in JPEGAlgebra?

/*******************************************************************************
2 Type Constructor ~jpeg~

*******************************************************************************/

/******************************************************************************
2.1 Class ~JPEG~  Implementation

******************************************************************************/

// Four class attributes and methods
int JPEG::numJpegsAlive = 0; // (initialization static/class variable)
int JPEG::jpegCounter   = 0; // number of JPEGs c'str'd inJPEGAlgebra lifetime
int JPEG::castJPEGs     = 0; // that is: memory is managed by Secondo System
int JPEG::clonedJPEGs   = 0;
int JPEG::createdJPEGs  = 0;
int JPEG::closedJPEGs   = 0;
int JPEG::deletedJPEGs  = 0;

/** number of Jpegs currently existing, w/o casts ( managed by Secondo ) */
int JPEG::GetNumAlive(){
  return numJpegsAlive;
}


/**
2.1.1 Constructors (c'str) and Destructors (d'str)

*/

JPEG::JPEG( const int size ) : // (initialiation list: declaration order!)
src(0), // needs the FLOB
defined(false),  // no valid picture yet
picture( size ), // success => memory/FLOB reserved, header not yet set.
canDelete( false ),
height(HEIGHT_INVALID),
width(WIDTH_INVALID),
coloured(false),
compLevel(COMPLEVEL_INVALID),
comment(COMMENT_INVALID),
destructing(false),
colorSpace(COLORSPACE_INVALID),
numComponents(NUMCOMPS_INVALID),
brightnessDcomputed(false),
rgbDcomputed(false),
cmykDcomputed(false),
srcConnected(false)
{
  // defined remains false since attributes not yet initialized by SrcMgr
  ++numJpegsAlive;
  ++jpegCounter;

  #ifdef DEBUGJPEG
  cout << "\nGeneral Constructor JPEG(int). alive (w/o casts): "
       << numJpegsAlive
       << "   c'str-calls: " << jpegCounter <<  "   including casts: "
       << castJPEGs << endl;
  #endif
  
  InitializeBrightnessDistribution(); // initialize Array []   with 0.0;
  InitializeRGBDistribution();	      // initialize Array [][] with 0.0;
  InitializeCMYKDistribution();       // initialize Array [][] with 0.0;
}


/**
InitializeJPEG() finishes the work of the c'str

*/
bool JPEG::InitializeJPEG()
{
  // Precondition: decoded FLOB 'picture' present

  // Construct the source manager, which will do all the work related
  // to libjpeg  (JPEG can concentrate on operator-/appl.- logic):

//  assert(!src);
  src = new JPEGSourceMgr(this); // sets connection to JPEG.
  srcConnected = (src != 0);

  #ifdef DEBUGJPEG
  cout << "\nJPEG::InitializeJPEG() after JPEGSourceMgr(this)" << endl;
  #endif

  // Two steps in construction required. The second one is init(), which :
  // (a) scans FLOB.
  // (b) sets the most important and often used members of JPEG. The other
  // ones are set by JPEGSourceMgr if needed. This greatly improves average
  // performance since no computations are done which are not needed.

  return src->init(); // used to report success to Secondo System
}

void JPEG::InitializeBrightnessDistribution ( )
{
  for (int i = 0; i <=255; i++)
     brightnessDistribution [i] = 0.0;
}

void JPEG::InitializeRGBDistribution ( )
{
  for (int i = 0; i <= 255; i++)
    for (int j = 0; j <=2; j++)
     rgbDistribution [i][j] = 0.0;
}

void JPEG::InitializeCMYKDistribution ( )
{
  for (int i = 0; i <= 255; i++)
    for (int j = 0; j <=3; j++)
     cmykDistribution [i][j] = 0.0;
}

// Destructor of JPEG: deletes its SourceManager after disconnecting from
// it, decrements count of Jpegs alive in the JPEGAlgebra-instance.
JPEG::~JPEG()
{
  if( canDelete )
    picture.Destroy();

  // Destruction mechanism may be changed IF possible extension to JPEG inde-
  // pendent source objects implemented: then a static SourceManager with
  // lifetime of JPEGAlgebra would be notified of JPEG-destruction and could
  // decide if also the src-Object is to be destroyed -- depending on a flag
  // 'isPermanent' set for this object ... As stated, this is currently NOT
  // implemented.
  if(srcConnected)
  {
    DisconnectFromSrc();
    delete src;
  }

  --numJpegsAlive;
  #ifdef DEBUGJPEG
  cout << "Destructor ~JPEG(). w/o casts alive: "
       << numJpegsAlive << "   c'str-calls: "
       << jpegCounter   << endl;
  #endif

  // defined destroyed with *this
}

void JPEG::Destroy()
{
  canDelete = true;
  SetDefined(false);
}


/**
2.1.2 'Ordinary' JPEG - member functions (methods) ...

  * supporting usage as Relation-Attribute ( IsDefined() etc. )

  * Flob-Management ( Encode() etc. using Base64 )

  * (diverse) Support to Operator- and Type Constructor- Functions

  * (Standard-) Member-Access (Get.. and Set.. ...)

*/


/**
[2] Relation-Attribute methods:  need to be revised, completed, made consistent

*/


/*
IsDefined() / SetDefined():
The goal of tracing defined-status is (besides 'Relation-Attribute-Abilities')
also to prevent system crashes if the user works with declared or constructed,
but not initialized objects:  'create' without 'update', for example.

*/
bool JPEG::IsDefined() const
{
  // return true;     // <- switch off defined-tracing
  return defined;
}

void JPEG::SetDefined( bool Defined)
{
  defined = Defined; 
  // defined = true; // <- switch off defined-tracing (caveat: constructor!)
}

size_t JPEG::HashValue()
{
  return height*5+width;
}

void JPEG::CopyFrom(StandardAttribute* right)
{
  bool no_error = true;

  JPEG *r = (JPEG *)right;

  if (!r)
  {
    cerr << "\nerror: CopyFrom() got 0x00 instead of jpeg!\n";
    no_error = false;
  }
    
  if (no_error &&
      r->IsDefined())
  {
    #ifdef DEBUGJPEG
    cout << "\n++ CopyFrom ++ (defined is true)\n";
    #endif

    // Copy the FLOB. (r _may_ also _not_ be connected to a SrcMgr).
    int copysize = r->picture.Size();
    picture.Resize( copysize );

    char *bin = (char *)malloc( copysize );
    if (!bin)
    { no_error = false;
      defined = no_error;
      cerr << "\nCopyFrom(): aborted because of memory leak...\n";
      jpegAlgGlobalError = true;
      return;
    }
    
    r->picture.Get( 0, copysize, bin );
    picture.Put( 0, copysize, bin );

    if (!src)
      src = new JPEGSourceMgr(this);

    // Copying members == scanning and evaluating the flob of ~same~ content
    if (!src)
      no_error = false;
    else
    {
      srcConnected = true;
      if (!src->init())
      {
        no_error = false;
        cerr << "\nCopyFrom(): JPEG initialization failed.\n";
      }
    }

    // Due to SecondoSystem object-management mechanisms which partly do _not_
    // call Destructors, there is no other possibility for releasing the Src-
    // Mgr _in_CopyFrom_ than doing it allready here ... if we want correct
    // object-/memory-management!
    // ... So, _if_ SrcMgr will be needed again for _extended_ features:
    // Re-InitializeJPEG(). Reduce this need by Computing distribution-array now:

    if (no_error)
    {
      switch (colorSpace)
      {
        case grayscale : src->ComputeBrightnessD();
                         break;
        case rgb       : src->ComputeRGBD();
                         break;
        case cmyk      : src->ComputeCMYKD();
                         break;
        default        : cerr << "\nunknown colorSpace."
                                 " couldn't create distribution.";
                         no_error = false;
      }
    }

    if (src)
      DropSrcMgr(); // Not the best way it vould work. see comment above!

    #ifdef DEBUGJPEG
    cout << "CopyFrom(): after src->init()\n";
    #endif
        
    free( bin );
    defined = no_error;
  }
  else
  {
    // defined: even if JPEG WAS defined before: it's NOT defined AS A COPY OF
    // 'right' now... semantical state not valid even if data valid
    
    cerr << "\n!!! CopyFrom() didn't try to copy from undefined JPEG !!!\n";
    no_error = false;
    defined = false;
  }
  
  if (!no_error)
    jpegAlgGlobalError = true;
}

int JPEG::Compare(Attribute * arg)
{
  // (perhaps a comparison of imgage creators comment would be an alternative)

  if(!arg)
  {
    cerr << "\nerror: JPEG::Compare() received 0x00 instead of Attribute *\n";
    jpegAlgGlobalError = true;
    return -2; // indicate error
  }

  JPEG *a = (JPEG *)arg;

  if (!IsDefined())
    return (a->IsDefined()) ? -1:0;  // undefined => worse, if other defined
  if (!a->IsDefined())
    return 1;                        // allways better if other not defined

  if ( (a->comment == comment) &&
       (a->height == height) &&
       (a->width == width) )
       return 0; // assume equal (without considering image content)
  if ( comment != a->comment )
    return (comment > a->comment) ? 1:-1;  // this bigger : this smaller
  if ( height != a->height )
    return (height > a->height) ? 1:-1;
  if ( width != a->width )
    return (width > a->width) ? 1:-1;

  jpegAlgGlobalError = true;
  return -2; // never reached
}

bool JPEG::Adjacent(Attribute * arg)
{
  if(!arg)
  {
    cerr << "\nerror: JPEG::Adjacent() received 0x00 instead of Attribute *\n";
    jpegAlgGlobalError = true;
    return false;
  }

  JPEG *a = (JPEG *)arg;

  if (!IsDefined() || !a->IsDefined())
    return false; // (adjacency is a constraint, un-definedness the opposite)

  if ( (a->comment == comment) && // taken as semantic: 'same sense'
        comment != "" &&
        Compare(a) != 0 )
    return true; // semantically same, technically modified

  return false; // exactly same or unequal in all considered aspects
}

JPEG* JPEG::Clone()
{
  JPEG *newJPEG = new JPEG( 0 );
  newJPEG->CopyFrom( (JPEG*)this ); // also connects to a JPEGSourceMgr
  return newJPEG;
}

ostream& JPEG::Print( ostream &os )
{
  if(IsDefined())
  {
    // print information useful for debugging
    return
           (os
            << "JPEG-Picture-Object with SrcMgr-ID-Nr. "   << src->GetID()
            << "  Existing JPEGs: " <<  numJpegsAlive        << "  from "
            << "overall " << jpegCounter << " c'str'd JPEGs."         
            << "\nCurrently alive SourceMgr(s): "<< src->GetNumAlive()
            << "\n\nPicture - Info:\n"
            << "created with Adobe? : "
            <<  ((Get_cinfo()->saw_Adobe_marker == 1) ? "yes":"no")
            << "\nheight= "                      << height        << endl
            << "width= "                         << width         << endl
            << "coloured= "                      << ((coloured) ? "yes":"no")
            << endl
            );
  }
  else
    return ( os << " existing but undefined JPEG-Picture-Object" << endl);
}

// overload iostream output-operator ( could access members, since a friend )
ostream& operator<<( ostream& o, JPEG& jp )
{
   return jp.Print(o);
}

int JPEG::NumOfFLOBs()
{
  return 1;
}

FLOB *JPEG::GetFLOB(const int i)
{
  assert( i >= 0 && i < NumOfFLOBs() );
  return &picture;
}



/**
[2] Flob-Management methods

*/


/*
Encode / Decode is the task of JPEG, not of the Source-Manager, since it is
related to the Secondo System Architecture. The same applies to Decode and
other FLOB management done inside JPEGAlgebra.

*/
void JPEG::Encode( string& textBytes )
{
  if (IsDefined()) // ... then also picture should be valid
  {
    Base64 b;
    char *bytes = (char *)malloc( picture.Size() );
    picture.Get( 0, picture.Size(), bytes );
    b.encode( bytes, picture.Size(), textBytes );
  }
  else
    textBytes = "undefined JPEG!";
}

void JPEG::Decode( string& textBytes )
{
  Base64 b;
  int sizeDecoded = b.sizeDecoded( textBytes.size() );
  char *bytes = (char *)malloc( sizeDecoded );
  int result = b.decode( textBytes, bytes );

  assert( result <= sizeDecoded );

  picture.Resize( result );
  picture.Put( 0, result, bytes );

  free( bytes );
}



/**
[2] Other methods supporting Operator- and Type Constructor- Functions

*/



bool JPEG::SaveToFile( char *fileName )
{
  if (!IsDefined())
  {
      if (strlen(fileName) >= strlen("undefined.dont_save_me"))
        strcpy(fileName, "undefined.dont_save_me");
      else
        strcpy( fileName, "");
        
      jpegAlgGlobalError = true;
      return false;
  }

  FILE *f = fopen( fileName, "wb" );

  if( f == NULL )
  {
    jpegAlgGlobalError = true;
    return false;
  }

  char *bytes;  // memory reserved by GetAllPictureBytes(), if successful
  if (!GetAllPictureBytes(bytes))
  {
    fclose(f);
    cerr << "SaveToFile: Couldn't get picture-Bytes. canceled.\n";
    jpegAlgGlobalError = true;
    return false;
  }

  if( (int)fwrite( bytes, 1, picture.Size(), f ) != picture.Size() )
  {
    fclose (f); 
    free(bytes);
    jpegAlgGlobalError = true;
    return false;
  }

  fclose( f );
  free(bytes);
  return true;
}

bool JPEG::Show(){ // OS-, even Installation dependent: calls ImageMagic
  if (!defined)
  {
    jpegAlgGlobalError = true;
    return false;
  }  
  bool success = false;

  if (picture.Size() > 0)
    success = SaveToFile("tmpJPEGAlgebra000.jpeg");
  else
    defined = false;
    
  if (success)
  {
    success = (-1 != system("display tmpJPEGAlgebra000.jpeg"));
    if (success)
    {
      success = (-1 != system("rm tmpJPEGAlgebra000.jpeg"));
      if (!success)
        cerr << "Temporary file couldn't be removed.\n";
    }
    else
      cerr << "X11-programm display could not be loaded.\n";
  }
  else
    cerr << "Temporary file couldn't be created. is there write permission to"\
            " directory?.\n";

  if (!success)
    jpegAlgGlobalError = true;
            
  return success;
}

// Demo: usage of JPEGSourceMgr. For Development and Debugging.
bool JPEG::Demo(){
  if (!defined)
  {
    jpegAlgGlobalError = true;
    return false;
  }
  
  bool success = false;
  if (!srcConnected)
    InitializeJPEG();
  success = src->ParseComment();

  if (success)
    cout << "\nDemo:\nPicture a has comment: \"" <<  comment
         << "\"\nwhich has been saved in member var by JPEGSourceMgr.\n";
  else
    cout << "\nDemo:\nNo comment was found in picture. Nothing else done. "\
              "value-map-fn gets false.\n";

  if (src->hasAdobeMarker())
    cout << "\nDemo:\nParsed picture is created with Adobe.\n";
  else
    if (Get_cinfo()->saw_JFIF_marker)
    cout << "\nDemo:\nParsed picture is a JFIF-compatible. ColorSpace is "
         << GetColorSpace("");
    else
        cout << "\nDemo: parsed picture is of valid but unknown Format. "
             << "ColorSpace is "     << GetColorSpace("");
  cout << endl
       << *this << endl;
       
  if (!success)
    jpegAlgGlobalError = true;

  return success;
}


bool JPEG::ColDTest(){  // for testing ColorDistribution-Algor. only 
  if (!defined)
  {
    cerr << "\nColDTest: JPEG is not defined!\n";
    jpegAlgGlobalError = true;
    return false;
  }

  int cs_val = (int)GetColorSpace();

  if (cs_val == 3)
  {
    cerr << "\nColDTest: ungueltiger colorspace.\n";
    jpegAlgGlobalError = true;
    return false;
  }

  double val = 0.0;

  if (!cs_val)  // brightness
  {
    cout << "\n\nBrightnessdistributionstest:\n\n";
    for (int r = 0; r <280; r += 20) // 14 lines
    {
       for (int i = 0; i < 128; i++) // somewhat un-exact
         cout << ((GetBrightnessValue(i) > ((double) (256 - r))/256.0) ?
                 '#':'.');
      cout << endl;
    }

  }
  else // RGB, CMYK  ... for simplicity only first 3 comps
  {
    cout << "\n\n" << ((cs_val == rgb) ? "RGB":"CMYK")
         <<"distributionstest:\n\n";
    for (int r = 0; r <280; r += 20) // 14 lines
    {
       for (int i = 0; i < 256/2; i++) 
       {  val = (cs_val == rgb) ? (GetRGBValue(0,i) +GetRGBValue(0,i+1))/2.0
                              : (GetCMYKValue(0,i)+GetCMYKValue(0,i+1))/2.0;
          cout << ( (val > ((double) (256 - r))/256.0) ? 'r':'.' );
       }
      cout << endl;
    }
    for (int r = 0; r <280; r += 20) // 14 lines
    {
       for (int i = 0; i < 256/2; i++) 
       {  val = (cs_val == rgb) ? (GetRGBValue(1,i)+GetRGBValue(1,i+1))/2.0
                              : (GetCMYKValue(1,i)+GetCMYKValue(1,i+1))/2.0;
          cout << ((val > ((double) (256 - r))/256.0) ? 'g':'.');
       }
      cout << endl;
    }
    for (int r = 0; r <280; r += 20) // 14 lines
    {
       for (int i = 0; i < 256/2; i++) 
       {  val = (cs_val == rgb) ? (GetRGBValue(2,i)+GetRGBValue(2,i+1))/2.0
                              : (GetCMYKValue(2,i)+GetCMYKValue(2,i+1))/2.0;
          cout << ((val > ((double) (256 - r))/256.0) ? 'b':'.');
       }
      cout << endl;
    }
  }
  return true;
}

/**
Cut():

Support for ValueMapping-Fn() of operator ~cut~

*/
bool JPEG::Cut(JPEG * outjpeg, int x, int y, int xdist, int ydist)
{
// outjpeg passed by pointer since actually only flob needed

  bool success = true;
  bool initialized = false;

  if(!src)
  {
    success = InitializeJPEG();
    initialized = success;
  }

  if (success)
    success = src->PrepareCompress(outjpeg->GetFLOB(0));
  if (success)
    success = src->ConfigureCut(x, y, xdist, ydist);
  if (success)
    success = src->Compress();

  outjpeg->SetDefined(success);

  if (!success)
    jpegAlgGlobalError = true;

  if (initialized) // ... initialized here ? so SrcMgr probably not needed
    DropSrcMgr();    
  
  return success;
}

/**
Tile():

Support for ValueMapping-Fn() of operator ~tiles~

*/
bool JPEG::Tile(JPEG * outjpeg, int x, int y, int xdist, int ydist)
{
// outjpeg passed by pointer since actually only flob needed

  bool success = true;
  bool initialized = false;

  if(!src)
  {
    success = InitializeJPEG();
    initialized = success;
  }

  if (success)
    success = src->PrepareCompress(outjpeg->GetFLOB(0));
  if (success)
    success = src->ConfigureCut(x, y, xdist, ydist);
  if (success)
    success = src->Compress();

  outjpeg->SetDefined(success);

  if (!success)
    jpegAlgGlobalError = true;

  if (initialized) // ... initialized here ? so SrcMgr probably not needed
    DropSrcMgr();

  return success;
}



/**
DownSize():

Support for ValueMapping-Fn() of operator ~downsize~

*/
bool JPEG::DownSize(JPEG * outjpeg, int quality)
{
// outjpeg passed by pointer since actually only flob needed

  bool success = true;
  bool initialized = false;

  if (quality > 100 || quality < 0)
  {
    quality = (quality > 100) ? 100:0;
    cout << "\nQuality Range must be 0 to 100 (meaning per cent), "
               "corrected to " << quality << endl;
  }

  if(!src)
  {
    success = InitializeJPEG();
    initialized = success;
  }

  if (success)
    success = src->PrepareCompressDefault(outjpeg->GetFLOB(0));
  if (success)
    success = src->ConfigureDownSize(quality);
  if (success)
    success = src->Compress();

  outjpeg->SetDefined(success);

  if (!success)
    jpegAlgGlobalError = true;

  if (initialized) // ... initialized here ? so SrcMgr probably not needed
    DropSrcMgr();

  return success;
}




/**
[2] (Standard-)Member-Access methods (Get\_\_ / Is\_\_ and Set\_\_)

*/


/**
Get\_\_ / Is\_\_:

*/

bool JPEG::IsColoured(){
  // special case if image not yet scanned, returns false. No 'INVALID_VALUE'.
  // test: numComponents != NUMCOMPS_INVALID
  return coloured;
}

string JPEG::GetComment(){
  // The comment of the Jpeg-Picture-File is not parsed by default.
  // Let JPEGSourceMgr parse the comment in the Jpeg-file, if not yet done.
  // This must be done only once and is done only if requested:

  if (!src->comment_parsed)
    assert(src->ParseComment()); // currently only partially implemented

  // if successful scr has set the JPEG::comment.
  
  return comment;
}

int JPEG::GetCompLevel(){
  cerr << "\ncompression Level set, get, change not yet implemented.\n";
  return compLevel;
}

size_t JPEG::GetHeight(){
  return height;
}

int JPEG::GetWidth(){
  return width;
}

// (GetAllPictureBytes also reserves memory for buffer!)
// (caller is responsible to free(buffer) again!)
bool JPEG::GetAllPictureBytes(char *& buffer){

  size_t noBytes = picture.Size();
  buffer = (char *) malloc( noBytes );
  if (buffer == NULL)
  {
    cerr << "GetAllPictureBytes: not enough Memory.";
    jpegAlgGlobalError = true;
    return false;
  }
  picture.Get(0, noBytes, buffer);

  return true;
}

// GetColorSpace(): this method is overloaded (for comfortability).
// JPEGSourceMgr 'src' sets JPEG::colorspace in its init()-method.

colorS JPEG::GetColorSpace()
{
  return colorSpace;
}
int JPEG::GetColorSpace(int dummy_int)
{
  return (colorSpace == grayscale) ? 0 :
         (colorSpace == rgb)       ? 1 :
         (colorSpace == cmyk)      ? 2 :
                                     3; // 3 == undefined. could also use -1
                                        // ! no assertion done !
}

string JPEG::GetColorSpace(string dummy_string)
{
  return (colorSpace == grayscale) ? "Grayscale" :
         (colorSpace == rgb)       ? "RGB" :
         (colorSpace == cmyk)      ? "CMYK" :
                                     "not supported ColorSpace";
                                     // 3 == undefined. could also use -1
}

int JPEG::Get_num_components()
{                             
  return numComponents;
}

double JPEG::GetBrightnessValue (int brightnessValue, int dummy_not_used)
{
  // Distribution allready computed?
  if (! brightnessDcomputed)
    brightnessDcomputed = src->ComputeBrightnessD();

  // check if no error
  assert(brightnessDcomputed);
  
  assert ( brightnessValue >= 0 && brightnessValue <=255); 
  return brightnessDistribution [brightnessValue];
}

double JPEG::GetRGBValue ( int colorIndex, int colorNumber)
{
  //cout << "GetRGBValue: Distribution already computed?" << rgbDcomputed << endl;
  if (! rgbDcomputed)
    rgbDcomputed = src->ComputeRGBD();

  assert(rgbDcomputed);

  assert (colorIndex >= 0 && colorIndex <=2);
  assert ( colorNumber >= 0 && colorNumber <=255);
  return rgbDistribution [colorNumber][colorIndex];
}

double JPEG::GetCMYKValue ( int colorIndex, int colorNumber)
{
  // Distribution allready computed?
  if (! cmykDcomputed)
    cmykDcomputed = src->ComputeCMYKD();

  // check if no error
  assert(cmykDcomputed);

  assert (colorIndex >= 0 && colorIndex <=3);
  assert ( colorNumber >= 0 && colorNumber <=255);
  return cmykDistribution [colorNumber][colorIndex];
}

bool JPEG::CompBright (JPEG* injpeg, double dist)
/*
Compares the difference of every BrightnessValue (0..255) of two JPEG's.
If the difference for every value is smaller then dist, true is returned.

*/

{
  JPEG* jin =(JPEG*)(injpeg);
  bool similar = true;
  int idx = 0;

  while (similar && (idx <= 255) )
  {
    similar = ( fabs(this->GetBrightnessValue (idx)  -
                  jin->GetBrightnessValue(idx) ) <= dist);
    idx++;
  }

  return similar;
}

bool JPEG::CompRgb (JPEG* injpeg, double rdist, double gdist, double bdist)
/*
Like CompBright, but for all colors RGB

*/
{
  if (!injpeg)
  {
    cerr << "\nerror: CompRgb() received 0x00 instead of jpeg.\n";
    jpegAlgGlobalError = true;
    return false;
  }

  JPEG* jin =(JPEG*)(injpeg);
  bool rSimilar = true;
  bool gSimilar = true;
  bool bSimilar = true;
  int idx = 0;

  //cout << "CompRGB: Compare the Red-Values" << endl;
  while (rSimilar && (idx <= 255))
  {
    rSimilar = ( fabs(this->GetRGBValue (0, idx) -
                  jin->GetRGBValue (0, idx) ) <= rdist);
    //cout <<"RED:"<<  rSimilar << ": idx=" << idx      << " : this="
    //     << this->GetRGBValue (0, idx)    <<" : jin="
    //     << jin->GetRGBValue (0, idx)     << endl;
    idx++;
  }

  //cout << "CompRGB: Compare the Green-Values" << endl;
  idx = 0;
  while (rSimilar && gSimilar && (idx <= 255))
  {
    gSimilar = ( fabs(this->GetRGBValue (1, idx) -
                  jin->GetRGBValue (1, idx) ) <= gdist);
    //cout <<"Green:" << gSimilar << ": idx=" << idx << " : this="
    //     << this->GetRGBValue (0, idx)      << " : jin="
    //     << jin->GetRGBValue (0, idx)       << endl;
    idx++;
  }

  //cout << "CompRGB: Compare the Blue-Values" << endl;
  idx = 0;
  while (rSimilar && gSimilar && bSimilar && (idx <= 255))
  {
    bSimilar = ( fabs(this->GetRGBValue (2, idx) -
                  jin->GetRGBValue (2, idx) ) <= bdist);
    //cout << "Blue:" << bSimilar << ": idx=" << idx << " : this="
    //     << this->GetRGBValue (0, idx) << " : jin="
    //     << jin->GetRGBValue (0, idx)  << endl;
    idx++;
  }

  return (rSimilar && bSimilar && gSimilar);
}

bool JPEG::CompRgb (JPEG* injpeg, double dist)
{
  return (CompRgb (injpeg, dist, dist, dist));
}


bool JPEG::CInfoValid(){
  if (! srcConnected)
    return false;
  if (src == 0)
  {
    cerr << "\nerror in management of srcConnected.\n";
    jpegAlgGlobalError = true;
    return false;
  }
  return src->CInfoValid();
}

// Get\_cinfo():
// Not recommended! C-style direct manipulation of JPEGSourceMgr::cinfo
// Warning: This evades consistency checks!

jpeg_decompress_struct* JPEG::Get_cinfo()
{
  if (!src)
  {
    cerr << "\nerror: JPEG::Get_cinfo() called, but no SourceMgr connected. "
         << "0 will be returned.\n";
    jpegAlgGlobalError = true;
    return 0;
  }
  return src->Get_cinfo();
}



/**
...: Set\_\_
attribute member-setting is done during constrution time or directly by friend
class JPEGSourceMgr. Set-methods who modify consistently member attribute AND
picture are currently not implemented.

*/



// DisconnectFromSource():
// Securely(?) reset the refencePointer in src (friend-access with check)

void JPEG::DisconnectFromSrc(){
  if (!src)
  {
    cerr << "\nerror: DisconnectFromSrc(), but there is no SrcMgr!\n";
    srcConnected = false;
    jpegAlgGlobalError = true;
    return;
  }
  if (!srcConnected)
  {  cerr << "\nforgot to update 'srcConnected' somewhere in the code?\n";
     jpegAlgGlobalError = true;
  }

  destructing = true;
  // src->Disconnect(this);  This way the src-manager can be notified (only by
  // *this) that its client (*this) is gone or not yet correctly initialized.

  src->DisconnectClient(this);  // also sets src = 0
  srcConnected = false;
}


/** Discard JPEGSourceMgr */
void JPEG::DropSrcMgr(){
    if (!srcConnected)
    {
        cerr << "\nforgot to update 'srcConnected' somewhere in the code?\n";
        jpegAlgGlobalError = true;
    }
    else
      if (!src)
      {
        cerr << "\nforgot to update 'srcConnected' after deleting src?\n";
        jpegAlgGlobalError = true;
      }
      
    if (src) {
      DisconnectFromSrc();  // (sets also srcConnected to false)
      delete src;
      src = 0;
    }
}



/*******************************************************************************
\pagebreak \rule {460 pt}{1 pt} \linebreak

*******************************************************************************/
/**
[2] S e c o n d o - S u p p o r t - F u n c t i o n s,\space\space O p e r a t
o r s\space\space   a n d\space\space   T y p e   C o n s t r u c t o r s
\linebreak f o r \space\space J P E G

*******************************************************************************/

/**
2.2 List Representation

The list representations of a ~binfile~ are

----        ( <file>picturefilename</file---> )
----

and

----        ( <text>filename</text---> )
----

If first representation is used then the entire contents of a picturefile
including JPEGHeader is read into the second representation
This is done automatically by the Secondo parser

*/

/**
2.3 ~Out~-Function

*/

ListExpr
OutJPEG( ListExpr typeInfo, Word value )
{
  ListExpr result = nl->TextAtom();

  JPEG *jpegFile = (JPEG *)value.addr;

  if (!jpegFile)
  {
    cerr << "\nerror: OutJPEG received 0x00 instead of jpeg-address.\n";
    jpegAlgGlobalError = true;
  }  
  else
    if (jpegFile->IsDefined())
    {
      string encoded;
      jpegFile->Encode( encoded );

      nl->AppendText( result, encoded );
    }
    else
    {
      cerr << "\nerror: OutJPEG() will not put out undefined jpeg.\n";
      nl->AppendText( result, "typeerror" );
      jpegAlgGlobalError = true;
    }

  return result;
}

/**
2.4 ~In~-Function

*/
Word
InJPEG( const ListExpr typeInfo, const ListExpr instance,
           const int errorPos, ListExpr& errorInfo, bool& correct )
{
  JPEG *jpegFile = new JPEG( 0 ); // not yet 'defined' nor connected to src 
                                   
  if( !jpegFile)
  {
    cerr << "\nInJPEG() failed in constructing a new JPEG.\n";
    jpegAlgGlobalError = true;
  }

  else if ( nl->IsAtom( instance ) && nl->AtomType( instance ) == TextType )
  {
    // Decode 'picture'(-member-att)

    string encoded;
    nl->Text2String( instance, encoded );
    jpegFile->Decode( encoded );  // needs not be 'defined'

    // now FLOB-member picture of JPEG is read in ... needs to be parsed ...

    // JPEG::InitializeJPEG() finishes the work of the cstr, setting up
    // the associated JPEG-Source-Manager, who parses the decoded
    // 'picture' and sets together with JPEG their member-vars:

    correct = jpegFile->InitializeJPEG();
    // 'defined' == correct. This is set in InitializeJPEG() or earlier.

    cout << "\nParsing of Picture, result:\n"                     << *jpegFile
         << "Colorspace:"       << jpegFile->GetColorSpace("")      << endl
         << "Color Components:" << jpegFile->Get_cinfo()->num_components
         << endl << endl;

    if (correct)
      return SetWord( jpegFile );

    // not correct => release ScrMgr. 'defined' remaines false
    if (jpegFile)
      jpegFile->DropSrcMgr();
  }

  jpegAlgGlobalError = true;
  correct = false;              // notify QP ...
  return SetWord( Address(0) ); 
}


/*
2.5 The ~Property~-function

*/
ListExpr
JPEGProperty()
{
  return (nl->TwoElemList(
          nl->FiveElemList(nl->StringAtom("Signature"),
                            nl->StringAtom("Example Type List"),
                            nl->StringAtom("List Rep"),
                            nl->StringAtom("Example List"),
                            nl->StringAtom("Remarks")),
          nl->FiveElemList(nl->StringAtom("-> DATA"),
                            nl->StringAtom("jpeg"),
                            nl->StringAtom("( <file>filename</file---> )"),
                            nl->StringAtom("( <file>Document.jpg</file---> )"),
                            nl->StringAtom(""))));
}

/*
2.6 ~Create~-function

*/
Word
CreateJPEG( const ListExpr typeInfo )
{
  #ifdef DEBUGJPEG
  cout << "\n++ CreateJPEG() ++";
  #endif

  JPEG::createdJPEGs++;
  JPEG::numJpegsAlive--; // correct this number in advance since the Secondo
                         // System manages destruction w/o calling d'str

  return SetWord( new JPEG( 0 ) ); // not defined yet: no data nor header
}

/*
2.7 ~Delete~-function

*/
void
DeleteJPEG( Word& w )
{
  #ifdef DEBUGJPEG
  cout << "\n-- DeleteJPEG() --";
  #endif

  JPEG *jpegFile = (JPEG *)w.addr;

  if (!jpegFile)
  {
    cerr << "\nerror: DeleteJPEG() received 0x00 instead of jpeg-address.\n";
    jpegAlgGlobalError = true;
    return;
  }
  
  jpegFile->Destroy(); 
  delete jpegFile;
  JPEG::deletedJPEGs++;
  w.addr = 0;
}

/*
2.8 ~Close~-function

*/
void
CloseJPEG( Word& w )
{
  #ifdef DEBUGJPEG
  cout << "\n-- CloseJPEG() --";
  #endif
 
  if (!(w.addr))
  {
    cerr << "\nerror: CloseJPEG() received 0x00 instead of jpeg-address.\n";
    jpegAlgGlobalError = true;
    return;
  }

  delete (JPEG *)w.addr;
  JPEG::closedJPEGs++;
  w.addr = 0;
}

/*
2.9 ~Clone~-function

*/
Word
CloneJPEG( const Word& w )
{
  #ifdef DEBUGJPEG
  cout << "\n++ CloneJPEG() ++";
  #endif

  if (!(w.addr))
  {
    cerr << "\nerror: CloneJPEG() received 0x00 instead of jpeg-address.\n";
    jpegAlgGlobalError = true;
    return SetWord(0);
  }
  
  JPEG::clonedJPEGs++;
  // 'w' will set 'defined' appropriately
  return SetWord( ((JPEG *)w.addr)->Clone() );
}

/*
2.10 ~SizeOf~-function

*/
int
SizeOfJPEG()
{
  return sizeof(JPEG);
}

/*
2.11 ~Cast~-function

*/
void* CastJPEG( void* addr )
                            
{
  #ifdef DEBUGJPEG
  cout << "\n+- CastJPEG() +-";
  #endif

  if (!addr)
  {
    cerr << "\nerror: CastJPEG() received 0x00 instead of jpeg-address.\n";
    jpegAlgGlobalError = true;
    return 0;
  }

  JPEG::castJPEGs++;
  // Std-Cstr will inc numJPEGsAlive, but doesn't know that this is a cast =>
  JPEG::numJpegsAlive--;
  return new (addr) JPEG;  
}

/*
2.12 Kind Checking Function

This function checks whether the type constructor is applied correctly. Since
type constructor ~jpeg~ does not have arguments, this is trivial.

*/
bool
CheckJPEG( ListExpr type, ListExpr& errorInfo )
{
  return (nl->IsEqual( type, "jpeg" ));
}

/*
2.13 Creation of the Type Constructor Instance

*/
TypeConstructor jpeg(
        "jpeg",                     //name
        JPEGProperty,               //property function describing signature
        OutJPEG,      InJPEG,       //Out and In functions
        0,            0,            //SaveToList and RestoreFromList functions
        CreateJPEG,   DeleteJPEG,   //object creation and deletion
        0,            0,            //object open and save
        CloseJPEG,    CloneJPEG,    //object close and clone
        CastJPEG,                   //cast function
        SizeOfJPEG,                 //sizeof function
        CheckJPEG,                  //kind checking function
        0,                          //predefined persistence function for model
        TypeConstructor::DummyInModel,
        TypeConstructor::DummyOutModel,
        TypeConstructor::DummyValueToModel,
        TypeConstructor::DummyValueListToModel );


/**
\pagebreak

*/
/*******************************************************************************
3 Non-Lossy Types for Intermediate Representation of Jpeg-Data:

        not yet implemented ... TIFF version 6 fix 2 e.g., cf. libjpeg-doku

        many operator-applications of lossy transformations
    increasingly would worsen the Jpeg-Image [=>] intermediate
    non-lossy representation required.

*******************************************************************************/



/**
\pagebreak

*/
/*******************************************************************************
4 Operators (currently Jpeg-related only)

*******************************************************************************/

/*
4.1 Operator ~savejpegto~

Saves the binary contents of into a file.

4.1.1 Type mapping function of operator ~savejpegto~

Operator ~savejpegto~ accepts a binary file object and a string representing
the name of the file, and returns a boolean meaning success or not.

----    (binfile string)               -> bool
----

*/
ListExpr
SaveJpegToTypeMap( ListExpr args )
{
  ListExpr arg1, arg2;
  if ( nl->ListLength(args) == 2 )
  {
    arg1 = nl->First(args);
    arg2 = nl->Second(args);
    if ( nl->IsEqual(arg1, "jpeg") && nl->IsEqual(arg2, "string") )
    return nl->SymbolAtom("bool");
  }
  return nl->SymbolAtom("typeerror");
}

/*
4.1.2 Value mapping functions of operator ~saveto~

*/
int
SaveJpegToFun(Word* args, Word& result, int message, Word& local, Supplier s)
{
  result = qp->ResultStorage( s );
  JPEG *jpegFile = (JPEG *)args[0].addr;

  if (!jpegFile)
  {
    cerr << "\nerror: SaveJPEGToFun() received 0x00 as arg for jpeg.\n";
    jpegAlgGlobalError = true;
    ((CcBool *)result.addr)->Set( true, false );
    return 0;
  }

  CcString *fileName = (CcString*)args[1].addr;

  // (SaveToFile returns false and does nothing if jpegFile is not 'defined')

  if( jpegFile->SaveToFile( *(fileName->GetStringval()) ) )
    ((CcBool *)result.addr)->Set( true, true );
  else
    ((CcBool *)result.addr)->Set( true, false );

  return 0;
}

/*
4.1.3 Specification of operator ~saveto~

*/
const string SaveJpegToSpec  =
      "( ( \"Signature\" \"Syntax\" \"Meaning\" \"Example\" ) "
        "( <text>(jpeg string) -> bool</text--->"
          "<text>_ savejpegto _</text--->"
          "<text>Saves the image object into a JPEG-image (OS-)file.</text--->"
          "<text>query imgObject savejpegto \"filename.jpg\"</text--->"
      ") )";

/*
4.1.4 Definition of operator ~saveto~

*/
Operator savejpegto (
        "savejpegto",           //name
        SaveJpegToSpec,         //specification
        SaveJpegToFun,          //value mapping
        Operator::DummyModel,   //dummy model mapping, defined in Algebra.h
        Operator::SimpleSelect, //trivial selection function
        SaveJpegToTypeMap       //type mapping
);


/*
4.2 operator ~show~

4.2.1 Type Mapping of operator ~show~

Operator ~show~ accepts a binary file object to show and returns a boolean
meaning success or not.

----    (binfile)               -> bool
----

*/

ListExpr
ShowJpegTypeMap( ListExpr args )
{
  ListExpr arg1;
  if ( nl->ListLength(args) == 1 )
  {
    arg1 = nl->First(args);
    if ( nl->IsEqual(arg1, "jpeg"))
      return nl->SymbolAtom("bool");
  }
  return nl->SymbolAtom("typeerror");
}

/*
4.2.2 Value mapping functions of operator ~show~

*/
int
ShowJpegFun(Word* args, Word& result, int message, Word& local, Supplier s)
{
  result = qp->ResultStorage( s );
  JPEG *jpegObj = (JPEG *)args[0].addr;

  if (!jpegObj)
  {
    cerr << "\nerror: ShowJpegFun() received 0x00 as arg for jpeg.\n";
    jpegAlgGlobalError = true;
    ((CcBool *)result.addr)->Set( true, false );
    return 0;
  }

  if (!jpegObj->IsDefined())
  {
    ((CcBool *)result.addr)->Set( true, false ); // showing failure to QP
    jpegAlgGlobalError = true;
    ((CcBool *)result.addr)->Set( true, false );
    return 0; // indicating error 
  }

  if( jpegObj->Show() )
    ((CcBool *)result.addr)->Set( true, true );
  else
    ((CcBool *)result.addr)->Set( true, false );

  return 0; // success
}

/*
4.2.3 Specification of operator ~show~

*/
const string ShowJpegSpec  =
      "( ( \"Signature\" \"Syntax\" \"Meaning\" \"Example\" ) "
        "( <text>(jpeg string) -> bool</text--->"
          "<text>_ show</text--->"
          "<text>Shows JPEG-image object. For Devel. + Test only. OS-dependent."\
          "</text--->"
          "<text>query imgObject show</text--->"
      ") )";

/*
4.2.4 Definition of operator ~show~

*/
Operator show (
        "show",                 //name
        ShowJpegSpec,           //specification
        ShowJpegFun,            //value mapping
        Operator::DummyModel,   //dummy model mapping, defined in Algebra.h
        Operator::SimpleSelect, //trivial selection function
        ShowJpegTypeMap         //type mapping
);

/*
4.3 operator ~demo~

This is only to demonstrate how to use the JPEGSource,
but surely doesn't demo all its flexibilities. (for develop + debug)

4.3.1 Type Mapping of operator ~demo~

Operator ~demo~ accepts a jpeg, parses its comment (dummy-impl.) which by
default is NOT parsed by libjpeg   and  looks up if the image is a Adobe-
created one  which info is not a member variable of JPEG  nor JPEG-SourceMgr.
It returns a boolean meaning success or not.

----    (jpeg)               -> bool
----

*/

ListExpr
DemoJpegTypeMap( ListExpr args )
{
  ListExpr arg1;
  if ( nl->ListLength(args) == 1 )
  {
    arg1 = nl->First(args);
    if ( nl->IsEqual(arg1, "jpeg"))
      return nl->SymbolAtom("bool");
  }
  return nl->SymbolAtom("typeerror");
}

/*
4.3.2 Value mapping functions of operator ~demo~

*/
int
DemoJpegFun(Word* args, Word& result, int message, Word& local, Supplier s)
{
  result = qp->ResultStorage( s );
  JPEG *jpegObj = (JPEG *)args[0].addr;

  if (!jpegObj)
  {
    cerr << "\nerror: DemoJpegFun() received 0x00 as arg for jpeg.\n";
    jpegAlgGlobalError = true;
    ((CcBool *)result.addr)->Set( true, false );
    return 0;
  }

  if (!jpegObj->IsDefined())
  {
    ((CcBool *)result.addr)->Set( true, false );
    jpegAlgGlobalError = true;
    return 0; 
  }

  if( jpegObj->Demo() )
    ((CcBool *)result.addr)->Set( true, true );
  else
    ((CcBool *)result.addr)->Set( true, false );

  return 0; // success
}

/*
4.3.3 Specification of operator ~demo~

*/
const string DemoJpegSpec  =
          "( ( \"Signature\" \"Syntax\" \"Meaning\" \"Example\" ) "
            "( <text>(jpeg string) -> bool</text--->"
              "<text>_ demo</text--->"
              "<text>Demos JPEGSourceMgr. Parses again for comment. Tells "\
                    "if Adobe-Picture.</text--->"
              "<text>query imgObject demo</text--->"
          ") )";

/*
4.3.4 Definition of operator ~demo~

*/
Operator demo (
        "demo",                 //name
        DemoJpegSpec,           //specification
        DemoJpegFun,            //value mapping
        Operator::DummyModel,   //dummy model mapping, defined in Algebra.h
        Operator::SimpleSelect, //trivial selection function
        DemoJpegTypeMap         //type mapping
);


/*
5.1 operator ~col\_d\_test~

5.1.1 Type Mapping of operator ~col\_d\_test~

Operator ~col\_d\_test~ accepts a jpeg object to show
and returns a boolean meaning success or not.

----    (jpeg)               -> bool
----

*/

ListExpr
ColDTestTypeMap( ListExpr args )
{
  ListExpr arg1;
  if ( nl->ListLength(args) == 1 )
  {
    arg1 = nl->First(args);
    if ( nl->IsEqual(arg1, "jpeg"))
      return nl->SymbolAtom("bool");
  }
  return nl->SymbolAtom("typeerror");
}

/*

5.1.2 Value mapping functions of operator ~col\_d\_test~

*/
int
ColDTestFun(Word* args, Word& result, int message, Word& local, Supplier s)
{
  result = qp->ResultStorage( s );
  JPEG *jpegObj = (JPEG *)args[0].addr;

  if (!jpegObj)
  {
    cerr << "\nerror: ColDTestFun() received 0x00 as arg for jpeg.\n";
    jpegAlgGlobalError = true;
    ((CcBool *)result.addr)->Set( true, false );
    return 0;
  }

  if (!jpegObj->IsDefined())
  {
    ((CcBool *)result.addr)->Set( true, false ); // showing failure to QP
    jpegAlgGlobalError = true;
    ((CcBool *)result.addr)->Set( true, false );
    return 0; // indicating error 
  }

  if( jpegObj->ColDTest() )
    ((CcBool *)result.addr)->Set( true, true );
  else
    ((CcBool *)result.addr)->Set( true, false );

  return 0; // success
}


/*

5.1.3 Specification of operator ~col\_d\_test~

*/
const string ColDTestSpec  =
          "( ( \"Signature\" \"Syntax\" \"Meaning\" \"Example\" ) "
            "( <text>(jpeg string) -> bool</text--->"
              "<text>_ col_d_test</text--->"
              "<text>Shows ColorDistribution of JPEG. Test only.</text--->"
              "<text>query imgObject col_d_test</text--->"
          ") )";

/*

5.1.4 Definition of operator ~col\_d\_test~

*/
Operator col_d_test (
        "col_d_test",             //name
        ColDTestSpec,             //specification
        ColDTestFun,              //value mapping
        Operator::DummyModel,     //dummy model mapping, defined in Algebra.h
        Operator::SimpleSelect,   //trivial selection function
        ColDTestTypeMap           //type mapping
);



/*
9.9 Operator ~cut~

Cuts from JPEG injpeg an area of [xdiff, ydiff] from origin (x;y) and yields
the newly constructed JPEG from this.

9.9.1 Type Mapping of operator ~cut~

The list representation is:

----    (jpeg int int int int)-> (jpeg)
----

Example call: query injpeg cut [x, y, xdiff, ydiff];


*/

ListExpr
CutTypeMap( ListExpr args )
{
  ListExpr argjpeg, argx, argy, argxdist, argydist;

  if ( nl->ListLength(args) == 5 )
  {
    argjpeg  = nl->First(args);  //  1    2   3   4   5
    argx     = nl->Second(args); // (jpeg int int int int)
    argy     = nl->Third(args);  
    argxdist = nl->Fourth(args);
    argydist = nl->Fifth(args); 

    if ( !(nl->IsAtom(argjpeg)  ) ||
         !(nl->IsAtom(argx)     ) ||
         !(nl->IsAtom(argy)     ) ||
         !(nl->IsAtom(argxdist) ) ||
         !(nl->IsAtom(argydist) ) ||
         !(nl->IsEqual(argjpeg,   "jpeg")) ||
         !(nl->IsEqual (argx,     "int"))  ||
         !(nl->IsEqual (argy,     "int"))  ||
         !(nl->IsEqual (argxdist, "int"))  ||
         !(nl->IsEqual (argydist, "int"))  )
    {
      string theErrorIs = "unspecified";

      if ( !(nl->IsAtom(argjpeg)) )
        theErrorIs = "Arg 1 is a list, not a JPEG.";
      else if (    !(nl->IsAtom(argx))     || !(nl->IsAtom(argy))
                || !(nl->IsAtom(argxdist)) || !(nl->IsAtom(argydist)) )
        theErrorIs = "Arg 2 to 5 require int-Atoms.";
      else if ( !(nl->IsEqual(argjpeg,   "jpeg")) )
        theErrorIs = "Arg 1 is not a jpeg";
      else if ( !(nl->IsEqual (argx,     "int"))  ||
                !(nl->IsEqual (argy,     "int"))  ||
                !(nl->IsEqual (argxdist, "int"))  ||
                !(nl->IsEqual (argydist, "int"))     )
        theErrorIs = "One of the x, y, xdist, ydist -values is not an int.";

      ErrorReporter::ReportError("Incorrect input types for operator cut:"
                                 + theErrorIs);
    }
    else
      return nl->SymbolAtom("jpeg");  // ret  (jpeg)

    // correct range of int-values can't be checked here
  }
  return nl->SymbolAtom("typeerror");
}


/*
9.9.2 Value mapping function of operator ~cut~

*/
int
CutFun( Word*  args,  Word& result, int  message,
        Word&  local, Supplier s )
{
  JPEG* injpeg;
  JPEG* outjpeg;
  bool  initialized = false;
  int   x, y, xdist, ydist;

  injpeg  = ((JPEG*)args[0].addr); // JPEGSourceMgr constructed, since arg0

  if (!injpeg)
  {
    cerr << "\nerror: CutFun() received 0x00 as arg for jpeg.\n";
    jpegAlgGlobalError = true;
    result = SetWord(new JPEG(0)); // SecondoSystem doesn't cope with 0
    return 0;
  }

  initialized = injpeg->srcConnected;

  if (!initialized)
    injpeg->InitializeJPEG();

  assert(injpeg->srcConnected);
  assert(injpeg->CInfoValid());

  x     = ((CcInt*)args[1].addr)->GetIntval();
  y     = ((CcInt*)args[2].addr)->GetIntval();
  xdist = ((CcInt*)args[3].addr)->GetIntval();
  ydist = ((CcInt*)args[4].addr)->GetIntval();

  // plausibility-check
  if (    x < 0 || y < 0 || xdist <= 0 || ydist <= 0
       || (x + xdist) > (int)injpeg->GetWidth()
       || (y + ydist) > (int)injpeg->GetHeight()
     )
  {
    // this is a user error, not a JPEGAlgebra-Error
    cout << "\nCan't cut: Coordinates are not within source-jpeg.\n";
    if (!initialized)
      injpeg->DropSrcMgr();
    result = SetWord(0); // SecondoSystem doesn't cope with 0
    return 0;

    // perhaps alternatively cutting a default size ???
  }
  
  // estimate destination-FLOB size; SrcMgr will append or shrink:
  int estimatedSize = injpeg->GetFLOB(0)->Size();

  if (estimatedSize == 0)
  {
    // this _is_ a JPEGAlgebra-Error
    cerr << "\nCan't cut: Size of source-jpeg is 0!\n";
    if (!initialized)
      injpeg->DropSrcMgr();

    jpegAlgGlobalError = true;
    result = SetWord(new JPEG(0)); // SecondoSystem doesn't cope with 0
    return 0;
  }
  

  // refine estimation regarding cut-size:
  int divisor = (injpeg->GetHeight() / ydist) * (injpeg->GetWidth() / xdist);
  // injpeg->height and injpeg->width shouldn't be 0 ... but to be sure:
  if (divisor <= 0)
    divisor = 1;
  estimatedSize = estimatedSize / divisor;
                                                                                    
  outjpeg = new JPEG(estimatedSize); // constructs also FLOB of right size
                                     // doesn't need a SourceMgr, injpeg does

  if (!outjpeg)
  {
    cerr << "\nerror: CutFun() could't construct output-Jpeg.\n";
    if (!initialized)
      injpeg->DropSrcMgr();
      
    jpegAlgGlobalError = true;
    result = SetWord(new JPEG(0)); // SecondoSystem doesn't cope with 0
    return 0;
  }
                                 
  injpeg->Cut(outjpeg, x, y, xdist, ydist);
  
  if (!initialized)
    injpeg->DropSrcMgr();

  result = SetWord(outjpeg);

  return (0);
}


/*

9.9.3 Specification of operator ~cut~

*/
const string CutSpec  =
  "( ( \"Signature\" \"Syntax\" \"Meaning\" \"Example\" ) "
    "( <text>(jpeg int int int int)-> (jpeg)</text---> "
      "<text>_ cut [_, _, _, _]</text--->"
      "<text>Cuts from JPEG injpeg an area of [xdiff, ydiff] from origin (x;y)"
            " and yields the newly constructed JPEG from this.</text--->"
      "<text>query injpeg cut [x, y, xdiff, ydiff];</text--->"
  " ) )";

/*

9.9.4 Definition of operator ~cut~

*/
Operator cut (
        "cut",                  //name
        CutSpec,                //specification
        CutFun,                 //value mapping
        Operator::DummyModel,   //dummy model mapping, defined in Algebra.h
        Operator::SimpleSelect, //trivial selection function
        CutTypeMap              //type mapping
);


/*
9.9 Operator ~tiles~

Disassembles JPEG injpeg tiles of size[xdiff, ydiff] and yields stream of
these tiles. Clips the rests on the right and bottem that doesn't divide the
size.

9.9.1 Type Mapping of operator ~tiles~

The list representation is:

----    (jpeg int int)-> (stream (jpeg))
----

Example call: query injpeg tiles [xdiff, ydiff];


*/

ListExpr
TilesTypeMap( ListExpr args )
{
  ListExpr argjpeg, argxdist, argydist;

  if ( nl->ListLength(args) == 3 )
  {
    argjpeg  = nl->First(args);  //  1    2   3  
    argxdist = nl->Second(args); // (jpeg int int)
    argydist = nl->Third(args);

    if ( !(nl->IsAtom(argjpeg)  ) ||
         !(nl->IsAtom(argxdist) ) ||
         !(nl->IsAtom(argydist) ) ||
         !(nl->IsEqual(argjpeg,   "jpeg")) ||
         !(nl->IsEqual (argxdist, "int"))  ||
         !(nl->IsEqual (argydist, "int"))  )
    {
      string theErrorIs = "unspecified";

      if ( !(nl->IsAtom(argjpeg)) )
        theErrorIs = "Arg 1 is a list, not a JPEG.";
      else if ( !(nl->IsAtom(argxdist)) || !(nl->IsAtom(argydist)) )
        theErrorIs = "Arg 2 to 5 require int-Atoms.";
      else if ( !(nl->IsEqual(argjpeg,   "jpeg")) )
        theErrorIs = "Arg 1 is not a jpeg";
      else if ( !(nl->IsEqual (argxdist, "int"))  ||
                !(nl->IsEqual (argydist, "int"))     )
        theErrorIs = "One of the xdist, ydist -values is not an int.";

      ErrorReporter::ReportError("Incorrect input types for operator tiles:"
                                 + theErrorIs);
    }
    else
      return 
       nl->TwoElemList ( nl->SymbolAtom("stream"),
                         nl->TwoElemList(
                           nl->SymbolAtom("tuple"),
                           nl->OneElemList(
                               nl->TwoElemList(nl->SymbolAtom("pict"),
                                               nl->SymbolAtom("jpeg")))));

//       nl->TwoElemList( nl->SymbolAtom("stream"),
//                              nl->OneElemList(nl->SymbolAtom("jpeg"))
//                            );  // ret  (stream (jpeg))
    // correct range of int-values can't be checked here
  }
  return nl->SymbolAtom("typeerror");
}


// workaround helper class; should be replaced by better data structure
// perhaps use of CTable ....

class TupleStack {

 public:

   TupleStack(int stacksize) {
     if (stacksize < 1)
      stacksize = 1;
     arr = new Tuple*[stacksize];
     maxIndex = stacksize-1;
     size = 0;
   };

   ~TupleStack()
   {
     delete arr;
   };

   void push(Tuple * t){
     assert(size <= maxIndex);
     arr[size] = t;
     size++;
   }

   Tuple * pop()
   {
     assert(size > 0);
     Tuple * t = arr[size-1];
     size--;
     return t;
   }

   bool isEmpty()
   {
     return size == 0;
   }

   Tuple ** arr;
   int size;
   int maxIndex;

};



/*
9.9.2 Value mapping function of operator ~tiles~

*/

int
TilesFun( Word*  args,  Word& result, int  message,
          Word&  local, Supplier s )
{
  JPEG* injpeg;
  JPEG* outjpeg;
  Word injpegWord, xdistWord, ydistWord;
  //bool  initialized = false;
  int   xdist, ydist, r, c;
  int tileNo;
  int cols, rows, divisor, estimatedSize;
  ListExpr resultType;
  TupleType *tupleType;
  Tuple *t;
  TupleStack * vTiles;
  
 switch(message)
  {
    case OPEN:
      qp->Request(args[0].addr, injpegWord);
      injpeg  = ((JPEG*)injpegWord.addr); // JPEGSourceMgr constructed, since arg0

      if (!injpeg)
      {
        cerr << "\nerror: TilesFun() received 0x00 as arg for jpeg.\n";
        jpegAlgGlobalError = true;
        result = SetWord(0);
        return 0;
      }

//      initialized = injpeg->srcConnected;

//      if (!initialized)
       injpeg->InitializeJPEG();

//      assert(injpeg->srcConnected);
//      assert(injpeg->CInfoValid());

      qp->Request(args[1].addr, xdistWord);
      qp->Request(args[2].addr, ydistWord);
      xdist = ((CcInt*)xdistWord.addr)->GetIntval();
      ydist = ((CcInt*)ydistWord.addr)->GetIntval();
      rows = injpeg->GetHeight() / ydist;
      cols = injpeg->GetWidth()  / xdist;

      // estimate destination-FLOB size; SrcMgr will append or shrink:
      estimatedSize = injpeg->GetFLOB(0)->Size();

      // refine estimation regarding tile-size:
      divisor = (rows * cols);
      // injpeg->height and injpeg->width shouldn't be 0 ... but to be sure:
      if (divisor <= 0)
        divisor = 1;
      estimatedSize = estimatedSize / divisor;
      
 
      // the following checks only need to be don once, here in OPEN:
    
      // plausibility-check
      if (  xdist <= 0                      || ydist <= 0
         || xdist > (int)injpeg->GetWidth() || ydist > (int)injpeg->GetHeight()
         )
      {
        // this is a user error, not a JPEGAlgebra-Error
        cout << "\nCan't tile: Tile-Size too small or big.\n";
        result = SetWord(0);
        return 0;
      }

      if (estimatedSize == 0)
      {
        // this _is_ a JPEGAlgebra-Error
        cerr << "\nCan't tile: Size of source-jpeg is 0!\n";
        
        jpegAlgGlobalError = true;
        result = SetWord(0); 
        return 0;
      }
     
      if (rows * ydist < (int) injpeg->GetHeight())
        cout << "\nTile-Height doesn't match exactly. Bottom rest will be skipped"
             << endl;
      if (cols * xdist < (int)injpeg->GetWidth())
        cout << "\nTile-Width doesn't match exactly. Rest on the right will be "
             << "skipped\n";

      resultType = GetTupleResultType(s);
      tupleType = new TupleType (nl->Second (resultType) );

      tileNo = 0;
      vTiles = new TupleStack(rows * cols);

      for (r = rows-1; r >= 0 ; r--)
        for (c = cols -1; c >= 0 ; c--)
        {
          outjpeg = new JPEG(estimatedSize); // constructs also FLOB of right size
                                       // doesn't need a SourceMgr, injpeg does
          if (!outjpeg)
          {
            cerr << "\nerror: TilesFun() could't construct output-Jpeg.\n";
            
            jpegAlgGlobalError = true;
            result = SetWord(0); 
            return 0;
          }

          injpeg->Tile(outjpeg, c * xdist, r * ydist, xdist, ydist);

          t = new Tuple (*tupleType, true);
          t->PutAttribute(0, outjpeg);
          vTiles->arr[r*cols+c] = t;
        }

      local = SetWord(vTiles);
    
      return 0;

    case REQUEST:

      vTiles = (TupleStack*) local.addr;
      if (!vTiles->isEmpty())
      {
        t = vTiles->pop();
        result = SetWord(t);
        return YIELD;
      }
      return CANCEL;

    case CLOSE:
      vTiles = (TupleStack*) local.addr;
      delete vTiles; // JPEG * need and may not be deleted!    
      return (0);
  }
  
  // we can't arrive here only if 'message' is not faulty
  return -1;  
}

/*
9.9.2 Value mapping function of operator ~tiles~

*/
/*
int
TilesFun( Word*  args,  Word& result, int  message,
          Word&  local, Supplier s )
{
  JPEG* injpeg;
  JPEG* outjpeg;
  bool  initialized = false;
  int   x, y, xdist, ydist;
  CcInt * CcTileNo;
  int tileNo;
  int cols, rows, divisor, estimatedSize;
  Word injpegWord, xdistWord, ydistWord;
  ListExpr resultType;
  TupleType *tupleType;
  Tuple *t;

  qp->Request(args[0].addr, injpegWord);
  injpeg  = ((JPEG*)injpegWord.addr); // JPEGSourceMgr constructed, since arg0

  if (!injpeg)
  {
    cerr << "\nerror: TilesFun() received 0x00 as arg for jpeg.\n";
    jpegAlgGlobalError = true;
    result = SetWord(0);
    return 0;
  }

  initialized = injpeg->srcConnected;

  if (!initialized)
    injpeg->InitializeJPEG();

  assert(injpeg->srcConnected);
  assert(injpeg->CInfoValid());

  qp->Request(args[1].addr, xdistWord);
  qp->Request(args[2].addr, ydistWord);
  xdist = ((CcInt*)xdistWord.addr)->GetIntval();
  ydist = ((CcInt*)ydistWord.addr)->GetIntval();
  rows = injpeg->GetHeight() / ydist;
  cols = injpeg->GetWidth()  / xdist;

  // estimate destination-FLOB size; SrcMgr will append or shrink:
  estimatedSize = injpeg->GetFLOB(0)->Size();

  // refine estimation regarding tile-size:
  divisor = (injpeg->GetHeight() / ydist) * (injpeg->GetWidth() / xdist);
  // injpeg->height and injpeg->width shouldn't be 0 ... but to be sure:
  if (divisor <= 0)
    divisor = 1;
  estimatedSize = estimatedSize / divisor;


  switch(message)
  {
    case OPEN:

      // the following checks only need to be don once, here in OPEN:

      // plausibility-check
      if (  xdist <= 0                      || ydist <= 0
         || xdist > (int)injpeg->GetWidth() || ydist > (int)injpeg->GetHeight()
         )
      {
        // this is a user error, not a JPEGAlgebra-Error
        cout << "\nCan't tile: Tile-Size too small or big.\n";
        if (!initialized)
          injpeg->DropSrcMgr();
        result = SetWord(0);
        return 0;
      }

      if (estimatedSize == 0)
      {
        // this _is_ a JPEGAlgebra-Error
        cerr << "\nCan't tile: Size of source-jpeg is 0!\n";
        if (!initialized)
          injpeg->DropSrcMgr();

        jpegAlgGlobalError = true;
        result = SetWord(0);
        return 0;
      }

      if (rows * ydist < (int) injpeg->GetHeight())
        cout << "\nTile-Height doesn't match exactly. Bottom rest will be skipped"
             << endl;
      if (cols * xdist < (int)injpeg->GetWidth())
        cout << "\nTile-Width doesn't match exactly. Rest on the right will be "
             << "skipped\n";

      tileNo = 0;
      CcTileNo = new CcInt(true, tileNo);
      local = SetWord(CcTileNo);

      return 0;

    case REQUEST:

      CcTileNo = (CcInt*) local.addr;
      tileNo = CcTileNo->GetIntval();
      
      // Increment remembered tile number
      CcTileNo->Set(true, tileNo + 1);

      local = SetWord(CcTileNo);

      // actual origin to cut from?
      x = tileNo % cols;
      y = tileNo / cols;

      outjpeg = new JPEG(estimatedSize); // constructs also FLOB of right size
                                       // doesn't need a SourceMgr, injpeg does
      if (!outjpeg)
      {
        cerr << "\nerror: TielsFun() could't construct output-Jpeg.\n";
        if (!initialized)
          injpeg->DropSrcMgr();

       jpegAlgGlobalError = true;
       result = SetWord(new JPEG(0)); // SecondoSystem doesn't cope with 0
       return CANCEL;
      }

      injpeg->Tile(outjpeg, x, y, xdist, ydist); // same as Cut()

      if (!initialized)
        injpeg->DropSrcMgr();

      resultType = GetTupleResultType(s);
      tupleType = new TupleType (nl->Second (resultType) );
      t = new Tuple (*tupleType, true);
      t->PutAttribute(0, outjpeg);

      result = SetWord(t);
      return YIELD;

    case CLOSE:
      CcTileNo = (CcInt*) local.addr;
      delete CcTileNo;
      return (0);
  }

  // we can't arrive here only if 'message' is not faulty
  return -1;
}
*/
/*

9.9.3 Specification of operator ~tiles~

*/
const string TilesSpec  =
  "( ( \"Signature\" \"Syntax\" \"Meaning\" \"Example\" ) "
    "( <text>(jpeg int int)-> (stream (jpeg))</text---> "
      "<text>_ tiles [_, _]</text--->"
      "<text>Disassembles JPEG injpeg tiles of size[xdiff, ydiff]"
            " and yields stream of these tiles. Clips the rests "
            "on the right and bottem that doesn't divide the size.</text--->"
      "<text>query injpeg tiles [xdiff, ydiff];</text--->"
  " ) )";

/*

9.9.4 Definition of operator ~tiles~

*/
Operator tiles (
        "tiles",                //name
        TilesSpec,              //specification
        TilesFun,               //value mapping
        Operator::DummyModel,   //dummy model mapping, defined in Algebra.h
        Operator::SimpleSelect, //trivial selection function
        TilesTypeMap            //type mapping
);




/*
9.9 Operator ~downsize~

Reduces image quality (and therefore size) to the desired percentage.

9.9.1 Type Mapping of operator ~downsize~

The list representation is:

----    (jpeg int)-> (jpeg)
----

Example call: query injpeg downsize 45;


*/

ListExpr
DownSizeTypeMap( ListExpr args )
{
  ListExpr argjpeg, argqual;

  if ( nl->ListLength(args) == 2 )
  {
    argjpeg  = nl->First(args);  //  1    2   
    argqual  = nl->Second(args); // (jpeg int)
                                         
    if ( !(nl->IsAtom(argjpeg)  ) ||
         !(nl->IsAtom(argqual)  ) ||
         !(nl->IsEqual(argjpeg,   "jpeg")) ||
         !(nl->IsEqual (argqual,  "int"))  
       )
    {
      string theErrorIs = "unspecified";

      if ( !(nl->IsAtom(argjpeg)) )
        theErrorIs = "Arg 1 is a list, not a JPEG.";
      else if ( !(nl->IsAtom(argqual)) )
        theErrorIs = "Arg 2 requires int-Atom.";
      else if ( !(nl->IsEqual(argjpeg,   "jpeg")) )
        theErrorIs = "Arg 1 is not a jpeg";
      else if ( !(nl->IsEqual (argqual,     "int")) )
        theErrorIs = "Quality-value is not an int.";

      ErrorReporter::ReportError("Incorrect input types for operator downsize:"
                                 + theErrorIs);
    }
    else
      return nl->SymbolAtom("jpeg");  // ret  (jpeg)

    // correct range of int-values can't be checked here
  }
  return nl->SymbolAtom("typeerror");
}


/*
9.9.2 Value mapping function of operator ~downsize~

*/
int
DownSizeFun( Word*  args,  Word& result, int  message,
        Word&  local, Supplier s )
{
  JPEG* injpeg;
  JPEG* outjpeg;
  bool  initialized = false;
  int   quality;

  injpeg  = ((JPEG*)args[0].addr); // JPEGSourceMgr constructed, since arg0

  if (!injpeg)
  {
    cerr << "\nerror: DownSizeFun() received 0x00 as arg for jpeg.\n";
    jpegAlgGlobalError = true;
    result = SetWord(new JPEG(0)); // SecondoSystem doesn't cope with 0
    return 0;
  }

  initialized = injpeg->srcConnected;

  if (!initialized)
    injpeg->InitializeJPEG();

  assert(injpeg->srcConnected);
  assert(injpeg->CInfoValid());

  quality = ((CcInt*)args[1].addr)->GetIntval();

  // estimate destination-FLOB size; SrcMgr will append or shrink:
  int estimatedSize = injpeg->GetFLOB(0)->Size();

  if (estimatedSize == 0)
  {
    // this _is_ a JPEGAlgebra-Error
    cerr << "\nCan't downsize: Size of source-jpeg is 0!\n";
    if (!initialized)
      injpeg->DropSrcMgr();

    jpegAlgGlobalError = true;
    result = SetWord(new JPEG(0)); // SecondoSystem doesn't cope with 0
    return 0;
  }

  outjpeg = new JPEG(estimatedSize); // constructs also FLOB of right size
                                     // doesn't need a SourceMgr, injpeg does

  if (!outjpeg)
  {
    cerr << "\nerror: DownSizeFun() could't construct output-Jpeg.\n";
    if (!initialized)
      injpeg->DropSrcMgr();

    jpegAlgGlobalError = true;
    result = SetWord(new JPEG(0)); // SecondoSystem doesn't cope with 0
    return 0;
  }

  injpeg->DownSize(outjpeg, quality);

  if (!initialized)
    injpeg->DropSrcMgr();

  result = SetWord(outjpeg);

  return (0);
}


/*

9.9.3 Specification of operator ~downsize~

*/
const string DownSizeSpec  =
  "( ( \"Signature\" \"Syntax\" \"Meaning\" \"Example\" ) "
    "( <text>(jpeg int)-> (jpeg)</text---> "
      "<text>_ downsize _</text--->"
      "<text>Reduces image quality (and therefore size) to the desired percentage.</text--->"
      "<text>query injpeg downsize 45;</text--->"
  " ) )";

/*

9.9.4 Definition of operator ~downsize~

*/
Operator downsize (
        "downsize",                  //name
        DownSizeSpec,                //specification
        DownSizeFun,                 //value mapping
        Operator::DummyModel,   //dummy model mapping, defined in Algebra.h
        Operator::SimpleSelect, //trivial selection function
        DownSizeTypeMap              //type mapping
);



// ======================================================

/*
4.3 Operator ~compbrightdist~

This operator compares the brightnessDistribution of a stream of jpeg's
with the brightnessDistribution of a specified jpeg. So it's possible to
find all pictures with similar brightnessDistribution in the database.

The user must specifiy "how similar" the found jpeg's should be:
the given real-argument defines the per Cent (Prozentwert) distance for
every value in the brightnessDistribution, which is concerned as similar.

4.3.1 Type Mapping of operator ~comparebrightness~

The list representation is:

----    (jpeg (stream (tuple ((xi ti)*) ) ) real string)-> (stream jpeg)
----

or

----    (jpeg jpeg real dummy)                        -> (bool)
----


Operator ~compbrightdist~ accepts a

  * jpeg - object: with the brightness- Distribution of this objects all
  other brightnessDistributions of the stream are compared.

  * stream of tuples: the string represents the name of an attribute in the
  tuple. The type of this attribute must be of type jpeg. The comparison will
  work with this jpeg.

  * or alternativey another jpeg - object: the brightness- Distributions are
  compared between the two jpeg - objects.

  * real-value: the distance for evey value (0..255)

  * string: the name of the compared attribute or only a dummy

*/

ListExpr
CompareBrightnessDistributionTypeMap( ListExpr args )
{
  ListExpr arg1, arg2, arg3, arg4, attrtype;
  string attrname;
  int j;

  if ( nl->ListLength(args) == 4 )
  {
    arg1  = nl->First(args);  //   1    2              3    4
    arg2  = nl->Second(args); // ( jpeg ( stream jpeg) real attrname)
    arg3  = nl->Third(args);  //real - distance
    arg4  = nl->Fourth(args); //string - attrname

    if ( (nl->IsAtom(arg1)          ) &&
         (nl->ListLength (arg2) == 2) &&
         (nl->IsAtom(arg3)          ) &&
         (nl->IsAtom(arg4)          ) &&
         (nl->IsEqual(arg1, "jpeg") ) &&
         (nl->ListLength(nl->Second(arg2)) == 2  ) &&
         (TypeOfRelAlgSymbol(nl->First(arg2)) == stream ) &&
         (TypeOfRelAlgSymbol(nl->First(nl->Second(arg2))) == tuple   ) &&
         (nl->IsEqual (arg3, "real")) )
    {
      attrname = nl->SymbolValue(arg4);
      j = FindAttribute(nl->Second(nl->Second(arg2)), attrname, attrtype);
      if (j && nl->IsEqual (attrtype, "jpeg"))
      {
        return nl->ThreeElemList(nl->SymbolAtom("APPEND"),
                                 nl->OneElemList(nl->IntAtom(j)),
                                 nl->TwoElemList (nl->SymbolAtom("stream"),
                                                  nl->Second(arg2)));
      }
    }

    // In the case of comparison two jpeg-objects, the fourth argument is not
    // needed.

    if ( (nl->IsAtom(arg1)          ) &&   //single-jpeg object         'jpeg'
         (nl->IsAtom(arg2)          ) &&   //single-jpeg object         'jpeg'
         (nl->IsAtom(arg3)          ) &&   //real = distance value      'real'
         (nl->IsEqual(arg1, "jpeg") ) &&
         (nl->IsEqual(arg2, "jpeg") ) &&
         (nl->IsEqual(arg3, "real") ) )
    {
      return nl->SymbolAtom("bool");
    }
  }

  ErrorReporter::ReportError("Incorrect input for operator compbrightdist.");
  return nl->SymbolAtom("typeerror");
}

/*
4.3.2 Selection function of overloaded operator ~compbrightdist~

*/

static int
JPEGSelectCompbrightdist (ListExpr args)
{
  ListExpr arg1 = nl->First (args);
  ListExpr arg2 = nl->Second(args);

  if ( nl->IsEqual(arg1, "jpeg") && (nl->IsEqual(arg2, "jpeg")) )
    return (1);
  if ( nl->IsEqual(arg1, "jpeg") && (nl->IsEqual (nl->First(arg2), "stream")) )
    return (0);

  return (-1); // This point should never be reached
}

/*
4.3.2 Value mapping functions of operator ~compbrightdist~

*/

struct CompBrightDistLocalInfo
{
  double distance;
  bool isValidFirstJpeg;
  int pictIndex;
};

int
CompBDistFunJS (Word*  args,  Word&    result, int message,
                Word&  local, Supplier s)
{
  CompBrightDistLocalInfo* cli;
  Word indexWord, distance, elem, singleJpeg;
  JPEG* elemptr;
  JPEG* singleJpegPtr;

  switch (message)
  {
    case OPEN:
      //cout << "OPEN" << endl;
      qp->Open(args[1].addr);

      cli = new CompBrightDistLocalInfo;

      qp->Request(args[2].addr, distance);  // color-distance
      cli->distance = ((CcReal*)distance.addr)->GetRealval();

      qp->Request(args[0].addr, singleJpeg);
      
      singleJpegPtr = (JPEG*)singleJpeg.addr; // initialized in q-tree c'str'n
      if (!singleJpegPtr)
      {
        cerr << "\nerror: CompBDistFunJS() received 0x00 as arg for jpeg.\n";
        jpegAlgGlobalError = true;
        return 0;
      }

      cli->isValidFirstJpeg = (singleJpegPtr->GetColorSpace() == grayscale );

      qp->Request(args[4].addr, indexWord);
      cli->pictIndex = ((CcInt*)indexWord.addr)->GetIntval();

      local = SetWord (cli);
      return 0;

    case REQUEST:
      //cout << "REQUEST" << endl;
      cli = (CompBrightDistLocalInfo*) local.addr;

      qp->Request(args[0].addr, singleJpeg);            //singleJpeg
      if (singleJpeg.addr == 0)
      {
        cerr << "\nerror: CompBDistFunJS() received 0x00 as arg for jpeg.\n";
        jpegAlgGlobalError = true;
        return 0;
      }

      if (cli->isValidFirstJpeg)                   //singleJpeg == grayscale ??
      {
        qp->Request (args[1].addr, elem);               // next stream-element

        while (qp->Received(args[1].addr) )
        {
          Tuple *tu = (Tuple*)elem.addr;
          elemptr = (JPEG*) tu->GetAttribute(cli->pictIndex - 1);
          elemptr->InitializeJPEG();

          if ( elemptr->GetColorSpace() == 0 )
          {
            if ( ((JPEG*)singleJpeg.addr)->CompBright(elemptr, cli->distance) )
            {
              result = elem;
              elemptr->DropSrcMgr();
              return YIELD;
            }
            else
            {   //cout << "Do nothing" << endl;
            }
          }

          elemptr->DropSrcMgr();
          qp->Request (args[1].addr, elem);             // next stream-element
        }
      }
      else  // only consume the stream, when singleJpeg not a grayscale
      {
        qp->Request (args[1].addr, elem);               // next stream-element
        while (qp->Received(args[1].addr) )
          qp->Request (args[1].addr, elem);
      }
      return CANCEL;

    case CLOSE:
      //cout << "CLOSE" << endl;
      qp->Close(args[1].addr);
      delete cli;
      return 0;
  }

  /* should not happen */
  return -1;
}


int
CompBDistFunJJ( Word*  args,  Word&    result, int  message,
                Word&  local, Supplier s )
{
  JPEG* jfirst;
  JPEG* jsecond;
  double dist;

  jfirst  = ((JPEG*)args[0].addr);
  jsecond = ((JPEG*)args[1].addr);

  if (!jfirst || !jsecond)
  {
    cerr << "\nerror: CompBDistFunJJ() received 0x00 as one of its jpegs.\n";
    jpegAlgGlobalError = true;
    return 0;
  }

  dist = ((CcReal*)args[2].addr)->GetRealval();

  result = qp->ResultStorage (s);
  if ( (jfirst->GetColorSpace() == grayscale) &&
       (jsecond->GetColorSpace() == grayscale) )
  {
    ((CcBool*)result.addr)->Set (true, jfirst->CompBright (jsecond, dist));
  }
  else
  {
    cout << "ERROR: Operator compbrightdist expects two grayscale objects.\n";
    ((CcBool*)result.addr)->Set (true, false);
  }

  return (0);
}

/*

5.10.3 Value Mapping Vector for operator ~compbrightdist~

*/

ValueMapping JPEGCompBrightDistMap [] = {CompBDistFunJS,
                                          CompBDistFunJJ };

/*
4.3.1 The dummy model mapping:

*/
static Word
JPEGNoModelMapping( ArgVector arg, Supplier opTreeNode )
{
  return (SetWord( Address( 0 ) ));
}

/*

5.10.3 Cost Model Mapping Vector for operator ~compbrightdist~

*/

ModelMapping JPEGNoModelMap[] = {JPEGNoModelMapping,
                                 JPEGNoModelMapping};

/*

5.10.3 Specification of operator ~compbrightdist~

*/
const string CompareBrightnessDistributionSpec  =
  "( ( \"Signature\" \"Syntax\" \"Meaning\" \"Example\" ) "
    "( <text>(jpeg stream (x) real string) -> (stream (x)),"
            "((jpeg jpeg) -> bool)</text---> "
      "<text>_ _ compbrightdist [_, _]</text--->"
      "<text>Compares the BrightnessDistribution of jpeg with all Brightness"
            "Distribution of (stream(x)) within a specified distance and given"
            " jpegAttributeName. "
            "Distance is a per Cent value for each BrightnessValue.</text--->"
      "<text>query jpegObj jpegRel feed compbrightdist [0.5, pict] count; "
            "query jpegObj1 jpegObj2 compbrightdist [0.5, dummy];</text--->"
  " ) )";

/*

5.10.4 Definition of operator ~compbrightdist~

*/
Operator jpegcompbrightdist (
         "compbrightdist",                    // name
         CompareBrightnessDistributionSpec,   // specification
         2,                                   // Number of overloaded functions
         JPEGCompBrightDistMap,               // value mapping
         JPEGNoModelMap,           // dummy model mapping, defines in Algebra.h
         JPEGSelectCompbrightdist,            //  selection function
         CompareBrightnessDistributionTypeMap // type mapping
);

/*
4.3 Operator ~comprgbdist~

This operator compares the rgbDistribution of two jpeg-objects. Also a
stream of tuples with jpeg-attribute's may be given as input,
then the rgbDistribution of the single jpeg-object is compared with the
rgbDistribution of a selected jpeg-attribute of the stream.

So it's possible to find all pictures with similar rgbDistribution in the
database.

The user must specifiy "how similar" the found jpeg's should be:
the given real-argument defines the per Cent (Prozentwert) distance for
every value in the brightnessDistribution, which is concerned as similar.

The operator expects three real values, the first represents the desired
distance for red, the second the distance for green and the third the
distance for blue.

4.3.1 Type Mapping of operator ~comprgbdist~

The list representation is:

---- (jpeg (stream(tuple((xi ti)*))) real real real string)-> (stream jpeg)
----

or

----    (jpeg jpeg real real real dummy)                        -> (bool)
----

For an textual description see operator ~compbrightdist~.

*/

ListExpr
CompareRgbDistributionTypeMap( ListExpr args )
{
  ListExpr arg1, arg2, arg3, arg4, arg5, arg6, attrtype;
  string attrname;
  int j;

  if ( nl->ListLength(args) == 6 )
  {
    arg1  = nl->First(args);
    arg2  = nl->Second(args);
    arg3  = nl->Third(args);
    arg4  = nl->Fourth(args);
    arg5  = nl->Fifth(args);
    arg6  = nl->Sixth(args);

    if ( (nl->IsAtom(arg1)          ) &&
         (nl->ListLength (arg2) == 2) &&
         (nl->IsAtom(arg3)          ) &&
         (nl->IsAtom(arg4)          ) &&
         (nl->IsAtom(arg5)          ) &&
         (nl->IsAtom(arg6)          ) &&
         (nl->ListLength(nl->Second(arg2)) == 2  ) &&
         (TypeOfRelAlgSymbol(nl->First(arg2)) == stream ) &&
         (TypeOfRelAlgSymbol(nl->First(nl->Second(arg2))) == tuple   ) &&
         (nl->IsEqual (arg1, "jpeg")) &&
         (nl->IsEqual (arg3, "real")) &&
         (nl->IsEqual (arg4, "real")) &&
         (nl->IsEqual (arg5, "real")) )
    {
      attrname = nl->SymbolValue(arg6);
      j = FindAttribute(nl->Second(nl->Second(arg2)), attrname, attrtype);
      if (j && nl->IsEqual (attrtype, "jpeg"))
      {
        return nl->ThreeElemList(nl->SymbolAtom("APPEND"),
                                 nl->OneElemList(nl->IntAtom(j)),
                                 nl->TwoElemList (nl->SymbolAtom("stream"),
                                                  nl->Second(arg2)));
      }
    }

    if ( (nl->IsAtom(arg1)          ) &&   //single-jpeg object         'jpeg'
         (nl->IsAtom(arg2)          ) &&   //single-jpeg object         'jpeg'
         (nl->IsAtom(arg3)          ) &&   //real = distance value      'real'
         (nl->IsAtom(arg4)          ) &&
         (nl->IsAtom(arg5)          ) &&
         (nl->IsEqual(arg1, "jpeg") ) &&
         (nl->IsEqual(arg2, "jpeg") ) &&
         (nl->IsEqual(arg3, "real") ) &&
         (nl->IsEqual(arg4, "real") ) &&
         (nl->IsEqual(arg5, "real") ) )
    {
        return nl->SymbolAtom("bool");
    }

  }
  ErrorReporter::ReportError("Incorrect input for operator compbrightdist.");
  return nl->SymbolAtom("typeerror");
}

/*
4.3.2 Selection function of overloaded operator ~compbrightdist~

*/

static int
JPEGSelectComprgbdist (ListExpr args)
{
  ListExpr arg1 = nl->First (args);
  ListExpr arg2 = nl->Second(args);

  if ( nl->IsEqual(arg1, "jpeg") && (nl->IsEqual(arg2, "jpeg")) )
    return (1);
  if ( nl->IsEqual(arg1, "jpeg") &&
     ( !(nl->IsAtom(arg2)) &&
      (nl->IsEqual (nl->First(arg2), "stream"))) )
    return (0);


  return (-1); // This point should never be reached
}

/*
4.3.2 Value mapping functions of operator ~compbrightdist~

*/

struct CompRgbDistLocalInfo
{
  double rdist;
  double gdist;
  double bdist;
  bool isValidFirstJpeg;
  int pictIndex;
};

int
CompRgbDistribFunJS(Word* args, Word& result, int message,
                                             Word& local, Supplier s)
{
  CompRgbDistLocalInfo* rgbli;
  Word rdist, gdist, bdist, elem, singleJpeg, indexWord;
  JPEG* elemptr;
  JPEG* singleJpegPtr;

  switch (message)
  {
    case OPEN:
      //cout << "OPEN" << endl;
      qp->Open(args[1].addr);	// opens input-Stream (arg 2)

      rgbli = new CompRgbDistLocalInfo;

      qp->Request(args[2].addr, rdist);  // r color-distance
      rgbli->rdist = ((CcReal*)rdist.addr)->GetRealval();

      qp->Request(args[3].addr, gdist);  // g color-distance
      rgbli->gdist = ((CcReal*)gdist.addr)->GetRealval();

      qp->Request(args[4].addr, bdist);  // b color-distance
      rgbli->bdist = ((CcReal*)bdist.addr)->GetRealval();

      qp->Request(args[0].addr, singleJpeg);
      singleJpegPtr = (JPEG*)singleJpeg.addr;
      if (!singleJpegPtr)
      {
        cerr << "\nerror: CompRgbDistribFunJS() received 0x00 as arg "
                "for jpeg.\n";
        jpegAlgGlobalError = true;
        return 0;
      }

      rgbli->isValidFirstJpeg = (singleJpegPtr->GetColorSpace() == 1 );

      qp->Request(args[6].addr, indexWord);
      rgbli->pictIndex = ((CcInt*)indexWord.addr)->GetIntval();

      local = SetWord (rgbli);
      return 0;

    case REQUEST:
      //cout << "REQUEST" << endl;
      rgbli = (CompRgbDistLocalInfo*) local.addr;

      qp->Request(args[0].addr, singleJpeg);            //singleJpeg
      singleJpegPtr = (JPEG*)singleJpeg.addr;
      if (!singleJpegPtr)
      {
        cerr << "\nerror: CompRgbDistribFunJS() received 0x00 as arg "
                "for jpeg.\n";
        jpegAlgGlobalError = true;
        return 0;
      }
      
      if (rgbli->isValidFirstJpeg)                      
      {
        qp->Request (args[1].addr, elem);               // next stream-element

        while (qp->Received(args[1].addr) )
        {
          Tuple *tu = (Tuple*)elem.addr;
          elemptr = (JPEG*) tu->GetAttribute(rgbli->pictIndex - 1);
          elemptr->InitializeJPEG();

          if ( elemptr->GetColorSpace() == 1 )
          {
            if ( singleJpegPtr->CompRgb(elemptr, rgbli->rdist,
                                                 rgbli->gdist, rgbli->bdist) )
            {
              result = elem;
              elemptr->DropSrcMgr();
              return YIELD;
            }
          }
          else
          {
            //cout << "Do nothing" << endl;
          }
          elemptr->DropSrcMgr();
          qp->Request (args[1].addr, elem);             // next stream-element
        }
      }
      else
      {
        qp->Request (args[1].addr, elem);               // next stream-element
        while (qp->Received(args[1].addr) )
          qp->Request (args[1].addr, elem);
      }
      return CANCEL;

    case CLOSE:
      //cout << "CLOSE" << endl;
      qp->Close(args[1].addr);
      delete rgbli;
      return 0;
  }
  /* should not happen */
  return -1;
}


int
CompRgbDistribFunJJ(Word* args, Word& result, int message,
                                             Word& local, Supplier s)
{
  JPEG* jfirst;
  JPEG* jsecond;
  double rdist;
  double gdist;
  double bdist;

  jfirst  = ((JPEG*)args[0].addr);
  jsecond = ((JPEG*)args[1].addr);
  if (!jfirst || !jsecond)
  {
    cerr << "\nerror: CompRgbDistribFunJJ() received 0x00 as one of its "
            "jpegs.\n";
    jpegAlgGlobalError = true;
    return 0;
  }
  
  rdist = ((CcReal*)args[2].addr)->GetRealval();
  gdist = ((CcReal*)args[3].addr)->GetRealval();
  bdist = ((CcReal*)args[4].addr)->GetRealval();

  result = qp->ResultStorage (s);
  if ( (jfirst->GetColorSpace() == 1) &&
       (jsecond->GetColorSpace() == 1) )
  {
    ((CcBool*)result.addr)->Set (true, jfirst->CompRgb (jsecond, rdist, gdist, bdist));
  }
  else
  {
    cout << "ERROR: Operator comprgbdist expects two rgb objects." << endl;
    ((CcBool*)result.addr)->Set (true, false);
  }

  return (0);
}

/*

5.10.3 Value Mapping Vector for operator ~comprgbdist~

*/

ValueMapping JPEGCompRgbDistMap [] = {CompRgbDistribFunJS,
                                          CompRgbDistribFunJJ };

/*

5.10.3 Specification of operator ~comprgbdist~

*/
const string CompareRgbDistributionSpec  =
  "( ( \"Signature\" \"Syntax\" \"Meaning\" \"Example\" ) "
    "( <text>(jpeg (stream (x)) real real real string)) -> (stream (x)),"
            "((jpeg jpeg real real real string) -> bool)</text---> "
      "<text>_ _ comprgbdist [_, _, _, _]</text--->"
      "<text>Compares the RGB-Distributions of jpeg with all "
            "RGB-Distributions of (stream(x)) within a specified distance. "
            "Distance is a per Cent value for each RGB-Value."
            "First real for red, second for green, third for blue."
            "The jpeg-Attributename is given as a string.</text--->"
      "<text>query jpegObj jpegRel feed comprgbdist [0.5, 0.1, 0.3, pict] count; "
            "query jpegObj1 jpegObj2 comprgbdist [0.5, 0.2, 0.3, dummy]</text--->"
  " ) )";

/*

5.10.4 Definition of operator ~comprgbdist~

*/
Operator jpegcomprgbdist (
         "comprgbdist",                       // name
         CompareRgbDistributionSpec,          // specification
         2,                                   // Number of overloaded functions
         JPEGCompRgbDistMap,                  // value mapping
         JPEGNoModelMap,           // dummy model mapping, defines in Algebra.h
         JPEGSelectComprgbdist,               //  selection function
         CompareRgbDistributionTypeMap        // type mapping
);



/*******************************************************************************
\rule {0 pt}{0 pt} \linebreak

*******************************************************************************/
/******************************************************************************
e n d\space\space   S e c o n d o - S u p p o r t - F u n c t i o n s,
        O p e r a t o r s   a n d   T y p e   C o n s t r u c t o r s \space
        f o r \linebreak J P E G

******************************************************************************/
/*******************************************************************************
\rule {460 pt}{1 pt} \linebreak
[newpage]

*******************************************************************************/

/*******************************************************************************
6 Type Constructor ~jinfo~: Implementation

*******************************************************************************/

/*
The intended use for the ~jinfo~-type constructor ist ONLY to get a nested list
representation of jpeg - objects. It is NOT intended to type a "let" command
manually by the user of the secondo-system.

The intended way is the use of the ~jinfo~-type constructor in conjunction with
the ~jreadinfo~ - operator. The ~jreadinfo~ operator computes the hundreds of
values necessary for ~jinfo~ and generates the jinfo objects.

*/

JINFO::JINFO(bool D, int inHeight, int inWidth,
             bool inColoured, int inCS, int inNumComp,
             ListExpr inPict)
{
  defined = D;
  height = inHeight;
  width = inWidth;
  coloured = inColoured;
  colorSpace = (colorS) inCS;
  numComponents = inNumComp;
  for (int j = 0; j <= 3; j++)
    for (int i = 0; i <=255; i++)
      cDistribution[i][j] = 0.0;
  picture = inPict;
}

JINFO::~JINFO() {}

int JINFO::GetHeight()
{
  assert( IsDefined() );
  return height;
}

int JINFO::GetWidth()
{
  assert( IsDefined() );
  return width;
}

bool JINFO::IsColoured()
{
  return coloured;
}

colorS JINFO::GetColorSpace()
{
  return colorSpace;
}

int JINFO::Get_num_components()
{
  return numComponents;
}

void JINFO::GetcDistribution(double outDistr[256][4])
{
  for (int k = 0; k <= 3; k++)
    for (int i = 0; i <= 255; i++)
      outDistr[i][k] = cDistribution[i][k];
}

ListExpr JINFO::GetPictureList()
{
  return picture;
}

void  JINFO::Set( const bool D,
                  const int  inHeight,       const int inWidth,
                  const bool inColoured,     const int inCS,
                  const int  inNumComponents, ListExpr inPict)
{
  defined  = D;
  height   = inHeight;
  width    = inWidth;
  coloured = inColoured;
  colorSpace    = (colorS) inCS;
  numComponents = inNumComponents;
  picture = inPict;
}


/******************************************************************************
[2] The following virtual functions are used for porting ~jinfo~ to Tuple.

******************************************************************************/

/*
The function Compare() defines a total order on the data type ~JINFO~.

*/
int JINFO::Compare(Attribute *arg)
{
 return (0);
}

bool JINFO::Adjacent(Attribute * arg)
{
    return false;
    //for pictures we can not decides whether they are adjacent or not.
}

JINFO* JINFO::Clone()
{
  return new JINFO ( *this );
}

bool JINFO::IsDefined() const
{
  return defined;
}

void JINFO::SetDefined( bool Defined )
{
  defined = Defined;
}

void JINFO:: SetcDistribution (int compIndex, int comp, double value)
{
  cDistribution[compIndex][comp] = value;
}

int  JINFO::Sizeof() const
{
  return sizeof(JINFO);
}

size_t JINFO::HashValue()
{
    if(!defined)  return (0);
    int h;
    int x = GetHeight();
    int y = GetWidth();
    int z = GetColorSpace();
    h = (int) (5 * x + z * y);
    return size_t (h);
}

void JINFO::CopyFrom(StandardAttribute* right)
{
  if (!right)
  {
    cerr << "\nerror: JINFO::CopyFrom() received 0x00 as StandardAttribute*."
         << endl;
    defined = false;
    jpegAlgGlobalError = true;
    return;
  }

  JINFO* j = (JINFO*)right;
  defined = j->IsDefined();
  if (defined)
  {
      Set( true,
           j->GetHeight(),          j->GetWidth(),
           j->IsColoured(),         j->GetColorSpace(),
           j->Get_num_components(), j->GetPictureList() );
  }
}

ostream& operator<<( ostream& o, JINFO& p )
{
  if( p.IsDefined() )
    o << "("  << p.GetHeight()      << ", " << p.GetWidth() << p.IsColoured()
      << ", " << p.GetColorSpace()  << ", " << p.Get_num_components()
      << ", " << p.GetPictureList() << ")";
  else
    o << "undef";

  return o;
}

ostream& JINFO::Print( ostream &os )
{
    if (defined)
      return (os <<  height << ", " << width << coloured << ", " << colorSpace
                 << ", "    << numComponents << ", "     << GetPictureList());
    else    return (os << "undefined");
}

/*
6.1 List Representation


The list representation is given through three sublists:

The first list contains the metadata, which is also given through the jpeg-
header. These are: Height, Width, IsColoured, ColorSpace and
Number\_of\_Color\_Components.

The second list contains four sublists, one sublist for every colorComponent.
Every represents the brightness or ColorDistribution of the jpeg. So the
sublist has 256 values representing the Distribution for this colorCompnent in
ascending order (from 0 to 255).

The third list contains the jpeg-picture in Base64 coded form.


----      ( (height width coloured colorSpace numComponents)
          ( (0.13 0.45 0.00 ..... 0.00 0.01)
            (0.00 0.1 0.2 ....     0.01 0.00)
            (0.00 0.1 0.1 ....      0.00 0.00)
            (0.0 0.0 ...            0.00 0.00) )
            (Base64CodedPicture) )
----

*/

/*
6.2 ~In~ and ~Out~ Functions

*/

/*
~OutJINFO~ generates the Nested List representation from the internal
representation.

*/
ListExpr
OutJINFO( ListExpr typeInfo, Word value )
{
  ListExpr Metadata, comp[4], appendList[4];
  JINFO* j;
  j = (JINFO*)(value.addr);

  if (!j)
    cerr << "\nerror: OutJINFO() received 0x00 as JINFO-address.\n";

  if( j &&
      j->IsDefined() )
  {
    double Distr[256][4];
    j->GetcDistribution(Distr);
    /* for (int k = 0; k <= 3; k++)
         for (int i = 0; i <= 255; i++)
           cout << "Comp:" << k << "   Index:" << i
                << "    Value:" << Distr[i][k] << endl; */

    Metadata = nl->FiveElemList(nl->IntAtom(j->GetHeight()),
                                nl->IntAtom(j->GetWidth()),
                                nl->BoolAtom(j->IsColoured()),
                                nl->IntAtom(j->GetColorSpace()),
                                nl->IntAtom(j->Get_num_components()) );

    for (int k = 0; k <= 3; k++)
    {
      //cout << "Create FirstElementOfList" << endl;
      comp[k] = nl->OneElemList(nl->RealAtom(Distr[0][k]));
      appendList[k] = comp[k];

      for (int l = 1; l <= 255; l++)
      {
        //cout << "Before Create NextElementOfList" << endl;
        appendList[k] = nl->Append(appendList[k],nl->RealAtom(Distr[l][k]));
        //cout << "After Create FirstElementOfList" << endl;
      }
    }

    return nl->ThreeElemList(
                    Metadata,
                    nl->FourElemList(comp[0], comp[1], comp[2], comp[3]),
                    nl->OneElemList(j->GetPictureList()) );
  }
  else
  {
    jpegAlgGlobalError = true;
    return (nl->SymbolAtom("undef"));
  }
}

/*
~InJINFO~ generates the internal representation from the Nested List
representation.

*/
Word
InJINFO( const ListExpr typeInfo, const ListExpr instance,
       const int errorPos, ListExpr& errorInfo, bool& correct )
{
  JINFO* newjinfo;

  if ( nl->ListLength( instance ) == 3 )
  {
    ListExpr First = nl->First(instance);
    ListExpr Second = nl->Second(instance);
    ListExpr Third = nl->Third(instance);

   if ( (nl->ListLength(First) == 5) &&
         (nl->ListLength(Second) == 4) )
   {
     ListExpr Dist[4];
     Dist[0] = nl->First(Second);
     Dist[1] = nl->Second(Second);
     Dist[2] = nl->Third(Second);
     Dist[3] = nl->Fourth(Second);

     ListExpr First1 = nl->First(First);
     ListExpr First2 = nl->Second(First);
     ListExpr First3 = nl->Third(First);
     ListExpr First4 = nl->Fourth(First);
     ListExpr First5 = nl->Fifth(First);

     if ( (nl->ListLength(Dist[0]) == 256) &&
          (nl->ListLength(Dist[1]) == 256) &&
          (nl->ListLength(Dist[2]) == 256) &&
          (nl->ListLength(Dist[3]) == 256) &&
           nl->IsAtom(First1) && nl->AtomType(First1) == IntType &&
           nl->IsAtom(First2) && nl->AtomType(First2) == IntType &&
           nl->IsAtom(First3) && nl->AtomType(First3) == BoolType &&
           nl->IsAtom(First4) && nl->AtomType(First4) == IntType &&
           nl->IsAtom(First5) && nl->AtomType(First5) == IntType )
     {
       correct = true;
       newjinfo = new JINFO(false, nl->IntValue(First1), nl->IntValue(First2),
                            nl->BoolValue(First3), nl->IntValue(First4),
                            nl->IntValue(First5), Third );

       ListExpr FirstVal, RestVal;
       for (int compIndex = 0; compIndex <= 3; compIndex++)
       {
          RestVal = Dist[compIndex];
          for (int cdx = 0; cdx <= 255; cdx ++)
          {
            FirstVal = nl->First(RestVal);
            RestVal = nl->Rest(RestVal);
            newjinfo->SetcDistribution(cdx, compIndex, nl->RealValue(FirstVal));
          }
       }

       newjinfo->SetDefined (true);

       return SetWord(newjinfo);
     }
    }
  }
  correct = false;
  return SetWord(Address(0));
}

/*
6.3 Functions Describing the Signature of the Type Constructors

This one works for type constructors ~jinfo~.

*/
ListExpr
JINFOProperty()
{
  return (nl->TwoElemList(
     nl->SixElemList(nl->StringAtom("Signature"),
        nl->StringAtom("Example Type List"),
        nl->StringAtom("List Rep"),
        nl->StringAtom("Example List"),
        nl->StringAtom("..."),
        nl->StringAtom("Remarks")),
     nl->SixElemList(nl->StringAtom("-> DATA"),
        nl->StringAtom("jinfo"),
        nl->StringAtom("((height width coloured colorSpace numComponents"),
        nl->StringAtom(") ( 4 lists with( 256 real-values))(B64codPict))"),
        nl->StringAtom("((275 215 TRUE 1 1)( 4 lists (0.1..5.0)(xxx))"),
        nl->StringAtom("All Distributions have exact 256 values!"))));

/*      nl->StringAtom("((height width coloured colorSpace numComponents)"
                       "( (0.13...0.01)(0.00...0.5)(0.0...1.0)(5.0...0.0)))"),
        nl->StringAtom("((275 215 TRUE 1 1)((0.13...0.01)(0.1...0.0)"
                       "(0.0...0.0)(0.0...0.0)))"),
        nl->StringAtom("All Distributions have exact 256 values! Only for use"
                       " with oprator jreadinfo!")))); */
}


Word
CreateJINFO( const ListExpr typeInfo )
{
  return (SetWord( new JINFO( false, 0, 0, false, 0, 0, nl->TheEmptyList())));
}

void
DeleteJINFO( Word& w )
{
  if (w.addr == 0)
  {
    cerr << "\nerror: DeleteJINFO() received 0x00 as JINFO-address.\n";
    jpegAlgGlobalError = true;
  }
  else
    delete (JINFO *)w.addr;
  w.addr = 0;
}

void
CloseJINFO( Word& w )
{
  if (w.addr == 0)
  {
    cerr << "\nerror: CloseJINFO() received 0x00 as JINFO-address.\n";
    jpegAlgGlobalError = true;
  }
  else
    delete (JINFO *)w.addr;
  w.addr = 0;
}

Word
CloneJINFO( const Word& w )
{
  if (w.addr == 0)
  {
      cerr << "\nerror: CloneJINFO() received 0x00 as JINFO-address.\n";
      jpegAlgGlobalError = true;
      return SetWord(0);
  }
  else
    return SetWord( ((JINFO *)w.addr)->Clone() );
}

/*
6.4 Kind Checking Function

This function checks whether the type constructor is applied correctly. Since
type constructor ~jinfo~ does not have arguments, this is trivial.

*/
bool
CheckJINFO( ListExpr type, ListExpr& errorInfo )
{
  return (nl->IsEqual( type, "jinfo" ));
}

/*
6.5 ~Cast~-function

*/
void* CastJINFO( void* addr )
{
  if (!addr)
  {
    cerr << "\nerror: CastJINFO() received 0x00 as JINFO-address.\n";
    jpegAlgGlobalError = true;
    return 0;
  }
  else
    return new (addr) JINFO;
}

/*
6.6 ~SizeOf~-function

*/
int
SizeOfJINFO()
{
  return sizeof(JINFO);
}

/*
6.7 Creation of the Type Constructor Instance

*/
TypeConstructor jinfo(
        "jinfo",                     //name
        JINFOProperty,               //property function describing signature
        OutJINFO,     InJINFO,       //Out and In functions
        0,            0,             //SaveToList and RestoreFromList functions
        CreateJINFO,  DeleteJINFO,   //object creation and deletion
        0, 0, CloseJINFO, CloneJINFO,//object open, save, and close
        CastJINFO,                   //cast function
        SizeOfJINFO,                 //SizeOf function
        CheckJINFO,                  //kind checking function
        0,                           //predef. pers. function for model
        TypeConstructor::DummyInModel,
        TypeConstructor::DummyOutModel,
        TypeConstructor::DummyValueToModel,
        TypeConstructor::DummyValueListToModel );


/*
6.8 Operator ~jreadinfo~

This is only to get the metadata of a jpegObject in the form of a NestedList.

4.3.1 Type Mapping of operator ~jreadinfo~

Operator ~jreadinfo~ accepts a jpeg-Object, reads the metadata and stores this
in a jinfo Object. This Object should/could be used from the viewer.
Further on, a stream-Object is accepted. The attrname of a jpeg-Attribute is
given from the user. For this attribute the jinfo-Object ist created and
passed as a stream of jinfo-Objects.

----    (jpeg)               -> jinfo
        (stream(x) attrname  -> stream (x)
----

*/

ListExpr
JRInfoTypeMap( ListExpr args )
{
  // single jpeg-Object to work with
  if ( nl->ListLength(args) == 2 )
  {
    ListExpr arg1, arg2;
    arg1 = nl->First(args);
    arg2 = nl->Second(args);

    if ( nl->IsAtom (arg1) &&
         nl->IsEqual(arg1, "jpeg") &&
         nl->IsAtom (arg2) )
      return nl->SymbolAtom("jinfo");

    if ( (nl->ListLength(arg1) == 2) &&
         (TypeOfRelAlgSymbol(nl->First(arg1)) == stream) &&
         (TypeOfRelAlgSymbol(nl->First(nl->Second(arg1))) == tuple ) &&
         (nl->IsAtom(arg2)) )
      {
        ListExpr attrtype;
        string attrname = nl->SymbolValue(arg2);
        cout << endl;
        int j = FindAttribute(nl->Second(nl->Second(arg1)),attrname,attrtype);
        if (j && nl->IsEqual (attrtype, "jpeg"))
        {
          ListExpr outList =
              (nl->ThreeElemList(
                   nl->SymbolAtom("APPEND"),
                   nl->OneElemList(nl->IntAtom(j)),
                   nl->TwoElemList (
                       nl->SymbolAtom("stream"),
                       nl->TwoElemList(
                           nl->SymbolAtom("tuple"),
                           nl->OneElemList(
                               nl->TwoElemList(nl->SymbolAtom("info"),
                                               nl->SymbolAtom("jinfo")))))));


          //nl->WriteListExpr (outList, cout); cout << endl;
          return outList;
        }
      }
  }

  return nl->SymbolAtom("typeerror");
}

/*
6.8.1 Selection function of overloaded operator ~jreadinfo~

*/

static int
JRInfoSelect (ListExpr args)
{
  ListExpr arg1 = nl->First (args);

  if ( nl->IsAtom(arg1) && nl->IsEqual(arg1, "jpeg") )
    return (0);
  if ( (nl->ListLength(arg1) == 2) && nl->IsEqual(nl->First(arg1), "stream") )
    return (1);

  return (-1); // This point should never be reached
}

/*
6.8.2 Value mapping functions of operator ~jreadinfo~

*/
int
JRInfoFunJ(Word* args, Word& result, int message, Word& local, Supplier s)
{
  JPEG* jpeg;
  JINFO* jinfo;

  jpeg = ((JPEG*)args[0].addr);
  if (!jpeg)
  {
    cerr << "\nerror: JRInfoFunJ(() received 0x00 as Jpeg-address.\n";
    result = SetWord(0);
    jpegAlgGlobalError = true;
    return 0;
  }

  jinfo = new JINFO (true,
                     (int) jpeg->GetHeight(),
                     (int) jpeg->GetWidth(),
                     jpeg->IsColoured(),
                     (int) jpeg->GetColorSpace(),
                     jpeg->Get_num_components(),
                     OutJPEG(nl->TheEmptyList(), SetWord(jpeg)));

  switch ( jpeg->GetColorSpace() )
  {
    case 0:          //grayscale
      for (int i = 0; i <= 255; i++)
         jinfo->SetcDistribution(i, 0, jpeg->GetBrightnessValue (i));
      break;
    case 1:          //RGB
      for (int comp = 0; comp <= 2; comp++)
        for (int idx = 0; idx <= 255; idx ++)
          jinfo->SetcDistribution(idx, comp, jpeg->GetRGBValue(comp, idx));
      break;
    default:
      jinfo->SetDefined (false);
      break;
  }

  result = qp->ResultStorage(s);
  *((JINFO*)result.addr)=*jinfo;
  return 0;
}

int
JRInfoFunS(Word* args, Word& result, int message, Word& local, Supplier s)
{
  Word elem, indexWord;
  Tuple* tu;
  JPEG* elemPtr;
  JINFO* jinfo;
  int index;

  switch (message)
  {
    case OPEN:
    {
      //cout << "OPEN" << endl;

      ListExpr resultType = GetTupleResultType(s);
      //cout << "resultType:"; nl->WriteListExpr (resultType, cout);
      //cout << endl;
      TupleType *tupleType = new TupleType (nl->Second (resultType) );
      local.addr = tupleType;

      qp->Open (args[0].addr);
      return (0);
    }
    case REQUEST:
    {
      //cout << "REQUEST" << endl;
      qp->Request (args[0].addr, elem);
      while (qp->Received(args[0].addr))
      {
        qp->Request(args[2].addr, indexWord);
        index = ((CcInt*)indexWord.addr)->GetIntval();
        //Could be: working with localInfo is more efficient !!

        tu = (Tuple*)elem.addr;
        elemPtr = (JPEG*) tu->GetAttribute(index -1);
        assert(elemPtr);
/*
InitializeJPEG() of JPEG is not allways necessary. E.g. it is not necessary for
accessing width, height, ... It is also not necessary for a simple 'query
reljpeg;' or ' ... consume'. InitializeJPEG() could be placed in CastJPEG but
this would be inefficient for many cases. But for GetBrightnessValue() e.g.,
which delegates filling of the distri-array to JPEGSourceMgr it is necessary.
Without, there is no loss of data (since FLOB resides in picture) but only
loss in operational, computational capabilities (scanning content of FLOB).

*/
        elemPtr->InitializeJPEG(); // JPEGSourceMgr should be destroyed again
        jinfo = new JINFO (true,
                           (int) elemPtr->GetHeight(),
                           (int) elemPtr->GetWidth(),
                           elemPtr->IsColoured(),
                           (int) elemPtr->GetColorSpace(),
                           elemPtr->Get_num_components(),
                           OutJPEG(nl->TheEmptyList(), SetWord(elemPtr)));

        switch ( elemPtr->GetColorSpace() )
        {
          case 0:                       //grayscale
          {
             for (int i = 0; i <= 255; i++)
              jinfo->SetcDistribution(i, 0, elemPtr->GetBrightnessValue (i));
            break;
          }
          case 1:                       //RGB
          {
            for (int comp = 0; comp <= 2; comp++)
              for (int idx = 0; idx <= 255; idx ++)
                jinfo->SetcDistribution(idx, comp, elemPtr->GetRGBValue(comp, idx));
            break;
          }
          default:
          {
            jinfo->SetDefined (false);
            break;
          }
        }

        // create the new tuple for result-stream
        TupleType *tupleType = (TupleType*)local.addr;
        Tuple *t = new Tuple (*tupleType, true); // true means: IsFree == true
        assert ( t->IsFree() );

        t->PutAttribute(0, (JINFO*)jinfo);

        tu->DeleteIfAllowed(); // delete the input-stream-element

        elemPtr->DropSrcMgr(); // // JPEGSourceMgr should be destroyed again

        result = SetWord(t);
        return YIELD;
      }
      return CANCEL;
    }
    case CLOSE:
    {
      //cout << "CLOSE" << endl;
      delete (TupleType*)local.addr;
      qp->Close(args[0].addr);
      return 0;
    }
  }

  return -1; // should never happen
}
/*

6.8.3 Value Mapping Vector for operator ~jreadinfo~

*/

ValueMapping JRInfoMap [] = {JRInfoFunJ,
                             JRInfoFunS };

/*

6.8.4 Cost Model Mapping Vector for operator ~jreadinfo~

*/

ModelMapping JRInfoModelMap[] = {JPEGNoModelMapping,
                                 JPEGNoModelMapping};

/*
6.8.5 Specification of operator ~jreadinfo~

*/
const string JRInfoSpec  =
 "( ( \"Signature\" \"Syntax\" \"Meaning\" \"Example\" ) "
   "( <text>(jpeg) -> (jinfo), (stream (x) string )-> stream (jinfo)</text--->"
     "<text>_ jreadinfo [_]</text--->"
     "<text>For use with viewer. Brings jpeg-(Meta)Data in a NestedList-Form."
     "</text--->"
     "<text>query jpegObject jreadinfo [dummy]; "
     "query jpegRelation feed jreadinfo [pict] consume;</text--->"
 ") )";

/*
6.8.6 Definition of operator ~demo~

*/
Operator jreadinfo (
        "jreadinfo",                 //name
        JRInfoSpec,                  //specification
        2,                           //Number of overloaded functions
        JRInfoMap,                   //value mapping
        JRInfoModelMap,        //dummy model mapping, defined in Algebra.h
        JRInfoSelect,                //trivial selection function
        JRInfoTypeMap                //type mapping
);


/*******************************************************************************
\rule {460 pt}{1 pt} \linebreak

*******************************************************************************/
/*******************************************************************************
7 Creating the Algebra  (class ~JPEGAlgebra~)

*******************************************************************************/

class JPEGAlgebra : public Algebra
{
 public:
  JPEGAlgebra() : Algebra()
  {
    AddTypeConstructor( &jpeg );
    AddTypeConstructor( &jinfo );

    jpeg.AssociateKind("DATA");
    jpeg.AssociateKind("FILE");
    jinfo.AssociateKind("DATA");

    AddOperator( &savejpegto );
    AddOperator( &show );
    AddOperator( &demo );
    AddOperator( &col_d_test );
    AddOperator( &cut );
    AddOperator( &tiles );
    AddOperator( &downsize );
    AddOperator( &jpegcompbrightdist);
    AddOperator( &jpegcomprgbdist);
    AddOperator( &jreadinfo );

    jpegAlgGlobalError = false;

    #ifdef DEBUGJPEG
    cout << "\nConstructor JPEGAlgebra. ";
    printStatistics();
    #endif
  }
  ~JPEGAlgebra() {

    cout << "\nDestructor JPEGAlgebra. ";
    printStatistics();

    if (jpegAlgGlobalError)
      cerr << "\n\nERROR: There has occured an error inside JPEGAlgebra:"
           <<   "\n       may be serious or not .... \n\n";
    else
      cout << "\n\nJPEGAlgebra worked without an error found,  :)))\n"
                  "(User errors not counted, nor SecondoSystem-faults)\n\n";
  };

  void printStatistics()
  {
    cout << "Number of JPEGs: "       << JPEG::GetNumAlive()
         << "\n( cast: "               << JPEG::castJPEGs
         << " cloned: "               << JPEG::clonedJPEGs
         << " created: "              << JPEG::createdJPEGs
         << " closed: "               << JPEG::closedJPEGs
         << " deleted: "              << JPEG::deletedJPEGs<< " )"
         << "\nNumber of SourceMgrs: "<< JPEGSourceMgr::GetNumAlive()
         << " of overall c'str'd: "   << JPEGSourceMgr::GetCounter()
                                      << endl;
  }

};

JPEGAlgebra jpegAlgebra;



/*******************************************************************************
\rule {460 pt}{1 pt}

*******************************************************************************/
/******************************************************************************
C o n n e c t i o n . . t o . . t h e . . S e c o n d o - S y s t e m

******************************************************************************/

/*
8 Initialization

Each algebra module needs an initialization function. The algebra manager
has a reference to this function if this algebra is included in the list
of required algebras, thus forcing the linker to include this module.

The algebra manager invokes this function to get a reference to the instance
of the algebra class and to provide references to the global nested list
container (used to store constructor, type, operator and object information)
and to the query processor.

The function has a C interface to make it possible to load the algebra
dynamically at runtime.

*/

extern "C"
Algebra*
InitializeJPEGAlgebra( NestedList* nlRef, QueryProcessor* qpRef )
{
  nl = nlRef;
  qp = qpRef;
  return (&jpegAlgebra);
}

/*
//paragraph [1] title: [{\Large \bf ]	[}]
//paragraph [2] subtitle: [{\bf ]	[}]
//[->] [$\rightarrow $]
//[=>] [$=> $]
//[TOC] [\tableofcontents]
//[newpage] [\newpage]


[1] (JPEG) Source Manager for JPEGAlgebra, Header-File

February 06    2004  Neumann (formatting,  removed unused methods)

January  14    2004  Schoenhammer (color-/brightness-distribution, testing),
                     Neumann (integration in JPEGSourceMgr, general revision)

January 08/09  2004    Neumann


1 JPEGSourceMgr: Defines, includes, types, forward declarations

*/

#ifndef JPEGSOURCEMGR_H
#define JPEGSOURCEMGR_H

using namespace std;

#include "JPEGAlgebra.h"

extern "C" {

// out-comment to see internal libjpeg-datastructures for debugging:
#define JPEG_INTERNALS

#ifdef JPEG_INTERNALS
#include "./DebugOnLinuxGNU/jpeglib.h"
#else
#include "jpeglib.h"
#endif

#include "jerror.h"
// for jmp_buf in followin struct and setjmp(jerr.setjmp_buffer) in init():
#include <setjmp.h>
#include "../Relation-C++/RelationAlgebra.h"


// The Error-Manager is afforded for (de-)compress-fns();
// jpeg\_error\_mgr: jpeglib.h line 643 ff, stores also user-error-functions:

  struct my_error_mgr
  {
    struct jpeg_error_mgr pub;
    jmp_buf setjmp_buffer;
  };

typedef struct my_error_mgr * my_error_ptr;

}

// forward declaration needed for compiler's signature checks:

class JPEG;

/**
2 Class JPEGSourceMgr - The libjpeg side of the interface. Interface.

Class JPEGSourceMgr is essentially a libjpeg-wrapper (C-Code !) for JPEG.

Goal: Separation of Interfaces to (a) libjpeg (this)  and  (b) Secondo (JPEG).

Possible later extension, that is changing of interface:

JPEGSourceMgr-instances surviving the lifetimes of their owners (JPEGs):

This may yield a gain of performance and flexibility (not at least a possible
emancipation of some unnecessairy constraints of the Secondo-Control-Mechanism
-- concerning object-lifetime-bound information and hence performance-loss in
regaining such information).

(see also Implementation description in JPEGSourceMgr.cpp).

*/

class JPEGSourceMgr {

/****************************************************************************
[2] Public constructors, destructor and methods

****************************************************************************/
 public:
  JPEGSourceMgr(JPEG* jObj);
  ~JPEGSourceMgr();

/**
[2] Initialization

*/
  void       DisconnectClient(JPEG * jObj);  // nulls jpegObj if destructed
  bool       CheckConnection();        // error check: JPEG<->JPEGSourceMgr
  bool       init();                   // Finishing work of cstr
  
/**
[2] Access-methods

*/
  int        GetID();
  static int GetNumAlive();   // get # of currently existing JPEGSourceMgrs
  static int GetCounter();    // # of all SrcMgrs seen in JPEGAlgebra lifetime
  jpeg_error_mgr* GetErrorMgr();     // access to libjpeg Error-Manager
  jpeg_decompress_struct* Get_cinfo();
  bool CInfoValid();
  
/**
[2] Decompression support. Extended JPEG-Info.

*/
  void parseFlobAgain();             // for use after reconfiguring cinfo
  void SetParseComment(bool yes_no); // demo: special cinfo-configure command
  void SetParseOnlyComment();
  bool ParseComment();               // dummy-Implem. for demo
  bool hasAdobeMarker();             // saw_Adobe_marker?
  bool Decompress(); // into rasterImage; FLOB-head allready had been parsed
  void ClearRasterImg();     // Discard rasterImg, e.g. before a new Decompress

/**
[2] Compression - with different configurations

*/

/**
PrepareCompress() and copyRasterToImageBuffer()

The first compression steps for all purposes: Source and Destination.

*/
  // Destination:
  bool PrepareCompress(FLOB * flob);
  // ... including whole rasterImg as Source:
  bool PrepareCompressDefault(FLOB * flob);

  // copyRasterToImageBuffer() -- Source:
  // Select data and create jpeg_write_scanlines-compatible imgBuffer from
  // rasterImage. Only one imgBuffer can be created, but this can be repea-
  // ted if the old imgBuffer has been processed.
  bool copyRasterToImageBuffer(int x, int y, int xdist, int ydist);
  bool copyRasterToImageBuffer();

/**
Configure-Methods:
The HowTo of Compression for various purposes, e.g. cut or size-reducing
compression.

*/
  bool ConfigureCut(int x, int y, int xdist, int ydist);

  bool ConfigureDownSize(int quality);   // not yet implemented

  bool ConfigureConvertToColor(colorS cs); // not yet implemented
    
/**
Execution of Compression: Compress()

Compresses the ImageBuffer to Jpeg-picture (valid Jpeg with
header etc.).  Checks before if (a) ImageBuffer exists, (b) flob.Size()
is sufficient, (c) the compress-info 'store\_info' is compatible with size
of ImageBuffer.

*/

  // Compress(): 
  // Preconditions: (a), (b) this is Secondo-related and hence the task of the
  // JPEG-methods/operators to provide initialized FLOB, (c) JPEG-method have
  // used appropriate JPEGSourceMgr-methods to configure 'store\_info' appro-
  // priately. (perhaps also writing such an compr\_info themselfes and giving
  // it to JPEGSourceMgr (not recommended)).

  bool Compress();

/**
[2] Color-Services.

*/

  // Add_XYZ_Distribution():
  // Augmenting jpegObj's values for frequency of the intensity of a color-
  // component or of brightness-intensities.
  // Used by compute_XYZ_D() to compute the distributions of color-compo-
  // nent-intensities (in the pixels) resp. compute the brightness-distribu-
  // tion (frequencies of intensities) (in the pixels):

  void AddBrightnessDistribution (double perCent, int valueIndex);
  void AddRGBDistribution (double perCent,
                           int colorIndex,    // 0 = R, 1 = G, 2 = B
                           int colorNumber);  // 0 .. 255
  void AddCMYKDistribution (double perCent,
                            int colorIndex,   // 0 = C, 1 = M, 2 = Y, 3 = K
                            int colorNumber); // 0 .. 255
  // compute_XYZ_D():
  bool ComputeBrightnessD(); // Computes Bri..Distribution from rasterImage
  bool ComputeRGBD();        //          RGB..
  bool ComputeCMYKD();       //          CMYK..



/*****************************************************************************
Public attributes

*****************************************************************************/
 public:

/**
[2] Data Structures

*/

  // comments in Jpeg-files are not parsed by default in libjpeg. parsing them
  // may be cpu-time-consuming. so remember if done.
  bool comment_parsed;
  bool store_info_valid;

/*****************************************************************************
Protected attributes

******************************************************************************/
 protected:

  JPEG * jpegObj; // the client to which this class instance serves.

  jpeg_decompress_struct cinfo; // libjpeg-DSs
  my_error_mgr jerr;

  int id; // id: identifier unique during live-time of JPEGAlgebra
  static int srcCounter; // # c'str'd in JPEGAlgebra lifetime
  static int numSrcAlive; // count (constructed-destructed) JPEGSourceMgrs

  // store_info:
  // to be used with (not yet implemented configuration methods, imgBuffer and
  // ->Compress(FLOB*)

  struct jpeg_compress_struct store_info;
  struct jpeg_error_mgr j_store_error;
  bool readyToCompress;
  bool compressCreated;


  // cinfo is correctly read in ?  have care: a ~valid~ cinfo doesn't imply
  // necessarily that its informations are ~consistent~ (after user configu-
  // ration actions).
  bool cinfoValid;


/*****************************************************************************
Private attributes

******************************************************************************/
 private:

/**
rasterImage:
decompressed image  resp. image to compress. The image is NOT automatically
scanned in init() for performance-reasons and since some configuration is
possibly required.

             [rows][columns\_in\_row][colour\_components\_in\_cell]

*/
  JSAMPIMAGE rasterImage;

  unsigned int rasterImgHeight; // cinfo.output_height - snapshot
  unsigned int rasterImgWidth;  // cinfo.output_width - snapshot
  unsigned int rasterImgComps;  // cinfo.output_components - snapshot
  bool decompressed;            // image data decompressed (, not only header)

/**
imgBuffer:
Buffer ready to compress. Compression allowed if 'store\_info' configured right,
and a FLOB of sufficient size has been provided by JPEG.
[->]see method Compress(FLOB[*])

*/
  JSAMPLE* imgBuffer;
  int imgBufHeight;
  int imgBufWidth;
};

#endif
/*
//paragraph [1] title: [{\Large \bf ]	[}]
//paragraph [2] subtitle: [{\bf ]	[}]
//[->] [$\rightarrow $]
//[=>] [$=> $]
//[TOC] [\tableofcontents]
//[newpage] [\newpage]


[1] (JPEG) Source Manager for JPEGAlgebra, Implementation-File

February 09, 2004  Neumann (corrections in object destruction)

February 06    2004  Neumann (formatting,  removed unused methods)

January  14    2004  Schoenhammer (color-/brightness-distribution, testing),
                     Neumann (integration in JPEGSourceMgr, general revision)

January 08/09  2004    Neumann

*/
/*******************************************************************************
\rule {100 pt}{1 pt} \linebreak

*******************************************************************************/
/*******************************************************************************
1 JPEGSourceMgr: Additional Defines and includes for Implementation

*******************************************************************************/

using namespace std;

#include "JPEGSourceMgr.h"
#include "JPEGAlgebra.h"

extern "C" {

// for jpeg_flob_src()/jpeg_flob_dest() (libjpeg-eXtension):
#include "jdatasrcX.c"
#include "jdatadstX.c"

#ifdef JPEG_INTERNALS
#include "./DebugOnLinuxGNU/jdapimin.c"
#include "./DebugOnLinuxGNU/jdinput.c"
#include "./DebugOnLinuxGNU/jdmarker.c"
#endif
}

/**
2 Class JPEGSourceMgr - The libjpeg side of the interface. Implementation.

Class JPEGSourceMgr is essentially a libjpeg-wrapper (C-Code !) for JPEG, but
has possible later extensions.

Goal: Separation of Interfaces to (a) libjpeg (this)  and  (b) Secondo (JPEG).

(see also description in JPEGSourceMgr.h)

Implementation issues:

JPEGSourceMgr is friend of JPEG.

With an independent interface to libjpeg having information-storage- and hence
information-exchange- capabilities the coordination of the implementation of
separated Secondo-operators promises to be easier:

Otherwise operator 'a' doesn't 'know' what operator 'b' is doing, nor can they
exchange commom information in a coordinated way. Coordination is then much more
left as constraint of different operator-implementors. Common use of (parts of)
algorithm (special ones coping with libjpeg) is also eased.

*/

int JPEGSourceMgr::srcCounter = 0;
int JPEGSourceMgr::numSrcAlive = 0;

/**
2.1 Constructors, Destructor, Connection to JPEG

*/

/**
[2] Constructor JPEGSourceMgr(JPEG[*] )

*/

JPEGSourceMgr::JPEGSourceMgr(JPEG* jObj){
  id               = ++srcCounter;
  ++numSrcAlive;
  jpegObj          = jObj;
  cinfoValid       = false; // header not yet scanned and parsed
  rasterImage      = 0;     // nothing read yet -> don't know size now
  rasterImgHeight  = 0;
  rasterImgWidth   = 0;
  rasterImgComps   = 0;
  decompressed     = false; // data not yet decompressed into rasterImage
  comment_parsed   = false; // assume libjpeg-default not to parse Jpeg-Comments
  imgBuffer        = 0;     // Compression-Source not yet prepared
  imgBufHeight     = 0;
  imgBufWidth      = 0;
  store_info_valid = false; // basic compression params not yet set
  readyToCompress  = false; // compression not yet congigured
  compressCreated  = false; // libjeg compression struct not yet allocated
  
  #ifdef DEBUGJPEG
  cout << "\nConstructor JPEGSourceMgr(). ID: " << id
       << "   alive: " << numSrcAlive << endl;
  #endif
}

/**
[2] Destructor

*/
JPEGSourceMgr::~JPEGSourceMgr(){
  jpeg_destroy_decompress (&cinfo);
  --numSrcAlive;

  // out-comment if Decompress() lets libjpeg reserve memory for rasterImage:
  if (rasterImage != 0)
    ClearRasterImg();

  #ifdef DEBUGJPEG
  cout << "\nDestructor ~JPEGSourceMgr(). ID:" << id
       << " alive: " << numSrcAlive << endl;
  #endif
}

/**
DisconnectClient()

*/
void JPEGSourceMgr::DisconnectClient(JPEG * jObj){
  assert(jObj == jpegObj);
  assert(jpegObj->destructing);
  jpegObj = 0;
}


// CheckConnection:
// This will be a restrictive error check: also the numbers of active src's and
// JPEGs must match, not only the correct association between JPEG and src.
//
// This method does seem to be NOT superfluous because of
//
//   * the complicated construction mechanisms of algebra-object-construction
//     in Secondo,
//   * the possible future extension towards src's surviving their (initial)
//     JPEG-owners -- possibly yielding some performance and flexibility
//     advantage: cf the persistance- and reusage- logic in
//     libjpeg : advantage:jpeg\_stdio\_src().

bool JPEGSourceMgr::CheckConnection(){

  if (!jpegObj) // nulled only by jpegObj->destructor via DisconnectFromSrc()
    return false;
  if (jpegObj->src != this)
    return false;
  // JPEGSourceManager needs a ~valid~ FLOB in jpegObj ... failure here
  // treated as 'bad connection':
  FLOB_Type jFlobType = jpegObj->picture.GetType();
  // missing for class FLOB: FLOB-Type 'Uninitialized' !!!
  if ( (jFlobType != InMemory) &&
       (jFlobType != InDiskSmall) &&  // currently not implemented?
       (jFlobType != InDiskLarge)
#ifdef PERSISTENT_FLOB
       && (jFlobType != InDiskMemory))
#else
      )
#endif
    return false;
  // 1:1 Relation of JPEGs and JPEGSourceMgr's?
  if (numSrcAlive != JPEG::numJpegsAlive)
    return false;

  return true; // nothing buggy in JPEG<->JPEGSourceMgr - connection
}

//METHODDEF (void)  // libjpeg portability-generic-typedef
static void
my_error_exit (j_common_ptr cinfo) // user-error-fn() stored in error-manager
{
  my_error_ptr myerr = ( my_error_ptr ) cinfo->err;
  (*(cinfo->err->output_message)) (cinfo);
  longjmp(myerr->setjmp_buffer, 1);
}


/**
2.2 Inititialization of JPEGSourceMgr ~and~ JPEG

*/


/**
[2] init() (version 1  or )  version 2:

Finishing the work of the cstr. Parsing the jpegObj[->]picture ~now~, since ~now~
the FLOB has been set up by jpegObj. [->]below (after version 2): overloaded
init(JPEGSourceMgr\&) omitting a superfluous parse-procedure.

There are actually two versions of init(), since it is not yet clear which one
is to be preferred. cf. following comments. (Jan 13th 2004: version 1 using
String-Streams removed for clearness (having overview in reading the code))

*/

// ( removed version 1:
// For Short: a String-Stream: FILE * fmemopen(bytes,...) may remain open for
// read and write, using as buffer 'bytes', which allready contains 'picture'.
// Limited portability disadvantage. )


// JPEGSourceMgr::init() - version 2:
// own libjpeg-'data-source-manager' connecting libjpeg to (flob) picture:
// solution   libjpeg:datasrc.c   with   own  jpeg_flob_src().

bool JPEGSourceMgr::init(){

  // Setup Error-Manager
  cinfo.err = jpeg_std_error(&jerr.pub);
  jerr.pub.error_exit = my_error_exit;
  if (setjmp(jerr.setjmp_buffer))     // LOW-LEVEL (asm) return point if ERROR
  {
    // jpeg_destroy_decompress(&cinfo); // destroyed in dstr
    return false;
  }

/**
Overview libjpeg Img-Parsing:
DeCompress [->] ReadFlob (or Buffer) [->] ReadHeader ([->] ERRORjmp or CleanUp):

*/
  jpeg_create_decompress(&cinfo);
  jpeg_flob_src(&cinfo, jpegObj->GetFLOB(0));
  jpeg_read_header (&cinfo, TRUE);

  // Code does not arrive here if jpeg-Error-Manager detects error.
  // So let's store the state, that cinfo can be used consistenty from now:
  cinfoValid = true;

/**
Initialize Jpeg-Member-Attributes (besides 'picture'):

*/

// We extract HERE the most important things, doing other extractions (if
// needed) in (JPEGSourceMgr-) methods which we could call only when needed, ..
// including possible usage of Get_cinfo()  for seldomly used requests ...
// Usage of Get_cinfo() is only encouraged for fetching information, ~not~ for
// setting cinfo-values.

  jpegObj->width = cinfo.image_width;
  jpegObj->height = cinfo.image_height;
  jpegObj->numComponents = cinfo.num_components;

  if (comment_parsed)  // in actual implementation *not* parsed
    jpegObj->comment = "JPEGSourceMgr::initialization_dummy_comment";

  switch (cinfo.jpeg_color_space) {
    case 1:
      jpegObj->coloured =  false;
      jpegObj->colorSpace = grayscale;
      break;
    case 3:
      jpegObj->coloured =  true;
      jpegObj->colorSpace = rgb;
      break;
    case 5:
      jpegObj->coloured =  true;
      jpegObj->colorSpace = cmyk;
      break;
    default:
      jpegObj->coloured = (cinfo.num_components > 1);
      jpegObj->colorSpace = colS_undefined;
      cerr << "Colorspace not supported" << endl;
      //jpegObj->SetDefined(false); // NOW picture read AND also Header, since

      //return false; // JPEG::defined is still false; don't need to set
                    // JPEG and InJPEG() will yield 'failure' to QP
  }

  jpegObj->SetDefined(true); // since FLOB AND jpeg-header read now.

  // CleanUP  is somewhat different from typical libjpeg usage:
  // It has been altered for use of cinfo the lifetime of *this and then to
  // be cleaned up in the destructor.  An implementation with temporary cinfo
  // w'd have destroyed cinfo -- as demonstrated in the libjpeg-documentation.

  // jpeg_destroy_decompress (&cinfo); // w'd have been called in libjpeg-demo

  return true; // success will let InJPEG return success + JPEG-Address to QP
}

/**
2.3 Get../ Is.. and Set.. Methods

*/

// GetCounter():
// Get number of all JPEGSourceMgrs c'str'd since JPEGAlgebra-Construction

int JPEGSourceMgr::GetCounter(){
  return srcCounter;
}

int JPEGSourceMgr::GetNumAlive(){ // Get number of currently existing SrcMgrs
  return numSrcAlive;
}

int JPEGSourceMgr::GetID(){       // unique
  return id;
}

/**
Get\_cinfo():

The use of this method has architectural consequences!

It is not very save... delivering the protected cinfo to the public ...
allowing C-Style bugs as before ...

Since a pointer is returned, one could also directly configure cinfo ... for
example to [->]parseFlobAgain() with a configuration largely changed.

BUT: not recommended, it would be better to supply a corresponding method here,
so other operator can use it and must not do the work again.

*/
jpeg_decompress_struct* JPEGSourceMgr::Get_cinfo(){

  return (jpeg_decompress_struct*) &cinfo;
}

bool JPEGSourceMgr::CInfoValid(){
  return cinfoValid == true;
}


// GetErrorMgr():
// another C-Like offer to the JPEGSrcMgr-User (JPEG-operator). It would be
// preferrable instead to write a method like GetErrorId() or GetErrorMsgFor-
// User()... and the like.

jpeg_error_mgr* JPEGSourceMgr::GetErrorMgr(){
  return (jpeg_error_mgr*) &(jerr.pub);
}


/*****************************************************************************
2.4 Color-Services for JPEG

*****************************************************************************/

void JPEGSourceMgr::AddBrightnessDistribution (double perCent, int valueIndex)
{
  assert (valueIndex >= 0 && valueIndex <=255);
  jpegObj->brightnessDistribution  [valueIndex] =
    jpegObj->brightnessDistribution[valueIndex] + perCent;
}

void JPEGSourceMgr::AddRGBDistribution (double perCent, int colorIndex,
                                                        int valueIndex)
{
  assert (colorIndex >= 0 && colorIndex <=2);
  assert (valueIndex >= 0 && valueIndex <=255);

  jpegObj->rgbDistribution   [valueIndex][colorIndex] =
    jpegObj->rgbDistribution [valueIndex][colorIndex] + perCent;

}

void JPEGSourceMgr::AddCMYKDistribution (double perCent, int colorIndex,
                                                         int valueIndex)
{
  assert (colorIndex >= 0 && colorIndex <=3);
  assert (valueIndex >= 0 && valueIndex <=255);

  jpegObj->cmykDistribution   [valueIndex][colorIndex] =
    jpegObj->cmykDistribution [valueIndex][colorIndex] + perCent;
}


bool JPEGSourceMgr::ComputeBrightnessD(){

// to be used with  NEW-VERSION  of Decompress()


  assert(cinfoValid); // if not then probable values for height, width,
                      // color_space not correct.

  // Decompression might not be done yet ...:
  // Imagine in Munich there is a huge Secondo-database containing all bavari-
  // an official Jpegs, about 2.000.000 (including one very nice and commented
  // of Mr. Stoiber visiting Regensburg)   Now we want to find all those who
  // contain the word 'Regensburg'. There is no index. Since Mr. Huber is joi-
  // ning us at 21:00h in the evening (inspecting efficiency of bavarian public
  // servants): Should our other operator examining the Jpeg-comments decom-
  // press the images before?  ;-)
  if (!decompressed)
    Decompress();

  assert(decompressed); // no problem occured .. for examply with memory?

  // Currently only Brightness-Distribution for Grayscale. Possible for color
  // to: average of intensity of color-components. check grayscale:
  assert( rasterImgComps == 1);// <=> JPEG::numComponents == 1 or inconsistent

  // As a comment code copied from method Decompress():
  //
  // rasterImgHeight = cinfo.output_height;     // |[rows]
  // rasterImgWidth  = cinfo.output_width;      // |[ ]..[cells]
  // rasterImgComps  = cinfo.output_components; // |[ ]..[ ]....[colcmps]
  //
  // These are consistent with JPEG::height,width,numComponents if only
  // JPEGSourceMgr has accessed JPEG for setting attributes. Variation of
  // cinfo doesn't matter since rasterImgHeight, ... are its values during
  // decompression time stored to savely access rasterImage in methods like
  // this one.

  double pc; // the perCent-Value of one pixel;
  pc = ( (double)100.0 / (double)
                         ( rasterImgWidth * (double) rasterImgHeight ) );

  unsigned int w, h; // w_idth(#columns), h_eight(#rows)

  for (h = 0; h < rasterImgHeight; h++)
    for (w = 0; w <= rasterImgWidth - 1; w++)
    {
      // cout << w <<":" << (int) buffer[h][w] << "  ";
      AddBrightnessDistribution (pc, ((int) rasterImage [h][w][0])); //###

      // with LIBJPEG-version of Decompress() this would be:
      // AddBrightnessDistribution (pc, ((int) rasterImage [h][0][w])); //###
    }


  // ### as a comment see code copied from Decompress():
  //
  //  for (unsigned int w = 0; w < rasterImgWidth; w++)
  //  {
  //    rasterImage[row_no][w] = new JSAMPLE[rasterImgComps];
  //    for (unsigned int c = 0; c < rasterImgComps; c++)
  //      rasterImage[row_no][w][c] = (int)buffer [0][w*rasterImgComps+c];
  //  }

  return true;
}


bool JPEGSourceMgr::ComputeRGBD(){

// to be used with  NEW-VERSION  of Decompress()

  assert(cinfoValid);

  // Decompression might not be done yet ...
  if (!decompressed)
    Decompress();

  assert(decompressed);
  assert( rasterImgComps == 3);// <=> JPEG::numComponents == 3 or inconsistent

  // As a comment code copied from method Decompress():
  //
  // rasterImgHeight = cinfo.output_height;     // |[rows]
  // rasterImgWidth  = cinfo.output_width;      // |[ ]..[cells]
  // rasterImgComps  = cinfo.output_components; // |[ ]..[ ]....[colcmps]
  //
  // see alse comments in ComputeBrightnessD()

  double pc; // the perCent-Value of one pixel;
  pc = ( (double)100.0 / (double)
                         ( rasterImgWidth * (double) rasterImgHeight ) );

  unsigned int w, h; // w_idth(#columns), h_eight(#rows)

  for (h = 0; h < rasterImgHeight; h++)
    for (w = 0; w <= rasterImgWidth - 1; w++)
    {
       // cout << w <<":" << (int) rasterImage[h][w] << "  ";
       AddRGBDistribution (pc, 0, ( (int) rasterImage [h] [w][0])); // red
       AddRGBDistribution (pc, 1, ( (int) rasterImage [h] [w][1])); // green
       AddRGBDistribution (pc, 2, ( (int) rasterImage [h] [w][2])); // blue

      // with LIBJPEG-version this would be:
      //  AddCMYKDistribution (pc, 0, ( (int) rasterImage [h] [0][w+0])); // r
      //  AddCMYKDistribution (pc, 1, ( (int) rasterImage [h] [0][w+1])); // g
      //  AddCMYKDistribution (pc, 2, ( (int) rasterImage [h] [0][w+2])); // b
    }
  return true;
}


bool JPEGSourceMgr::ComputeCMYKD(){

// to be used with  NEW-VERSION  of Decompress()

  assert(cinfoValid);

  // Decompression might not be done yet ...
  if (!decompressed)
    Decompress();

  assert(decompressed);
  assert( rasterImgComps == 4);// <=> JPEG::numComponents == 4 or inconsistent

  // As a comment code copied from method Decompress():
  //
  // rasterImgHeight = cinfo.output_height;     // |[rows]
  // rasterImgWidth  = cinfo.output_width;      // |[ ]..[cells]
  // rasterImgComps  = cinfo.output_components; // |[ ]..[ ]....[colcmps]
  //
  // see also comments in ComputeBrightnessD()

  double pc; // the perCent-Value of one pixel;
  pc = ( (double)100.0 / (double)
                         ( rasterImgWidth * (double) rasterImgHeight ) );

  unsigned int w, h; // w_idth(#columns), h_eight(#rows)

  for (h = 0; h < rasterImgHeight; h++)
    for (w = 0; w <= rasterImgWidth - 1; w++)//w+=4)
    {
      // cout << w <<":" << (int) rasterImage[h][w][0] << "  ";
      // cout << "Farbindex 0 -> Zeile:" << h << " Spalte:" << w << endl;
      // cout << "Farbindex 1 -> Zeile:" << h << " Spalte:" << w << endl;
      // cout << "Farbindex 2 -> Zeile:" << h << " Spalte:" << w << endl;
      // cout << "Farbindex 3 -> Zeile:" << h << " Spalte:" << w << endl;

      AddCMYKDistribution (pc, 0, ( (int) rasterImage [h][ w] [0])); // C
      AddCMYKDistribution (pc, 1, ( (int) rasterImage [h] [w] [1])); // M
      AddCMYKDistribution (pc, 2, ( (int) rasterImage [h] [w] [2])); // Y
      AddCMYKDistribution (pc, 3, ( (int) rasterImage [h] [w] [3])); // K

      // with LIBJPEG-version this would be:
      //      AddCMYKDistribution (pc, 0, ( (int) rasterImage [h] [0][w+0]));
      //      AddCMYKDistribution (pc, 1, ( (int) rasterImage [h] [0][w+1]));
      //      AddCMYKDistribution (pc, 2, ( (int) rasterImage [h] [0][w+2]));
      //      AddCMYKDistribution (pc, 3, ( (int) rasterImage [h] [0][w+3]));
    }
  return true;
}


/**
2.5 Decompression and preparations

*/

/****************************************************************************
2.5.1 Services for Configuring (libjpeg-) cinfo, flexible reparsing etc.

****************************************************************************/

/**
After reconfiguring parse-options, the FLOB of the associated JPEG can be
parsed again, for example to parse something that was skipped with the libjpeg-
parse-configuration used before. Use with care: not yet tested!

*/
void JPEGSourceMgr::parseFlobAgain(){
  assert(jpegObj != 0);
  assert(jpegObj->IsDefined());

  // cinfo valid till now first must be discarded:
  jpeg_destroy_decompress (&cinfo);

  init();

}



/*****************************************************************************
[2] Different Services simplifying libjpeg-usage

*****************************************************************************/

// SetParseComment():
// Configures cinfo to also parse the comment included in the jpeg-picture
// which is not parsed by default.

void JPEGSourceMgr::SetParseComment(bool yes_no){

  // to do:  not yet implemented;
  // set variable in cinfo?  set another user-defined libjpeg-fn() in cinfo?

  // to_do_set_the_apropriate_options()

  // may be of more general use as only to output this comment to the user.
}

// SetParseOnlyComment():
// Configures cinfo to also parse the jpeg-picture skipping all markers except
// the comment.  The following ->parseFlobAgain() might be much faster with this

void JPEGSourceMgr::SetParseOnlyComment(){

  // not yet implemented

}

// ParseComment():
// demo with dummy-implem.

bool JPEGSourceMgr::ParseComment(){

   // SetParseComment(true); // assume we not just only need the comment
   // ParseFlobAgain();  // have care : not tested

   // fetch the comment from where configured to be stored (by SetParseComment)
   // dummy-impl.:
   string dummy_comment = "this is a dummy-comment by ParseComment()";
                        // the fetched comment

   comment_parsed = true;
   jpegObj->comment = dummy_comment;

   // SetParseComment(false);  // now we have, and can skip it next time ...
   return (dummy_comment != "");
}

//  to do if needed: ... similar methods.

/** Jpegs with Adobe-markers are the only ones whose colorspace is converted to
    CMYK in the libjpeg-default-configuration represented by */

bool JPEGSourceMgr::hasAdobeMarker(){
  return cinfo.saw_Adobe_marker;
}


/*****************************************************************************
2.5.2 Decompress()

Read image into JPEGSourceMgr::rasterImage[][][] after jpeg\_read\_header().

See also [->]init(), [->]parseAgain() and  (optionally) calls to
'decompress-configure-functions()'.

We read into an 3-dim Array instead an 1-dim buffer as needed by compression:
operations on this datastructure are easier to understand, less cryptical and
therefore less error-prone.

3-dim Array remains available till JPEGSourceMgr-Destructor or explicit request
to be discarded.

Decompression is done by demand, but only needed once. Not all operators need
this time consuming computation!

*/
bool JPEGSourceMgr::Decompress(){

// 'NEW-VERSION'   ( ,  NOT  'LIBJPEG-MEM-VERSION' )

  // cf. example.c from libjpeg (author: Lane)

  // don't overwrite a previous scan: must be cleared first
  if (rasterImage != 0)
    return false;

  (void) jpeg_start_decompress (&cinfo);


  // prevent accidential change inco cinfo:
  rasterImgHeight = cinfo.output_height;     // |[rows]
  rasterImgWidth  = cinfo.output_width;      // |[ ]..[cells]
  rasterImgComps  = cinfo.output_components; // |[ ]..[ ]....[colcmps]

  // height == #rows, each pixel in a row has num_components col_comps =>
  // rasterImage is an array of these rows with array-size height
  rasterImage = new JSAMPARRAY [rasterImgHeight];

  int row_stride = rasterImgWidth * rasterImgComps;

  JSAMPARRAY buffer = (*cinfo.mem->alloc_sarray)
    ((j_common_ptr) &cinfo, JPOOL_IMAGE, row_stride, 1);

  // read single scanlines till no more found
  assert (cinfo.output_scanline == 0); // be sure!
  int row_no = cinfo.output_scanline;

  while ((cinfo.output_scanline < cinfo.output_height) // output_height const?
      && (cinfo.output_scanline < rasterImgHeight )) { // to be sure

    jpeg_read_scanlines(&cinfo, buffer, 1);

    // 'row = new colourC [#pixels_in_row][ _ignored_#of_colourC_in_pixel]'
    rasterImage[row_no] = new JSAMPROW[rasterImgWidth];


    // the following is nicely ordered, but lots slower then with memcpy ...
    // with memcpy: caveat BITS_IN_SAMPLE etc. ... + cryptical usage of DS
    for (unsigned int w = 0; w < rasterImgWidth; w++)
    {
      rasterImage[row_no][w] = new JSAMPLE[rasterImgComps];
      for (unsigned int c = 0; c < rasterImgComps; c++)
        rasterImage[row_no][w][c] = (int)buffer [0][w*rasterImgComps+c];
    }
    ++row_no;

  }///~while

  (void) jpeg_finish_decompress(&cinfo);

  decompressed = true;

  // Lanes 'Step 8: Release JPEG decompression object' is done by d'str
  // or by explicit request

  return true;
}

// ClearRasterImg():
// Discard rasterImg memory, e.g. before a newly configured decompression

void JPEGSourceMgr::ClearRasterImg(){
  assert(rasterImage);
  assert(rasterImgHeight);
  assert(rasterImgWidth);
  assert(rasterImgComps);
  for (unsigned int r = 0; r < rasterImgHeight; r++)
  {
    for (unsigned int w = 0; w < rasterImgWidth; w++)
      delete rasterImage[r][w];
    delete rasterImage[r];
  }
}



/*****************************************************************************
2.6 Compression and preparations

*****************************************************************************/

/**
2.6.1 PrepareCompress() and related methods

Besides copyRasterToImageBuffer the first step in Compression.

*/
bool JPEGSourceMgr::PrepareCompress(FLOB * flob)
{
  assert(flob != 0);
  store_info_valid = true;
  assert(store_info_valid);

  if (!decompressed) // rasterImage allready constructed?
    Decompress();

  store_info.err = jpeg_std_error(&j_store_error);
  jpeg_create_compress(&store_info);
  compressCreated = true; // later checked if memory has to be released
  
  jpeg_flob_dest(&store_info, flob); // connect to destination
  return true;
}

/**
PrepareCompressDefault()

PrepareCompress including copying whole rasterImage as Source.

*/
bool JPEGSourceMgr::PrepareCompressDefault(FLOB * flob)
{
  assert(flob != 0);
  store_info_valid = true;
  assert(store_info_valid);

  if (!decompressed) // rasterImage allready constructed?
    Decompress();

  if (rasterImage == 0)
    return false;

  if (imgBuffer != 0)  // first process previous Compression: memory!
    return false;

  copyRasterToImageBuffer(); // the source: whole rasterImage or part of it

  // check if imgBuffer exists
  if (!imgBuffer)
  {
    cerr << "\nerror in Compress: attempt to Compress from imgBuffer not"
             " yet available!.\n";
    return false;
  }

  store_info.err = jpeg_std_error(&j_store_error);
  jpeg_create_compress(&store_info);
  compressCreated = true; // later checked if memory has to be released

  jpeg_flob_dest(&store_info, flob); // connect to destination

  store_info.image_width = rasterImgWidth;
  store_info.image_height = rasterImgHeight;
  store_info.input_components = cinfo.num_components; // may be overwritten
  store_info.in_color_space = cinfo.out_color_space; // before jpeg_defaults()
  store_info.jpeg_color_space = cinfo.jpeg_color_space;

  return true;
}


// copyRasterToImageBuffer():
// Copy rasterImage to format expected from jpeg\_write\_scanlines()

bool JPEGSourceMgr::copyRasterToImageBuffer(int x, int y, int xdist, int ydist)
{
  // boundary checks allready done by caller
  // further checks:
  
  // cf. preconditions to compress: 1. part of libjpeg : example.c

  if (rasterImage == 0)
    return 0;

  if (imgBuffer != 0)  // first process previous Compression: memory!
    return 0;

  unsigned int rowSize = (unsigned int) xdist * rasterImgComps;
  unsigned long imgSize = (unsigned long) rowSize *
                          (unsigned long) ydist;

  imgBuffer = new JSAMPLE[imgSize];
  imgBufHeight = ydist;
  imgBufWidth = xdist * rasterImgComps;

  // to do: errorcheck!   or   use libjpeg.memorymanager with its error-checks

  // if (failure in new())
  //   return false;

  unsigned int hMax = (unsigned int) (y + ydist);
  unsigned int wMax = (unsigned int) (x + xdist);
  unsigned int hStart = (unsigned int) y ;
  unsigned int wStart = (unsigned int) x ;

  
  for (unsigned int r = hStart; r < hMax; r++)
    for (unsigned int w = wStart; w < wMax; w++)
      for (unsigned int c = 0; c < rasterImgComps; c++)
        imgBuffer[(r-hStart)*rowSize + (w-wStart) * rasterImgComps + c] = rasterImage[r][w][c];

  return true;
}

bool JPEGSourceMgr::copyRasterToImageBuffer()
{
  int x = 0, y = 0, xdist = rasterImgWidth, ydist = rasterImgHeight;
  return copyRasterToImageBuffer(x, y, xdist, ydist);
}

/**
2.6.2 Configuring 'store\_info':

Various configuration methods, configuring 'store\_info' as needed and for
usage with imgBuffer in [->]Compress. ~Before~, Compression must be prepared.

cf. middle of first part in libjpeg: example.c

*/

/**
ConfigureCut():

The configuring Method for JPEGs ~cut~-operator.

*/

bool JPEGSourceMgr::ConfigureCut(int x, int y, int xdist, int ydist)
{
  copyRasterToImageBuffer(x, y, xdist, ydist); // the source: whole rasterImage or part of it

  // check if imgBuffer exists
  if (!imgBuffer)
  {
    cerr << "\nerror in Compress: attempt to Compress from imgBuffer not"
             " yet available!.\n";
    return false;
  }

  store_info.image_width = xdist;
  store_info.image_height = ydist;
  store_info.input_components = cinfo.num_components;
  store_info.in_color_space = cinfo.out_color_space;
  store_info.jpeg_color_space = cinfo.jpeg_color_space;

  jpeg_set_defaults(&store_info);
  readyToCompress = true;

  store_info_valid = true; // optionally: extended check eventually setting
                           // it to false before executing Compress()
  
  return readyToCompress;
}


bool JPEGSourceMgr::ConfigureDownSize(int quality)   
{
  if (!compressCreated)
    return false;
  jpeg_set_defaults(&store_info);
  jpeg_set_quality(&store_info, quality, TRUE ); // baseline
  readyToCompress = true;

  store_info_valid = true; // optionally: extended check eventually setting

  return true;
}

bool JPEGSourceMgr::ConfigureConvertToColor(colorS cs) // not yet implemented
{
  return false;
}
  
/**
2.6.3 Compress()

Last and executing compression step. Must be prepared and configured before!

*/
bool JPEGSourceMgr::Compress()
{
  // prevent error-prone executions
  if (!readyToCompress || !store_info_valid || !compressCreated)
  {
    cerr << "\nCompress(): Attempt to Compress mal-configured data refused.\n";

    if (compressCreated)
      jpeg_destroy_compress(&store_info); // release storage again

    // reset:
    compressCreated = false;
    readyToCompress = false;
    store_info_valid = false;
    return false;
  }

  JSAMPROW row_pointer[1]; // improvement: several rows at a time ...
  int row_stride;

  jpeg_start_compress(&store_info, TRUE);
  row_stride = store_info.image_width * store_info.num_components;

  while (store_info.next_scanline < store_info.image_height) {
    row_pointer[0] = & imgBuffer[store_info.next_scanline * row_stride];
    // store_info works with FLOB => this writes directly into JPEG::picture :
    (void) jpeg_write_scanlines(&store_info, row_pointer, 1);
  }

  jpeg_finish_compress(&store_info);

  jpeg_destroy_compress(&store_info);

  // reset:
  store_info_valid = false;
  compressCreated  = false;
  readyToCompress = false;
  
  return true;
}
/*******************************************************************************
//[newpage] [\newpage]

\rule {100 pt}{1 pt} \linebreak

[newpage]

1 Extension of Libjpeg for Use with FLOBs

[newpage]

*/
/******************************************************************************
//[->] [$\rightarrow $]

1 Libjpeg-Extension for use with FLOBs - Part 1: Decompression

  jdatasrc.c  eXtended to jdatasrcX.c  (to be placed in directory JPEG)

  Copyright (C) 1994-1996, Thomas G. Lane.
  This file is part of the Independent JPEG Group's software.
  For conditions of distribution and use, see the accompanying README file.

  This file contains decompression data source routines for the case of
  reading JPEG data from a file (or any stdio stream).  While these routines
  are sufficient for most applications, some will want to use a different
  source manager.
  IMPORTANT: we assume that fread() will correctly transcribe an array of
  JOCTETs from 8-bit-wide elements on external storage.  If char is wider
  than 8 bits on your machine, you may need to do some tweaking.

*/

/*
(C-left) January 2004, Ulrich Neumann (eXt)

eXtended for supporting buffers (not well testet nor well implemented)
and for Secondo-FLOBs (expected to work without bugs) as datasources
instead of the (OS-) file-stream originally expected by jpeg\_stdio\_src

original fn()s: jpeg\_stdio\_src() and related (for comparison)
buffer-version: jpeg\_buffer\_src() using same fn()s for stdio\_src
flob-version:   jpeg\_flob\_src() using adapted fn()s

*/

// this is not a core library module,  so it doesn't define JPEG_INTERNALS

// unneccessary to include jinclude.h only for the following 3 defines:
#define JFREAD(file,buf,sizeofbuf)  \
  ((size_t) fread((void *) (buf), (size_t) 1, (size_t) (sizeofbuf), (file)))
#define JFWRITE(file,buf,sizeofbuf)   ((size_t)  \
  fwrite((const void *) (buf), (size_t) 1, (size_t) (sizeofbuf), (file)))

#define SIZEOF(object)	((size_t) sizeof(object))


//          jinclude: see 3 defines above.
//#include "jinclude.h"
// (standard include directory, $HOME/secondo-sdk/include:)
#include "jpeglib.h"
#include "jerror.h"


// eXt:
// INPUT_BUF_SIZE  is a configuration issue: possible big performance
// improvements  with values  adapted to FLOB::Get()  (which ones ???)
// => to do: experimenting  INPUT_BUF_SIZE <-> Image-Parse-Performance

#define INPUT_BUF_SIZE  1024

// INPUT_BUF_SIZE :
// possibly take pageSize of FLOB, which is most efficient, ...
// ... if the image is bigger then FLOB::THRESHOLD == actually 1024

// 4096  is the original value for fill_input_buffer() from TH. G. Lane

// choose an efficiently fread'able size  (Lane)
//                       FLOB.Get_able size


// Expanded data source object for stdio input (Lane)

typedef struct {
  //struct
  jpeg_source_mgr pub; // public fields

  FILE * infile;		// source stream
  JOCTET * buffer;		// start of buffer
  boolean start_of_file;	// have we gotten any data yet?
} my_source_mgr;

typedef my_source_mgr * my_src_ptr;


// (eXt) eXtension for FLOB:

typedef struct {
  //struct
  jpeg_source_mgr pub;	// public fields

  FLOB * fromFLOB;		// source 'stream'
  JOCTET * buffer;		// start of buffer
  boolean start_of_file;	// have we gotten any data yet?
                          // eXt: attr. not really needed. for compatibility.
                          // instead:
  size_t offset;  // eXt: keep track of buffer-location for FLOB::Get()-call

} my_source_flob_mgr;

typedef my_source_flob_mgr * my_src_flob_ptr;


// Initialize source --- called by jpeg_read_header
// before any data is actually read.   (Lane)

static void
init_source (j_decompress_ptr cinfo)
{
  my_src_ptr src = (my_src_ptr) cinfo->src;

  // We reset the empty-input-file flag for each image,
  // but we don't clear the input buffer.
  // This is correct behavior for reading a series of images from one source.
  //
  src->start_of_file = TRUE;
}



// eXt:
// Initialize source --- called by jpeg_read_header
// before any data is actually read.   (Lane)

static void
init_source_flob (j_decompress_ptr cinfo)
{
  // (eXt) (as in init_source) the following cast works because
  // my_source_(flob_)mgr starts with a jpeg_source_mgr-Attribute

  my_src_flob_ptr src = (my_src_flob_ptr) cinfo->src;

  // "We reset the empty-input-file flag for each image,
  // but we don't clear the input buffer. " -> eXt: bytes of last FLOB
  // read remain in the buffer allocated (outside the FLOB) by libjpeg.
  // "This is correct behavior for reading a series of images from one source."
  // -> eXt: FLOB can be read several times ...
  //
  src->start_of_file = TRUE;
  src->offset = 0; // first byte of FLOB  is the next to fetch with FLOB::Get(...)
}


/**
(Lane:)
Fill the input buffer --- called whenever buffer is emptied.

In typical applications, this should read fresh data into the buffer
(ignoring the current state of next\_input\_byte and bytes\_in\_buffer),
reset the pointer and count to the start of the buffer, and return TRUE
indicating that the buffer has been reloaded.  It is not necessary to
fill the buffer entirely, only to obtain at least one more byte.

There is no such thing as an EOF return.  If the end of the file has been
reached, the routine has a choice of ERREXIT() or inserting fake data into
the buffer.  In most cases, generating a warning message and inserting a
fake EOI marker is the best course of action --- this will allow the
decompressor to output however much of the image is there.  However,
the resulting error message is misleading if the real problem is an empty
input file, so we handle that case specially.

In applications that need to be able to suspend compression due to input
not being available yet, a FALSE return indicates that no more data can be
obtained right now, but more may be forthcoming later.  In this situation,
the decompressor will return to its caller (with an indication of the
number of scanlines it has read, if any).  The application should resume
decompression after it has loaded more data into the input buffer.  Note
that there are substantial restrictions on the use of suspension --- see
the documentation.

When suspending, the decompressor will back up to a convenient restart point
(typically the start of the current MCU). next\_input\_byte and bytes\_in\_buffer
indicate where the restart point will be if the current call returns FALSE.
Data beyond this point must be rescanned after resumption, so move it to
the front of the buffer rather than discarding it.

*/

static boolean
fill_input_buffer (j_decompress_ptr cinfo)
{
  my_src_ptr src = (my_src_ptr) cinfo->src;
  size_t nbytes;

  nbytes = JFREAD(src->infile, src->buffer, INPUT_BUF_SIZE);

  if (nbytes <= 0) {
    if (src->start_of_file)	// Treat empty input file as fatal error
      ERREXIT(cinfo, JERR_INPUT_EMPTY);
    WARNMS(cinfo, JWRN_JPEG_EOF);
    /* Insert a fake EOI marker */
    src->buffer[0] = (JOCTET) 0xFF;
    src->buffer[1] = (JOCTET) JPEG_EOI;
    nbytes = 2;
  }

  src->pub.next_input_byte = src->buffer;
  src->pub.bytes_in_buffer = nbytes;
  src->start_of_file = FALSE;

  return TRUE;
}


/**
1.1 Essential Method for Performance

(eXt)  -- this is the essential fn() for performance improovements.

*/
static boolean
fill_input_buffer_fromFLOB (j_decompress_ptr cinfo)
{
  my_src_flob_ptr src = (my_src_flob_ptr) cinfo->src;
  size_t nbytes;
  int input_buf_size = INPUT_BUF_SIZE; // just for seeing it in GNU-Debugger

  // to do: assure offset + INPUT_BUF_SIZE <= FLOB::Size()
  size_t numFlobBytes = src->fromFLOB->Size();
  assert(src->offset <= numFlobBytes);

  // read from FLOB
  if ((src->offset + input_buf_size) > numFlobBytes)
  {
    src->fromFLOB->Get(src->offset, numFlobBytes - src->offset, src->buffer);
        // not - (offset - 1), since buffer starts with 0
   nbytes = numFlobBytes - src->offset;
    // Caution: FLOB::Get() actually DOESN'T check the
                             // NUMBER of bytes really copied ...
  }
  else
  {  src->fromFLOB->Get(src->offset, input_buf_size ,src->buffer);
     nbytes = input_buf_size;
  }

  // update offset to read next time from FLOB
  src->offset += nbytes;

  // (eXt)     nbytes < 0 ??? =>
  // error in FLOB::Get()? ...actually never occurs: Get assumes ALL bytes
  // correctly memcpy'd, if none of its assertions fail. one of them asserts:
  // enough bytes left.     *** But nbytes may be 0. *** => wrong usage?
  if (nbytes <= 0) {
    if (src->start_of_file)	/* Treat empty input file as fatal error */
      ERREXIT(cinfo, JERR_INPUT_EMPTY);

    WARNMS(cinfo, JWRN_JPEG_EOF);

    // Insert a fake EOI marker  (Lane, working with stream!)

    // eXt: possibly not used, but not removed for compatibility
    // to do: own resync_to_start-fn(), which obsoltes following lines.
    // ... but on the other side we should never arrive here!

    src->buffer[0] = (JOCTET) 0xFF;       // this is set in buffer,
    src->buffer[1] = (JOCTET) JPEG_EOI;   // not in the FLOB! (eXt)
    nbytes = 2;                           // ... not used ... return false!

    // nothing to resume, since FLOB is NOT a stream which could
    // be waiting  but   IF nbytes <= 0  nothing more can be got: Get()-Bug
    cerr << "fill_input_buffer_fromFLOB(): nbytes = " << nbytes
         << " src->pub.unread_marker = " << cinfo->unread_marker
         << " ... returning false instead of letting resynch try." << endl;

    assert(FALSE);  // eXt: don't try to correct error which
  }
  // not any error occurred

  src->pub.next_input_byte = src->buffer; // buffer[0], since newly filled
  src->pub.bytes_in_buffer = nbytes; // we could also use count == FLOB::Size()
                                     // instead of INPUT_BUF_SIZE
  src->start_of_file = FALSE;

  return TRUE;
}


/**
(Lane:)
Skip data. Used to skip over a potentially large amount of
uninteresting data (such as an APPn marker).

Writers of suspendable-input applications must note that skip\_input\_data
is not granted the right to give a suspension return.  If the skip extends
beyond the data currently in the buffer, the buffer can be marked empty so
that the next read will cause a fill\_input\_buffer call that can suspend.
Arranging for additional bytes to be discarded before reloading the input
buffer is the application writer's problem.

*/

static void
skip_input_data (j_decompress_ptr cinfo, long num_bytes)
{
  my_src_ptr src = (my_src_ptr) cinfo->src;

  // Just a dumb implementation for now.  Could use fseek() except
  // it doesn't work on pipes.  Not clear that being smart is worth
  // any trouble anyway --- large skips are infrequent.
  //
  if (num_bytes > 0) {
    while (num_bytes > (long) src->pub.bytes_in_buffer) {
      num_bytes -= (long) src->pub.bytes_in_buffer;
      (void) fill_input_buffer(cinfo);
      // note we assume that fill_input_buffer will never return FALSE,
      // so suspension need not be handled.
      //
    }
    src->pub.next_input_byte += (size_t) num_bytes;
    src->pub.bytes_in_buffer -= (size_t) num_bytes;
  }
}


// (eXt) eXtension for FLOB: should be faster then Lane, since
//       seeking of position is possible.

static void
skip_input_flob_data (j_decompress_ptr cinfo, long num_bytes)
{
  my_src_flob_ptr src = (my_src_flob_ptr) cinfo->src;

  // eXt: cf. comment in skip_input_data() :
  // "Just a dumb implementation for now.  Could use fseek() except
  // it doesn't work on pipes.  Not clear that being smart is worth
  // any trouble anyway --- large skips are infrequent."
  //
  // eXt: no fseek since no stream. Meantheless no simple dump. Large
  // skips also treated efficiently.
  //

  assert(num_bytes > 0); // if caller wants to skip a non-positive number of
                         // bytes then it's HIS/HER code to be investigated!

  if (num_bytes < (long)src->pub.bytes_in_buffer) // only 'inside-buffer-jump'
  {
    src->pub.next_input_byte += (size_t) num_bytes;
    src->pub.bytes_in_buffer -= (size_t) num_bytes;
    // src->offset remains same, since skipped bytes allready loaded
  }
  else // 'beyond-buffer-jump' to a FLOB-position not yet loaded
  {
    // in FLOB source skip only FLOB-bytes not yet loaded to buffer
    // (may be += 0, if skipped exactly the remaining buffer-bytes)
    src->offset += num_bytes - src->pub.bytes_in_buffer;

    // fetch the next bytes not skipped
    assert( fill_input_buffer_fromFLOB(cinfo)); //caller shouldn't skip beyond!

    // now: buffer ([0...]) filled from the first byte after the skipped ones

    // src->pub.next_input_byte   and   src->pub.bytes_in_buffer  ...
    // ... allready set by fill_input_buffer_fromFLOB
  }
}


//   R e s y n c h r o n i z a t i o n   f r o m   M a r k e r E r r o r s  ???

/**
(Lane:)
An additional method that can be provided by data source modules is the
resync\_to\_restart method for error recovery in the presence of RST markers.
For the moment, this source module just uses the default resync method
provided by the JPEG library.  That method assumes that no backtracking
is possible.

*/

/**
eXt:
Backtracking IS possible with FLOBs. But how to understand a RST marker found??
Since FLOB, this would not be a time-caused stream-error, but instead corrupt
data in the picture itself...  Really try to repair?

*/

/*
(eXt:) following the comment of (Lane)  regarding the default resynch\_
       to\_restart()   copied from  jdmarker.c
       Below in jpeg\_flob\_src we set up a dummy-failure-exit() instead.

*/
/**
(Lane:)
This is the default resync\_to\_restart method for data source managers
to use if they don't have any better approach.  Some data source managers
may be able to back up, or may have additional knowledge about the data
which permits a more intelligent recovery strategy; such managers would
presumably supply their own resync method.

read\_restart\_marker calls resync\_to\_restart if it finds a marker other than
the restart marker it was expecting.  (This code is *not* used unless
a nonzero restart interval has been declared.)  cinfo[->]unread\_marker is
the marker code actually found (might be anything, except 0 or FF).
The desired restart marker number (0..7) is passed as a parameter.
This routine is supposed to apply whatever error recovery strategy seems
appropriate in order to position the input stream to the next data segment.
Note that cinfo[->]unread\_marker is treated as a marker appearing before
the current data-source input point; usually it should be reset to zero
before returning.
Returns FALSE if suspension is required.

This implementation is substantially constrained by wanting to treat the
input as a data stream; this means we can't back up.  Therefore, we have
only the following actions to work with:
  1. Simply discard the marker and let the entropy decoder resume at next
     byte of file.
  2. Read forward until we find another marker, discarding intervening
     data.  (In theory we could look ahead within the current bufferload,
     without having to discard data if we don't find the desired marker.
     This idea is not implemented here, in part because it makes behavior
     dependent on buffer size and chance buffer-boundary positions.)
  3. Leave the marker unread (by failing to zero cinfo[->]unread\_marker).
     This will cause the entropy decoder to process an empty data segment,
     inserting dummy zeroes, and then we will reprocess the marker.

2. is appropriate if we think the desired marker lies ahead, while 3. is
appropriate if the found marker is a future restart marker (indicating
that we have missed the desired restart marker, probably because it got
corrupted).
We apply 2. or 3. if the found marker is a restart marker no more than
two counts behind or ahead of the expected one.  We also apply 2. if the
found marker is not a legal JPEG marker code (it's certainly bogus data).
If the found marker is a restart marker more than 2 counts away, we do 1.
(too much risk that the marker is erroneous; with luck we will be able to
resync at some future point).
For any valid non-restart JPEG marker, we apply 3.  This keeps us from
overrunning the end of a scan.  An implementation limited to single-scan
files might find it better to apply 2. for markers other than EOI, since
any other marker would have to be bogus data in that case.

*/

// (eXt): no default resynch-method ... with flobs
//        'eXtension': if resynching required then not the image or
//        time is to be debugged, but the source code, either ours
//        or Lanes. =>

boolean
jpeg_flob_no_resync (j_decompress_ptr cinfo, int desired)
{
  // Always put up a warning.
  // WARNMS2(cinfo, JWRN_MUST_RESYNC, marker, desired);
  cerr << "jpeg_flob_no_resynch(): if code arrives here, debug it.";

  assert(false);
  return true;  // pro forma ... you may continue but you can't
}




/**
(Lane:)
Terminate source --- called by jpeg\_finish\_decompress
after all data has been read.  Often a no-op.

NB: *not* called by jpeg\_abort or jpeg\_destroy; surrounding
application must deal with any cleanup that should happen even
for error exit.

*/

static void
term_source (j_decompress_ptr cinfo)
{
  /* no work necessary here (Lane) */
}



// (eXt) (not-yet-)eXtension

static void
term_source_flob (j_decompress_ptr cinfo)
{
  // For only-one-time read of FLOB and no further use, we could
  // help Secondo-Cache-Manager by calling :
  //

  //  scr->fromFLOB->SaveToLob(); // if Size() > THRESHOLD

}


/**
(Lane)     (Lanes main fn()  for  preparing  the parsing process )

Prepare for input from a stdio stream.
The caller must have already opened the stream, and is responsible
for closing it after finishing decompression.

*/

void
jpeg_stdio_src (j_decompress_ptr cinfo, FILE * infile)
{
  my_src_ptr src;

  // The source object and input buffer are made permanent so that a series
  // of JPEG images can be read from the same file by calling jpeg_stdio_src
  // only before the first one.  (If we discarded the buffer at the end of
  // one image, we'd likely lose the start of the next one.)
  // This makes it unsafe to use this manager and a different source
  // manager serially with the same JPEG object.  Caveat programmer.
  //
  if (cinfo->src == NULL) { // first time for this JPEG object?
    cinfo->src = (struct jpeg_source_mgr *)
      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_PERMANENT,
				  SIZEOF(my_source_mgr));
    src = (my_src_ptr) cinfo->src;
    src->buffer = (JOCTET *)
      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_PERMANENT,
				  INPUT_BUF_SIZE * SIZEOF(JOCTET));
  }

  src = (my_src_ptr) cinfo->src;
  src->pub.init_source = init_source;
  src->pub.fill_input_buffer = fill_input_buffer;
  src->pub.skip_input_data = skip_input_data;
  src->pub.resync_to_restart = jpeg_resync_to_restart; // use default method
  src->pub.term_source = term_source;
  src->infile = infile;
  src->pub.bytes_in_buffer = 0; // forces fill_input_buffer on first read
  src->pub.next_input_byte = NULL; // until buffer loaded
}


/**
1.2 libjpeg-decompression-eXtension:  m a i n  method

(eXt:) eXtension  m a i n  method: prepare for parsing the FLOB bytes

Prepare for piece-wise input of bytes from FLOB.
FLOB must be valid: FLOB::Get(0,..) must return more than 0 Bytes.
FLOB must not be destructed as long as used by src. caveat: src is able to
read FLOB more than once by resetting its read-counters.

Receiving piece by piece may be an advantage over all-once-approach
in jpeg\_buffer\_src(), especially with very, very large JPEG-pictures.

*/

void
jpeg_flob_src (j_decompress_ptr cinfo, FLOB * flob)
{
  my_src_flob_ptr src;
  int input_buf_size = INPUT_BUF_SIZE;

  // "The source object and input buffer are made permanent so that a series
  // of JPEG images can be read from the same file by calling jpeg_stdio_src
  // only before the first one.  (If we discarded the buffer at the end of
  // one image, we'd likely lose the start of the next one.)
  // This makes it unsafe to use this manager and a different source
  // manager serially with the same JPEG object.  Caveat programmer."
  //
  // eXt: ?These problems should only emerge with streams? ?Is Problem, exactly
  // stated == 'loss of stream-bytes arriving DURING replacement of buffer'? ??
  //
  // It seems so. But there is no time-CAUSED loss in the source, if a FLOB.
  // There may only be a loss OF time if FLOB was removed from main memory, and
  // Get() must first bring it up. But FLOB::Get() and caller are on same
  // thread. ... => caveat does not apply.
  //
  if (cinfo->src == NULL) { // first time for this JPEG object?

    // (Permanently) allocate and set Source-Manager-Struct
    cinfo->src = (struct jpeg_source_mgr *)
      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_PERMANENT,
				  SIZEOF(my_source_flob_mgr));
    src = (my_src_flob_ptr) cinfo->src;

    // (Permanently) allocate buffer receiving the FLOB-copy piece-wise.
    src->buffer = (JOCTET *)
      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_PERMANENT,
				  input_buf_size * SIZEOF(JOCTET));
  }

  // Set init-values and user-defined (= our) functions
  src = (my_src_flob_ptr) cinfo->src; // (redundancy needed for first call)
  // .. user-fns()
  src->pub.init_source = init_source_flob;
  src->pub.fill_input_buffer = fill_input_buffer_fromFLOB;
  src->pub.skip_input_data = skip_input_flob_data;
  // to do for next call: improove default function ??? see comment above:
  // "Backtracking ...". next call equal to default jpeg_resync_to_restart
  src->pub.resync_to_restart = jpeg_flob_no_resync;
                                                    //
                          // = ; // default fn()
  src->pub.term_source = term_source_flob;
  // .. init-values
  src->fromFLOB = flob;
  src->pub.bytes_in_buffer = 0; // same as in jpeg_stdio_src: fill_input_buffer
                                // at start
  src->pub.next_input_byte = NULL; // same as in jpeg_stdio_src:
                                   // not yet initialized
}


// (eXt) quick and dirty  solution  with intermediate buffer.  deprecated.
//
//          ... simply replaces stream from jpeg_stdio_src by the ready buffer.
//             not a very proper solution to the 'workaround' problem, neither:
//( this is for the C-style solution; C++-supported solution: jpeg_flob_src() )

void
jpeg_buffer_src (j_decompress_ptr cinfo, char* bytes, size_t count)
{
  my_src_ptr src;

  // inpropernesses (1): still permanent JPool
  //                (2): explizit JOCTED->char cast
  //                (3): unused / unusefull fn()s
  //                (4): no appropriate failure mechanisms
  //                (5): whole array bytes... no streaming for very large bytes
  // shorty tested with infile = 0  and  infile = stdin: it works both.

  if (cinfo->src == NULL) { // first time for this JPEG object?
    cinfo->src = (struct jpeg_source_mgr *)
      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_PERMANENT,
                                  SIZEOF(my_source_mgr));
    src = (my_src_ptr) cinfo->src;
    src->buffer = (JOCTET*) bytes;
  }

  src = (my_src_ptr) cinfo->src;
  src->pub.init_source = init_source;
  src->pub.fill_input_buffer = 0;// fill_input_buffer; will not be called with
                                 // bytes[count]      !!! it is crucial to set
                                 // bytes_in_buffer <= count !!!
  src->pub.skip_input_data = skip_input_data;
  src->pub.resync_to_restart = jpeg_resync_to_restart; // use default method;
                                                    // never used if bytes ok.
  src->pub.term_source = term_source;
  src->infile = 0;// since fill_input_buffer not called => stream not utilized
  src->pub.bytes_in_buffer = count; // > 0 inhibits fill_input_buffer on first
                                    // read == 0  should crash (not tested)
  src->pub.next_input_byte = (JOCTET*) &(bytes[0]);
}
/**
1 Libjpeg-Extension for use with FLOBs - Part 2: Compression

jdatadstX.c

Copyright (C) 1994-1996, Thomas G. Lane.
This file is part of the Independent JPEG Group's software.

eXtended for use with flobs by Ulrich Neumann.

*/

//#include "jinclude.h"
#include "jpeglib.h"
#include "jerror.h"

// Expanded data destination object for FLOB output
typedef struct {
  struct jpeg_destination_mgr pub;

  FLOB * flob; // destination
  JOCTET * buffer;
  int offset;  // eXt: keep track of buffer-location for FLOB::Put()-call
} my_destination_flob_mgr;

typedef my_destination_flob_mgr * my_dest_flob_ptr;

#define OUTPUT_BUF_SIZE  1024 // FLOB::SWITCH_THRESHOLD should be optimal

static void
init_flob_destination (j_compress_ptr store_info)
{
  my_dest_flob_ptr dest = (my_dest_flob_ptr) store_info->dest;

  dest->buffer = (JOCTET *)
      (*store_info->mem->alloc_small) ((j_common_ptr) store_info, JPOOL_IMAGE,
        OUTPUT_BUF_SIZE * SIZEOF(JOCTET));

  dest->pub.next_output_byte = dest->buffer;
  dest->pub.free_in_buffer = OUTPUT_BUF_SIZE;
  dest->offset = 0;
}

static boolean
empty_toFlob_output_buffer (j_compress_ptr store_info)
{
  // fetch/set parameters
  my_dest_flob_ptr dest = (my_dest_flob_ptr) store_info->dest;

  // write to FLOB ... there shouldn't be more than this in the buffer
  if ((dest->offset + OUTPUT_BUF_SIZE) > dest->flob->Size())
    dest->flob->Resize(dest->offset + OUTPUT_BUF_SIZE);

  assert((dest->offset + OUTPUT_BUF_SIZE) <= dest->flob->Size());
      
  dest->flob->Put(dest->offset, OUTPUT_BUF_SIZE, dest->buffer);

  // change status-info: inc flob position, reset buffer position
  dest->pub.next_output_byte = dest->buffer;
  dest->pub.free_in_buffer = OUTPUT_BUF_SIZE ;
  dest->offset = dest->offset + OUTPUT_BUF_SIZE;

  return TRUE;
}

static void
term_flob_destination (j_compress_ptr store_info)
{
  my_dest_flob_ptr dest = (my_dest_flob_ptr) store_info->dest;
  int datacount = OUTPUT_BUF_SIZE - dest->pub.free_in_buffer;

  if ((dest->offset + datacount) > dest->flob->Size())
    dest->flob->Resize(dest->flob->Size() + datacount);


  // Write any data remaining in the buffer
  if (datacount > 0)
  {
    cout << "\nterm_flob_destination(), writing " << datacount
         << " additional bytes.\n";

    my_dest_flob_ptr dest = (my_dest_flob_ptr) store_info->dest;
    dest->flob->Put(dest->offset, datacount, dest->buffer);

    dest->offset = dest->offset + datacount;
  }

  cout << "\nCorrecting flobsize\n";
  dest->flob->Resize(dest->offset);
  
  // Make sure we wrote the output file OK
  // => done automatically for flobs ?
}                     

void
jpeg_flob_dest (j_compress_ptr store_info, FLOB * preparedFlob)
{
  my_dest_flob_ptr dest;

  if (store_info->dest == NULL) {
    store_info->dest = (struct jpeg_destination_mgr *)
      (*store_info->mem->alloc_small) ((j_common_ptr) store_info,
        // JPOOL_PERMANENT,
        JPOOL_IMAGE,                 // only needed once
        SIZEOF(my_destination_flob_mgr));
  }

  dest = (my_dest_flob_ptr) store_info->dest;
  dest->pub.init_destination = init_flob_destination;
  dest->pub.empty_output_buffer = empty_toFlob_output_buffer;
  dest->pub.term_destination = term_flob_destination;
    // .. init-values
  dest->flob = preparedFlob;
  dest->offset = 0;
}
/*******************************************************************************
//[newpage] [\newpage]
//[Appendix] [\appendix]


[newpage]

1 Appendix

[Appendix]

Please look at the actual versions of these example and test files in
directory \/TestJPEG\/

1 testfile1

[FILE ~testfile1~]

*/

# $HOME/secondo-jpeg/TestJPEG/testfile1

create database j;

open database j;

## vereinbarte Std-Bilder

(let testGray = (jpeg <file>girlsh.jpg</file--->));

(let testRGB = (jpeg <file>girlsrgb.jpg</file--->));

(let testCMYK = (jpeg <file>girlscmyk.jpg</file--->));

## Bilder < SWITCH_THRESHOLD
# gray

(let smallestG = (jpeg <file>stopAdobegray.jpg</file--->));

(let smallG1 = (jpeg <file>blobgray.jpg</file--->));

(let smallG2 = (jpeg <file>firegray.jpg</file--->));


# rgb

(let small1 = (jpeg <file>blobMini.jpg</file--->));

(let small2 = (jpeg <file>firergbMini.jpg</file--->));

(let small3 = (jpeg <file>strandMini.jpg</file--->));


## andere

(let testGraySharp = (jpeg <file>girlsh_sharp.jpg</file--->));

(let pi4 = (jpeg <file>pi4.jpg</file--->));

(let pi4gray = (jpeg <file>pi4sh.jpg</file--->));

(let firergb = (jpeg <file>firergb.jpg</file--->));

(let firegray = (jpeg <file>firegray.jpg</file--->));

(let blue = (jpeg <file>blau.jpg</file--->));

(let holz = (jpeg <file>wood.jpg</file--->));

(let sued = (jpeg <file>strand.jpg</file--->));

(let strand = (jpeg <file>strand.jpg</file--->));

(let wall_gray = (jpeg <file>wall_gray.jpg</file--->));

(let XV_gray = (jpeg <file>fromPNG_gray.jpg</file--->));


## binfile

(let bintest = (binfile <file>girlsh.jpg</file--->));

let bintest2 = bintest;


(let binMini = (binfile <file>strandMini.jpg</file--->));

let binMini2 = bintest;

## Relationen

# wahrscheinlich gleiche reljpeg2 wie herbert

(let reljpeg2 = ( (rel (tuple ( (name string) (pict jpeg)))) ( ("girlsgray" <file>girlsh.jpg</file--->) ("girlsrgb" <file>girlsrgb.jpg</file--->)
("girlsgray" <file>girlsh.jpg</file--->) )));

#

(let reljpeg = ( (rel (tuple ( (name string) (pict jpeg)))) ( ("firegray" <file>firegray.jpg</file--->) ("firergb" <file>firergb.jpg</file--->) ("firegray" <file>firegray.jpg</file--->) )));

# mixed grau/rgb, normal/klein
(let relj = ( (rel (tuple ( (name string) (pict jpeg)))) ( ("bounty" <file>strand.jpg</file--->) ("XVGray" <file>fromPNG_gray.jpg</file--->) ("feuergray" <file>firegray.jpg</file--->) )));

# mittelgross  rgb  + einmal 'written with Adobe Photoshop 5.0'

(let relj1 = ( (rel (tuple ( (name string) (pict jpeg)))) ( ("water" <file>blau.jpg</file--->) ("wood" <file>wood.jpg</file--->) ("adobe" <file>stopAdobe.jpg</file--->) )));

# rgb only

(let reljRGB = ( (rel (tuple ( (name string) (pict jpeg)))) ( ("blobRGB" <file>blob.jpg</file--->) ("Strand" <file>strand.jpg</file--->) ("fireRGB" <file>firergb.jpg</file--->) )));


# gray only

(let relj2 = ( (rel (tuple ( (name string) (pict jpeg)))) ( ("stopAdobesh" <file>stopAdobegray.jpg</file--->) ("pi4sh" <file>pi4sh.jpg</file--->) ("strandsh" <file>strandgray.jpg</file--->) )));



# smaller SWITCH_THRESHOLD

(let reljpegRGBklein = ( (rel (tuple ( (name string) (pict jpeg)))) ( ("blobRGB" <file>blobMini.jpg</file--->) ("Strand" <file>strandMini.jpg</file--->) ("fireRGB" <file>firergbMini.jpg</file--->) )));


################################ QUERIES

################
#compbrightdist#
################

# alte Version
#query firergb reljpeg feed compbrightdist [0.05] consume;

query firergb reljpeg feed compbrightdist [0.05, pict] consume;

       # alte Version
       #query testRGB reljpeg2 feed compbrightdist [0.05] consume;


# ergibt (natuerlich) leere Relation

query testRGB reljpeg2 feed compbrightdist [0.05, pict] consume;

# liefert ebenfalls leere Relation

query testGray reljpeg feed compbrightdist [0.05, pict] consume;

# alte version
#query testGray reljpeg2 feed compbrightdist [0.05] consume;
#query testGray reljpeg feed compbrightdist [0.05] consume;


# Ergebnis:  2
query testGray reljpeg2 feed compbrightdist [0.05, pict] count;

query testGray reljpeg2 feed compbrightdist [0.05, pict] consume;

# Ergebnis:  2
query testGray reljpeg2 feed compbrightdist [0.0001, pict] count;

# Ergebnis:  2
query testGray reljpeg2 feed compbrightdist [0.00000000000000001, pict] count;

# Ergebnis:  2
query testGray reljpeg2 feed compbrightdist [0.0, pict] count;

# Ergebnis:  0
query testGraySharp reljpeg2 feed compbrightdist [0.0, pict] count;

# Ergebnis:  0
query testGraySharp reljpeg2 feed compbrightdist [0.5, pict] count;

# Ergebnis:  2
query testGraySharp reljpeg2 feed compbrightdist [0.9, pict] count;

# todo: testen mit Bild sehr kleinen Unterschiedes

# Ergebnis: 0
query testRGB reljpeg2 feed compbrightdist [0.9, pict] count;

# Ergebnis: 0
query testRGB reljpeg2 feed compbrightdist [1.0, pict] count;

# Ergebnis: 0
query testGray reljpeg feed compbrightdist [1.0, pict] count;

# Ergebnis: 2
query firegray reljpeg feed compbrightdist [0.05, pict] count;

query firegray reljpeg feed compbrightdist [0.05, pict] consume;

query firegray reljpeg feed compbrightdist [0.05, pict] consume;

query firergb reljpeg feed compbrightdist [0.05, pict] consume;

query testRGB reljpeg2 feed compbrightdist [0.05, pict] consume;

query testGray testGray compbrightdist [0.2, dummy];

query testGray wall_gray compbrightdist [0.2, dummy];

###########
#jreadinfo#
###########

query jpegObject jreadinfo;

query reljpeg2 feed jreadinfo [pict] consume;

query reljpeg feed jreadinfo [pict] consume;

query relj1 feed jreadinfo [pict] consume;

query reljpeg2 feed jreadinfo [pict] count;

query reljpeg feed jreadinfo [pict] count;

query relj1 feed jreadinfo [pict] count;


###########################
#combrightdist + jreadinfo#
###########################

#query jpegObject reljpeg2 feed compbrightdist [0.001, pict] jreadinfo [pict] consume;

query firegray reljpeg feed compbrightdist [0.001, pict] jreadinfo [pict] consume;

query testGray reljpeg2 feed compbrightdist [0.001, pict] jreadinfo [pict] consume;

query testGray reljpeg feed compbrightdist [0.001, pict] jreadinfo [pict] consume;

query testGray reljpeg2 feed compbrightdist [0.05, pict] jreadinfo [pict] consume;

query testRGB reljpeg2 feed compbrightdist [0.05, pict] jreadinfo [pict] consume;


close database;

#delete database j;

q


/**
2 jpegtest

[FILE ~jpegtest~]

this can be executed with the TestRunner utility.

*/


# a test for the jpeg algebra
# run with : TestRunner -c MyConfig.config < jpegtest
# run in the TestJPEG directory
# (Runner can be found in directory UserInterfaces)

# February 07    Schoenhammer (first release; 30 testcases)

# clean up what may be left over from e.g. a segfault
delete database jpegtest;

#setup
create database jpegtest;
open database jpegtest;
e


############################################
# ObjectCreation                           #
############################################

#testcase ================================================ CreateJpegObject RGB
#yields success
(let firergb = (jpeg <file>firergb.jpg</file--->));

#testcase CreateJpegObject RGB
#yields success
(let girlsrgb = (jpeg <file>girlsrgb.jpg</file--->));

#testcase CreateJpegObject GrayScale
#yields success
(let firegray = (jpeg <file>firegray.jpg</file--->));

#testcase CreateJpegObject GrayScale
#yields success
(let girlsgray = (jpeg <file>girlsh.jpg</file--->));

#testcase CreateRelation_TowAttributs_OneObject;
#yields success
(let reljpeg1 = ( (rel (tuple ( (name string) (pict jpeg)))) ( ("girlsgray" <file>girlsh.jpg</file--->) )));

#testcase CreateRelation_TwoAttributs_ThreeObjects;
#yields success
(let reljpeg2 = ( (rel (tuple ( (name string) (pict jpeg)))) ( ("girlsgray" <file>girlsh.jpg</file--->) ("girlsrgb" <file>girlsrgb.jpg</file--->) ("girlsgray" <file>girlsh.jpg</file--->) )));

#testcase mixed gray/rgb, normal/small
(let relj = ( (rel (tuple ( (name string) (pict jpeg)))) ( ("bounty" <file>strand.jpg</file--->) ("XVGray" <file>fromPNG_gray.jpg</file--->) ("feuergray" <file>firegray.jpg</file--->) )));

#testcase Relation_Feed_and_Count;
#yields (int 3)
query reljpeg2 feed count;

# testcase pictures < SWITCH_THRESHOLD Gray
#yields success
(let smallestG = (jpeg <file>stopAdobegray.jpg</file--->));

#testcase pictures < SWITCH_THRESHOLD RGB
#yields success
(let small1 = (jpeg <file>blobMini.jpg</file--->));

################
#compbrightdist#
################

#testcase ====== compbrightdist with single jpeg-object: first gray second gray
#yields (bool TRUE)
query firegray firegray compbrightdist [0.0001, dummy];

#testcase compbrightdist with single jpeg-object: first rgb
#yields (bool FALSE)
query firergb firegray compbrightdist [0.0001, dummy];

#testcase compbrightdist with single jpeg-object: first gray second rgb
#yields (bool FALSE)
query firegray firergb compbrightdist [0.0001, dummy];

#testcase compbrightdist with stream: no result
#yields (int 0)
query firegray reljpeg2 feed compbrightdist [0.1, pict] count;

#testcase compbrightdist with stream: 2 identic pictures count
#yields (int 2)
query girlsgray reljpeg2 feed compbrightdist [0.01, pict] count;

#testcase compbrightdist with stream: 2 identic pictures consume
#yields success
query girlsgray reljpeg2 feed compbrightdist [0.01, pict] consume;

################
#comprgbdist#
################

#testcase =========== comprgbdist with single jpeg-object: first rgb second rgb
#yields (bool TRUE)
query firergb firergb comprgbdist [0.0001, 0.0001, 0.0001, dummy];

#testcase comprgbdist with single jpeg-object: first rgb second gray
#yields (bool FALSE)
query firergb firegray comprgbdist [0.000001, 0.0001, 0.0001,dummy];

#testcase comprgbdist with single jpeg-object: first gray second rgb
#yields (bool FALSE)
query firegray firergb comprgbdist [0.000001, 0.0001, 0.0001,dummy];


#########################
#comprgbdist + jreadinfo#
#########################

### To do: tests with streams: actual result = crash



###########
#jreadinfo#
###########

#testcase ======== jreadinfo with single jpeg-object: gray
#yields success
query girlsgray jreadinfo [dummy];

#testcase jreadinfo with single jpeg-object: rgb
#yields success
query girlsrgb jreadinfo [dummy];

#testcase jreadinfo with stream of tuples
#yields success
query reljpeg2 feed jreadinfo [pict] consume;

#testcase jreadinfo with stream of tuples
#yields (int 3)
query reljpeg2 feed jreadinfo [pict] count;

###########################
#combrightdist + jreadinfo#
###########################

#testcase compbrightdist single jpeg-Object + jreadinfo
#yields success
query girlsrgb jreadinfo [dummy];

#testcase compbrightdist stream-Object + jreadinfo
#yields (int 1)
query firegray relj feed compbrightdist [0.001, pict] jreadinfo [pict] count;

#testcase compbrightdist first = rgb
#yields (int 0)
query firergb relj feed compbrightdist [0.001, pict] jreadinfo [pict] count;

#########################################
# jinfo                                 #
#########################################

#testcase jinfo object creation
#yields success
let ji1 = girlsgray jreadinfo [dummy];

#testcase query jinfo
#yields success
query ji1;

#testcase jinfo - relation
#yields success
let reljinfo = reljpeg2 feed jreadinfo [pict] consume;

#testcase jinfo - relationb query and count
#yields (int 3)
query reljinfo feed count;

#teardown
close database;
delete database jpegtest;


/**
3 testCUTDOWNSIZE

[FILE ~testCUTDOWNSIZE~]

*/

open database j;

query testGray cut [0, 0, 100, 100];

query testRGB cut [0, 0, 100, 100] show;

let testGraycut1 = testGray cut[0,0,279,215];

#true
query testGray testGraycut1 compbrightdist [0.3125, pict];

#false
query testGray testGraycut1 compbrightdist [0.1, pict];

let testRGBcut11 = testRGB cut[0,0,279,215];

# true
query testRGB testRGBcut1 comprgbdist [0.1, 0.1, 0.1, pict];

#(false)
query testRGB testRGBcut1 comprgbdist [0.001, 0.001, 0.001, pict];

query testRGB testRGB comprgbdist [0.001, 0.001, 0.001, pict];

query testGray cut [0, 0, 100, 100] show;

query testGray cut [0, 0, 100, 100];

query testGray cut [0, 0, 279, 215];

query testGray cut [0, 0, 279, 215] show;

query testGray cut [0, 0, 140, 108] show;

query testGray cut [0, 0, 140, 215] show;

query testGray cut [0, 0, 279, 108] show;


query testRGB cut [0, 0, 100, 100] show;

query testRGB cut [0, 0, 100, 100];

query testRGB cut [0, 0, 279, 215];

query testRGB cut [0, 0, 279, 215] show;

query testRGB cut [0, 0, 140, 108] show;

query testRGB cut [0, 0, 140, 215] show;

query testRGB cut [0, 0, 279, 108] show;

query testRGB cut [0, 0, 100, 100] show;




query testCMYK cut [0, 0, 100, 100];

query testCMYK cut [0, 0, 279, 215];

query testCMYK cut [0, 0, 279, 215] show;

query testCMYK cut [0, 0, 140, 108] show;

query testCMYK cut [0, 0, 140, 215] show;

query testCMYK cut [0, 0, 279, 108] show;



#ok
query firergb cut [2,2,10,10];

#ok
query firergb cut [2,2,10,10] show;

# user error: "Can't cut: Coordinates are not within source-jpeg."
query firergb cut [22,22,10,10];

# FALSE  error messages:
#       Can't cut: Coordinates are not within source-jpeg.
#       error: ShowJpegFun() received 0x00 as arg for jpeg.
query firergb cut [22,22,10,10] show;

#ok
query firergb cut [20,20,100,8];

# ok
query firergb cut [20,20,100,8] show;

# TRUE
query firergb cut [22,20,100,8] show;

#ok
query firergb cut [0,0,10,10];

#ok
query firergb cut [0,0,10,10] show;

# ok. error messages:
#  Can't cut: Coordinates are not within source-jpeg.
#  error: OutJPEG received 0x00 instead of jpeg-address.
query firergb cut [0,0,100,310];

#ok
query testRGB downsize 50;

#ok
query testRGB downsize 20;

#ok
query testGray downsize 50;

#ok
query testGray downsize 20;

#ok
let testRGB50 = testRGB downsize 50;

#ok
query testRGB50 show;

#ok
let testRGB20 = testRGB downsize 20;

#ok (in Wasserglas)
query testRGB20 show;

#ok
query testRGB50 savejpegto "downRGB50.jpg" ;

#ok
query testRGB20 savejpegto "downRGB20.jpg" ;

#ok
let testRGB5 = testRGB downsize 5;

#ok  nearly tiles
query testRGB5 show;

#ok
query testRGB5 savejpegto "downRGB5.jpg" ;

# ok: overwrites
query testRGB5 savejpegto "downRGB5.jpg" ;

#ok
let testGray50 = testGray downsize 50;

#ok
query testGray50 show;

#ok
query testGray50 savejpegto "downG50.jpg";

#ok
let testGray1percent = testGray downsize 1;

#ok
query testGray1percent show;

#ok
query testGray1percent savejpegto "downG1.jpg";

query (testGray downsize 0);

#ok
query testGray downsize 0;

# Incorrect input types for operator downsize:Quality-value is not an int.
query testGray downsize 0 show;

# Incorrect input types for operator downsize:Quality-value is not an int.
query testGray downsize 70 show;

#ok
query (testGray downsize 70) show;

query (testGray downsize 0) show;

query (testGray downsize 0) demo;

# TRUE  user error message:
#       Quality Range must be 0 to 100 (meaning per cent), corrected to 0.
query (testGray downsize -2) demo;

# ok  user error message:
#     Quality Range must be 0 to 100 (meaning per cent), corrected to 0.
query (testGray downsize -2) show;

# ok  user error message:
#     Quality Range must be 0 to 100 (meaning per cent), corrected to 100.
query (testGray downsize 200) show;

