/*
This class is a FixedMRegion.

*/
using namespace std;
#include "FixedMRegion.h"
//#define DEBUG_VERBOSE
//#define DEBUG_VERBOSE2
/*
This is the default constructor. Do not use.

*/
FixedMRegion::FixedMRegion ():r (NULL)
{
}


static const string BasicType() { return "fixedmregion";}

static const bool checkType(const ListExpr list) {
return listutils::isSymbol(list, BasicType());};
/*
This is the copy constructor.

*/
FixedMRegion::FixedMRegion (const FixedMRegion & f):
t (f.t),
m (f.m),
r (f.r),
l (f.l)
{
}

/*
This is the constructor. It gets necessary information. 

*/
FixedMRegion::FixedMRegion (Region * _region, const Move & _move,
                            const Point & rot_center, double _starttime)
{
  r = _region;
  m = _move;
  t = _starttime;
  xm = rot_center.GetX ();
  ym = rot_center.GetY ();
  calculateInternalVars ();
}

FixedMRegion::FixedMRegion (double _t, double _xm, double _ym,
                            Region * _r, double _x0, double _y0,
                            double _alpha0, double _vx, double _vy,
                            double _valpha)
{
  t = _t;
  xm = _xm;
  ym = _ym;
  r = _r;
  m = Move (_x0, _y0, _alpha0, _vx, _vy, _valpha);
  calculateInternalVars ();
}


FixedMRegion::FixedMRegion (Region * _region, const Point & _start,
                            double alpha_start, const Point & _speed,
                            double alpha_speed, const Point & rot_center,
                            double _starttime)
{
  r = _region;
  m = Move (_start.GetX (), _start.GetY (), alpha_start, _speed.GetX (),
            _speed.GetY (), alpha_speed);
  t = _starttime;
  xm = rot_center.GetX ();
  ym = rot_center.GetY ();
  calculateInternalVars ();
}

/*
This is the standard destructor.

*/
FixedMRegion::~FixedMRegion ()
{
  if (r != NULL)
    delete r;
}

Region
FixedMRegion::interpolate (Region * spots)
{
  Point *p1 = new Point (true, 0.0, 0.0);
  Point *p2 = new Point (true, 1.0, 0.0);
  Point *p3 = new Point (true, 0.0, 1.0);
  Region result = Region (*p1, *p2, *p3);
  return result;
  //TODO
}

Region *
FixedMRegion::atinstant (double ti)
{
  sett (ti);
  Region *result = new Region (*r);
  HalfSegment hs;
  result->StartBulkLoad ();
  for (int i = 0; i < result->Size (); i++)
    {
      result->Get (i, hs);

      const Point lp = hs.GetLeftPoint ();
      //printf("Pl%d=(%f,%f)\n",i,lp.GetX(),lp.GetY());
      double newx = l.getImgX (lp.GetX (), lp.GetY ());
      double newy = l.getImgY (lp.GetX (), lp.GetY ());
      Point newlp (true, newx, newy);

      const Point rp = hs.GetRightPoint ();
      //printf("Pr%d=(%f,%f)\n",i,rp.GetX(),rp.GetY());
      newx = l.getImgX (rp.GetX (), rp.GetY ());
      newy = l.getImgY (rp.GetX (), rp.GetY ());
      Point newrp (true, newx, newy);
      //printf("Pnl%d=(%f,%f)\n",i,newlp.GetX(),newlp.GetY());
      //printf("Pnr%d=(%f,%f)\n",i,newrp.GetX(),newrp.GetY());
      //HalfSegment tmp= HalfSegment(false, newlp,newrp);
      hs.Set (hs.IsLeftDomPoint (), newlp, newrp);

      result->Put (i, hs);
    }
  result->EndBulkLoad ();
  return result;
}

Point FixedMRegion::getInvRelatime(double t, const Point & p) const {
  double *coord = m.attime(t, true);
  LATransform lt(coord[0], coord[1], xm, ym, coord[2]);
  delete coord;
  double tmpx=lt.getOrigX(p.GetX(), p.GetY());
  double tmpy=lt.getOrigY(p.GetX(), p.GetY());
  return Point(true, tmpx, tmpy);
}

Point FixedMRegion::getTransPoint(DateTime t, const Point & p) const {
  double *coord = m.attime (t);
  LATransform lt(coord[0], coord[1], xm, ym, coord[2]);
  delete coord;
  double tmpx=lt.getImgX(p.GetX(), p.GetY());
  double tmpy=lt.getImgY(p.GetX(), p.GetY());
  return Point(true, tmpx, tmpy);
}  


MPoint FixedMRegion::approxMovement(const MPoint &p, double precision) const {
  UPoint unit;
  p.Get(p.GetNoComponents()-1, unit);
  Instant ite=unit.getTimeInterval().end-m.getStart();

  p.Get(0, unit);
  Instant ita=unit.getTimeInterval().start-m.getStart();  
  
  //te and ta are relatime
  double te=ita.ToDouble();
  double ta=(ite-ita).ToDouble();
  
  MPoint res(0);
  res.StartBulkLoad();
  
  double i=ta+precision;
  DateTime to(m.getStart());
  Point po=getInvRelatime(ta, unit.p0);
  
  //FIXME: erreichen wir hier tatsächlich genau das Ende?
  do {
    if (i>te)
      i=te;
    DateTime tn(i);
    tn+=m.getStart(); //convert to absolute time
    Intime<Point> tp;
    p.AtInstant(tn, tp);
    Point pn=getInvRelatime(i, tp.value);
    Interval<Instant> in(to, tn, true, false);
    UPoint up(in, po.GetX(), po.GetY(), pn.GetX(), pn.GetY());
    res.MergeAdd(up);
    i+=precision;
    to=tn;
    po=pn;
  } while (i<=te);   
  res.EndBulkLoad();
  return res;
}

MRegion * FixedMRegion::buildMovingRegion() {
  MRegion *mr;
    Region *r =atinstant (m.getStart(0.0));
    MPoint rock (0);
    rock.Clear ();
    rock.StartBulkLoad ();
    DateTime t1 (instanttype);
    t1.Set (0, 1, 1, 0, 0);
    DateTime t2 (instanttype);
    t2.Set (3999, 12, 31, 23, 59);
    Interval < Instant > iv (t1, t2, false, true);
    UPoint ub (iv, 0, 0, 0, 0);
    rock.MergeAdd (ub);
    rock.EndBulkLoad ();
    //Stillstehende MovingRegion erzeugen
    mr = new MRegion (rock, *r);
    delete r;
    return mr;
}

MBool
FixedMRegion::inside (const MPoint & mp)
{
  MRegion *rfix = buildMovingRegion();
  MPoint tmp=approxMovement(mp, 1e-5);
  MBool res (0);
  rfix->Inside(tmp, res);
  delete rfix;
  return res;
}



//Evtl. Zeitintervalle aus p holen und Orte aus dem Orginalpunkt
MPoint FixedMRegion::reverseMovement(const MPoint& p) const {  
  MPoint res(0);
  res.StartBulkLoad();
  for (int i=0; i<p.GetNoComponents(); i++) {
    UPoint unit;
    p.Get(i, unit);
    Point p0=getTransPoint(unit.getTimeInterval().start,unit.p0);
    Point p1=getTransPoint(unit.getTimeInterval().end,unit.p1);
    UPoint u2(unit.getTimeInterval(), p0, p1);
    res.MergeAdd(u2);
  }
  res.EndBulkLoad();
  return res;
  
}

MPoint
FixedMRegion::intersection (MPoint & mp)
{
  MRegion *rfix = buildMovingRegion();
  MPoint tmp=approxMovement(mp, 1e-5);
  MPoint res(0);
  rfix->Intersection(tmp, res);
  delete rfix;
  return reverseMovement(res);
}



Region *
FixedMRegion::traversed2 (double ta, double te, double precision)
{
  Region *res = NULL;
  for (double i = 0; i <= (te - ta); i = i + precision)
    {
      Region *tmp = atinstant (ta + i);
      if (res == NULL)
        {
          res = tmp;
        }
      else
        {
          Region *tmp2 = new Region (*res);
          tmp2->Clear ();
          //res->Union(*tmp, *tmp2);
          RobustPlaneSweep::robustUnion (*res, *tmp, *tmp2);
          delete tmp;
          delete res;
          res = tmp2;
        }
    }
  return res;
}


Point
FixedMRegion::getIntersectionPoint (const Point & p1,
                                    const Point & p2,
                                    const Point & p3, const Point & p4)
{
  double x1 = p1.GetX ();
  double y1 = p1.GetY ();
  double x2 = p2.GetX ();
  double y2 = p2.GetY ();
  double x3 = p3.GetX ();
  double y3 = p3.GetY ();
  double x4 = p4.GetX ();
  double y4 = p4.GetY ();

  double a, b, c, d, e, f, D, Dx;
  double t;

  a = x1 - x3;
  b = x1 - x2;
  c = x4 - x3;

  d = y1 - y3;
  e = y1 - y2;
  f = y4 - y3;

  D = b * f - c * e;

  //if (D==0) {
  //Fallunterscheidung nicht notwendig, weil nur in Spezialfällen aufgerufen
  //}

  Dx = a * f - c * d;

  t = Dx / D;

  double x = x1 + (x2 - x1) * t;
  double y = y1 + (y2 - y1) * t;
  Point p_res = Point (true, x, y);
  return p_res;
}

int
FixedMRegion::getTraversedCase (const Point & p1, const Point & p2,
                                const Point & p3, const Point & p4)
{
  double x1 = p1.GetX ();
  double y1 = p1.GetY ();
  double x2 = p2.GetX ();
  double y2 = p2.GetY ();
  double x3 = p3.GetX ();
  double y3 = p3.GetY ();
  double x4 = p4.GetX ();
  double y4 = p4.GetY ();
#ifdef DEBUG_VERBOSE
  printf ("gettraversedcase P1: (%f, %f), P2:" 
        "(%f, %f), P3: (%f, %f), P4: (%f, %f), ", x1, y1, x2, y2, x3, y3, x4, y4);
#endif
  double a, b, c, d, e, f, D, Dx, Dy;
  double t, s;

  a = x1 - x3;
  b = x1 - x2;
  c = x4 - x3;

  d = y1 - y3;
  e = y1 - y2;
  f = y4 - y3;

  D = b * f - c * e;

  if (AlmostEqual (D, 0.0))
    {
      //Fallunterscheidung Geraden parallel oder aufeinander:
      //Strecken parallel zur x-Achse
      if (AlmostEqual (x1, x2))
        {
          if (AlmostEqual (x3, x1))
            {
              return -2;
            }
          else
            {
              return -1;
            }
        }
      double t = (x3 - x1) / (x2 - x1);
      if (AlmostEqual (y3, y1 + (y2 - y1) * t))
        {
          //Geraden liegen aufeinander
          return -2;
        }
      else
        {
          //Geraden liegen parallel
          return -1;
        }
    }

  Dx = a * f - c * d;
  Dy = b * d - a * e;

  t = Dx / D;
  s = Dy / D;
//Strecke1: (x1, y1), (x2, y2)
//Strecke2: (x3, y3), (x4, y4)
  int cc = 0;                   // Schnitt außerhalb
  //Fallunterscheidung nach (x1, y1), (x2, y2)
  if ((t > 0) && (t < 1))
    cc = 3;                     //Schnitt zwischen (x1, y1) und (x2, y2)
  if (AlmostEqual (t, 0))
    cc = 1;                     //Schnitt auf (x1, y1)
  if (AlmostEqual (t, 1))
    cc = 2;                     //Schnitt auf (x2, y2)
  //Fallunterscheidung nach (x3, y3), (x4, y4)
  if ((s > 0) && (s < 1))
    cc += 12;                   //Schnitt zwischen (x3, y3) und (x4, y4)
  if (AlmostEqual (s, 0))
    cc += 4;                    //Schnitt auf (x3, y3)
  if (AlmostEqual (s, 1))
    cc += 8;                    // Schnitt auf (x4, y4)

#ifdef DEBUG_VERBOSE
  printf ("Schnittpunkt: %3.2f, %3.2f\n", x1 + (x2 - x1) * t,
          y1 + (y2 - y1) * t);
#endif

  return cc;
}

vector < vector < Point > >FixedMRegion::traversedGetVectorVector (vector <
                                                                   Point > v)
{
  vector < vector < Point > >vv;
  //Einen Vektor von Vektoren erzeugen
  vv.push_back (v);
  //Die einzelnen Polygonzüge hinzufügen (hier nur einer)
  return vv;
}

vector < vector < Point >
  >FixedMRegion::traversedCalculateQuadrangle (const Point & p1,
                                               const Point & p2,
                                               const Point & p3,
                                               const Point & p4)
{
  vector < Point > v;           //Vektor für den Polygonzug
  v.push_back (p1);
  //Die einzelnen Punkte hinzufügen
  v.push_back (p2);
  v.push_back (p3);
  v.push_back (p4);
  v.push_back (p1);             //Den ersten zum Schluss nochmal
  return traversedGetVectorVector (v);
}

vector < Point > FixedMRegion::traversedCalcTriangle (const Point & p1,
                                                      const Point & p2,
                                                      const Point & p3)
{
  vector < Point > v;           //Vektor für den Polygonzug
  v.push_back (p1);
  //Die einzelnen Punkte hinzufügen
  v.push_back (p2);
  v.push_back (p3);
  v.push_back (p1);             //Den ersten zum Schluss nochmal
  return v;
}

vector < vector < Point >
  >FixedMRegion::traversedCalculateTriangle (const Point & p1,
                                             const Point & p2, const Point & p3)
{
  vector < Point > v;           //Vektor für den Polygonzug
  v = traversedCalcTriangle (p1, p2, p3);
  return traversedGetVectorVector (v);
}

vector < vector < Point >
  >FixedMRegion::traversedCalculateTwoTriangles (Point p1, Point p2,
                                                 Point p3, Point p4)
{
  Point
    pi = getIntersectionPoint (p1, p2, p3, p4);
  vector < Point > t1;          //Vektor für den Polygonzug
  vector < Point > t2;
  t1 = traversedCalcTriangle (pi, p1, p3);
  t2 = traversedCalcTriangle (pi, p2, p4);
  vector < vector < Point > >vv;        //Einen Vektor von Vektoren erzeugen
  vv.push_back (t1);
  //Die einzelnen Polygonzüge hinzufügen (hier nur einer)
  vv.push_back (t2);
  return vv;
}


vector < vector < Point >
  >FixedMRegion::getTraversedArea (const HalfSegment & hsold,
                                   const HalfSegment & hsnew)
{
  vector < vector < Point > >res;
  Point
    p1 = hsold.GetDomPoint ();
  Point
    p2 = hsold.GetSecPoint ();
  Point
    p3 = hsnew.GetDomPoint ();
  Point
    p4 = hsnew.GetSecPoint ();
  vector < Point > v;
  int
    casetype = getTraversedCase (p1, p2, p3, p4);
#ifdef DEBUG_VERBOSE2
  printf ("P1: (%f, %f), P2: (%f, %f), P3: (%f, %f), P4: (%f, %f), ",
          p1.GetX (), p1.GetY (),
          p2.GetX (), p2.GetY (),
          p3.GetX (), p3.GetY (), p4.GetX (), p4.GetY ());
  printf ("Case: %d\n", casetype);
#endif
  switch (casetype)
    {
    case -1:                   //Strecken sind parallel
      //1
    case 0:                    //Schnittpunkt liegt außerhalb beider Strecken
      //2
    case 3:                    //Schnittpunkt liegt innerhalb Strecke1 und außerhalb Strecke2
      //16
    case 12:                   //Schnittpunkt liegt außerhalb Strecke1 und innerhalb Strecke2
      //13
      res = traversedCalculateQuadrangle (p1, p2, p4, p3);
      break;

    case 15:                   //Schnittpunkt liegt innerhalb Strecke1 und innerhalb Strecke2
      //6
      res = traversedCalculateTwoTriangles (p1, p2, p3, p4);
      break;
    case -2:                   //Strecken liegen auf der selben Geraden
      //Entartung
      break;
    case 2:                    //Schnittpunkt liegt auf P2 und außerhalb Strecke2
      //8
      res = traversedCalculateTriangle (p1, p2, p3);
      break;
    case 1:                    //Schnittpunkt liegt auf P1 und außerhalb Strecke2
      //3
      res = traversedCalculateTriangle (p1, p2, p4);
      break;
    case 4:                    //Schnittpunkt liegt außerhalb Strecke1 und auf P3
      //12
      res = traversedCalculateTriangle (p2, p3, p4);
      break;
    case 5:                    //Schnittpunkt liegt auf P1 und auf P3
      //4
      res = traversedCalculateTriangle (p1, p2, p4);
      break;
    case 8:                    //Schnittpunkt liegt außerhalb Strecke1 und auf P4
      //14
      res = traversedCalculateTriangle (p1, p3, p4);
      break;
    case 6:                    //Schnittpunkt liegt auf P2 und auf P3
      //9
      res = traversedCalculateTriangle (p1, p2, p4);
      break;
    case 7:                    //Schnittpunkt liegt innerhalb Strecke1 und auf P3
      //15
      res = traversedCalculateTriangle (p1, p2, p4);
      break;
    case 9:                    //Schnittpunkt liegt auf P1 und auf P4
      //7
      res = traversedCalculateTriangle (p1, p2, p3);
      break;
    case 10:                   //Schnittpunkt liegt auf P2 und auf P4
      //10
      res = traversedCalculateTriangle (p1, p2, p3);
      break;
    case 11:                   //Schnittpunkt liegt innerhalb Strecke1 und auf P4
      //17
      res = traversedCalculateTriangle (p1, p3, p4);
      break;
    case 13:                   //Schnittpunkt liegt auf P1 und innerhalb Strecke2
      //5
      res = traversedCalculateTriangle (p1, p2, p4);
      break;
    case 14:                   //Schnittpunkt liegt auf P2 und innerhalb Strecke2
      //11
      res = traversedCalculateTriangle (p1, p2, p3);
      break;

    default:
      assert (false);
      break;
    }
  return res;
}

void
FixedMRegion::traversedCreateCyclesNotHoles (vector < vector < Point > >&v_list)
{
#ifdef DEBUG_VERBOSE
  printf ("Numcycles: %d", v_list.size ());
#endif
  for (size_t i = 0; i < v_list.size (); i++)
    {
      if (!getDir (v_list[i]))
        {
#ifdef DEBUG_VERBOSE
          printf ("R: %d, ", i);
#endif
          reverseCycle (v_list[i]);
        }
    }
#ifdef DEBUG_VERBOSE
  printf ("\n");
#endif
}

vector < HalfSegment > FixedMRegion::getHSFromRegion ()
{
  vector < HalfSegment > result;
  for (int i = 0; i < r->Size (); i++)
    {
      HalfSegment
        tmp;
      r->Get (i, tmp);
      if (tmp.IsLeftDomPoint ())
        {
          result.push_back (tmp);
        }
    }
  return result;
}

vector < HalfSegment > *FixedMRegion::atinstant (double ti,
                                                 const vector <
                                                 HalfSegment > &v)
{
  sett (ti);
  vector < HalfSegment > *result = new vector < HalfSegment > (v.size ());
  HalfSegment
    hs;
  for (size_t i = 0; i < v.size (); i++)
    {
      hs = v[i];

      const Point
        lp = hs.GetLeftPoint ();
      double
        newx = l.getImgX (lp.GetX (), lp.GetY ());
      double
        newy = l.getImgY (lp.GetX (), lp.GetY ());
      Point
      newlp (true, newx, newy);

      const Point
        rp = hs.GetRightPoint ();
      newx = l.getImgX (rp.GetX (), rp.GetY ());
      newy = l.getImgY (rp.GetX (), rp.GetY ());
      Point
      newrp (true, newx, newy);
      hs.Set (hs.IsLeftDomPoint (), newlp, newrp);

      result->push_back (hs);
    }
  return result;
}



Region *
FixedMRegion::getDiffRegion (const vector < HalfSegment >
                             *resultold,
                             const vector < HalfSegment > *resultnew)
{
  Region *diffregion = NULL;
  Region *tmp2 = NULL;
  Region *tmp_region = NULL;
  HalfSegment hsold;
  HalfSegment hsnew;
  for (size_t i = 0; i < resultold->size (); i++)
    {
      hsold = (*resultold)[i];
      hsnew = (*resultnew)[i];
      vector < vector < Point > >tmp_polygons = getTraversedArea (hsold, hsnew);

      if (tmp_polygons.size () > 0)
        {
          //routine zum orientierung prüfen und korrigieren
          traversedCreateCyclesNotHoles (tmp_polygons);

          tmp_region = buildRegion2 (tmp_polygons);     //Region erstellen
#ifdef DEBUG_VERBOSE
          vector < Region * >v;
          tmp_region->Components (v);
          printf ("No. Components: %d\n", v.size ());
          for (size_t j = 0; j < v.size (); j++)
            delete v[j];
#endif

          if (diffregion == NULL)
            {
              diffregion = tmp_region;
            }
          else
            {
              tmp2 = new Region (0);
              RobustPlaneSweep::robustUnion (*diffregion, *tmp_region, *tmp2);
              delete diffregion;
              delete tmp_region;
              diffregion = tmp2;
            }
        }
    }
  return diffregion;
}

Region *
FixedMRegion::traversed (double ta, double te, double precision)
{
  Region *res = atinstant (ta);
  vector < HalfSegment > vhs = getHSFromRegion ();
  vector < HalfSegment > *tiold = atinstant (ta, vhs);
  for (double i = 0; i <= (te - ta); i = i + precision)
    {
      vector < HalfSegment > *tinew = atinstant (ta + i, vhs);
      Region *tmp = getDiffRegion (tiold, tinew);
      if (tmp != NULL)
        {
          Region *tmp2 = new Region (*res);
          tmp2->Clear ();
          //res->Union(*tmp, *tmp2);
          RobustPlaneSweep::robustUnion (*res, *tmp, *tmp2);
          delete tmp;
          delete res;
          res = tmp2;
        }
      delete tiold;
      tiold = tinew;
    }
  delete tiold;
  return res;
}


const Region *
FixedMRegion::getRegion () const
{
  return r;
}

void
FixedMRegion::setRegion (Region * _r)
{
  if (r != NULL)
    delete r;
  r = _r;
}

const double
FixedMRegion::gett () const
{
  return t;
}

void
FixedMRegion::sett (double _t)
{
  t = _t;
  calculateInternalVars ();
}

 //TODO   
void
FixedMRegion::calculateInternalVars ()
{
  double *coord = m.attime (t);
  l = LATransform (coord[0], coord[1], xm, ym, coord[2]);
  delete coord;
}

const LATransform &
FixedMRegion::getLATransform ()
{
  return l;
}

void
FixedMRegion::setLATransform (const LATransform & _l)
{
  l = _l;
}

const Move &
FixedMRegion::getMove ()
{
  return m;
}

void
FixedMRegion::setMove (const Move & _m)
{
  m = _m;
}

  ListExpr FixedMRegionProperty() {
    return  nl->TwoElemList (
      nl->FourElemList (
      nl->StringAtom("Signature"),
      nl->StringAtom("Example Type List"),
      nl->StringAtom("List Rep"),
      nl->StringAtom("Example List")),
    nl->FourElemList (
      nl->StringAtom("-> DATA"),
      nl->StringAtom(FixedMRegion::BasicType()),
      nl->StringAtom("(real real real real real real real real real) = 
      (t,xm,ym,r,m,_x0,_y0,_alpha0,_vx,_vy,_valpha)"),
      nl->StringAtom("(13.5 -76.0 1.2 2.3 3.4 4.5 4.6 6.7 8.9)")
    ));
    }
  

Word InFixedMRegion( const ListExpr typeInfo, const ListExpr instance,
const int errorPos, ListExpr& errorInfo, bool& correct){
  Word res((void*)0);
  correct = false;
  if(!nl->HasLength(instance,9)){
    return res;
  }
  if(
    !listutils::isNumeric(nl->First(instance))
    || !listutils::isNumeric(nl->Second(instance))){
      return res;
      //FIXME: Test verbessern
    }
  double x = listutils::getNumValue(nl->First(instance));
  double y = listutils::getNumValue(nl->Second(instance));

  correct = true;
  res.addr = new FixedMRegion(x,y);
  return res;
}

ListExpr OutFixedMRegion( ListExpr typeInfo, Word value ) {
FixedMRegion* k = (FixedMRegion*) value.addr;
return nl->TwoElemList(
nl->RealAtom(k->getX()),
nl->RealAtom(k->getY()));
}

Word CreateFixedMRegion( const ListExpr typeInfo ) {
  Word w;
  w.addr = (new FixedMRegion(0,0));
  return w;
}

void DeleteFixedMRegion( const ListExpr typeInfo, Word& w ) {
  FixedMRegion *k = (FixedMRegion *)w.addr;
  delete k;
  w.addr = 0;
}

bool SaveFixedMRegion(  SmiRecord& valueRecord, size_t& offset,
const ListExpr typeInfo, Word& value ) {
  FixedMRegion* k = static_cast<FixedMRegion*>( value.addr );
  size_t size = sizeof(double);
  double v = k->getX();
  bool ok = valueRecord.Write( &v, size, offset );
  offset += size;
  v = k->getY();
  ok = ok && valueRecord.Write(&v,size,offset);
  offset += size;
  return ok;
}

bool OpenFixedMRegion( SmiRecord& valueRecord,
size_t& offset, const ListExpr typeInfo,
Word& value ){
  size_t size = sizeof(double);
  double x,y;
  bool ok = valueRecord.Read(&x,size,offset);
  offset += size;
  ok = ok && valueRecord.Read(&y,size,offset);
  offset += size;
  if(ok){
  value.addr = new FixedMRegion(x,y);
  } else {
    value.addr = 0;
  }
  return ok;
}

void CloseFixedMRegion( const ListExpr typeInfo, Word& w ) {
  FixedMRegion *k = (FixedMRegion *)w.addr;
  delete k;
  w.addr = 0;
}

Word CloneFixedMRegion( const ListExpr typeInfo, const Word& w ){
  FixedMRegion* k = (FixedMRegion*) w.addr;
  Word res;
  res.addr = new FixedMRegion(k->getX(), k->getY());
  return res;
}

void* CastFixedMRegion( void* addr ) {
  return (new (addr) FixedMRegion);
}

int SizeOfFixedMRegion() {
  return 2*sizeof(double);
}

bool FixedMRegionTypeCheck(ListExpr type, ListExpr& errorInfo){
  return nl->IsEqual(type, FixedMRegion::BasicType());
}



TypeConstructor FixedMRegionTC(
FixedMRegion::BasicType(),
FixedMRegionProperty,
OutFixedMRegion, InFixedMRegion,
0, 0, //deprecated, don’t think about it
CreateFixedMRegion, DeleteFixedMRegion,
OpenFixedMRegion, SaveFixedMRegion,
CloseFixedMRegion, CloneFixedMRegion,
CastFixedMRegion,
SizeOfFixedMRegion,
FixedMRegionTypeCheck);


class PSTAlgebra : public Algebra 
{
  public:
    FixedMRegion() : Algebra() {
      AddTypeConstructor( &FixedMRegionTC );
      FixedMRegionTC.AssociateKind( Kind::DATA() );
      
      AddOperator(&insideOp);
      AddOperator(&intersectionOp);
      AddOperator(&equalpstOp);
      AddOperator(&getbigpstsegmentlistOp);
      AddOperator(&testoperatoraOp);
    }
    ~FixedMRegion() {};
 };

extern "C"
Algebra*
InitializeFixedMRegion( NestedList* nlRef,
QueryProcessor* qpRef ) {
  return new FixedMRegion;
}
;
