\documentclass[a4paper]{article}
\usepackage[margin=2cm]{geometry}
\usepackage{hyperref}
\usepackage{cite}
\usepackage{amssymb}
\usepackage{url}
\usepackage{float}
\usepackage{longtable}
\usepackage{array}
\usepackage{algorithmic}
\usepackage[boxed]{algorithm}
\pagestyle{headings}
\newcommand{\secondo}{\textsc{Secondo}}
\newcommand{\bmodb} {BerlinMOD Benchmark}
\newcommand{\op}[1]{\textbf{#1}}
\newcommand{\var}[1]{\textsl{#1}}
\newcommand{\dt}[1]{\textsl{\underline{#1}}}
\newcommand{\file}[1]{\texttt{#1}}
\newcommand{\true}{\var{TRUE}}
\newcommand{\false}{\var{FALSE}}
\title{Implementation of Network Data Model in \secondo{}DBMS}
\author{Simone Jandt}
\date{Last Update: \today}
\begin{document}
\maketitle
\tableofcontents
\section{Introduction}
The network data model was first presented in \cite{1146465}. The network data model is restricted to represent objects which are constrained by a given network, e.g. cars on a street network. For this network constrained  objects the network data model delivers a complete system of data types and operations.

In the next sections we describe our implementation of the network data model in the extensible \secondo{} DBMS\cite{686903,1054151,secondoweb}. Parts of this network implementation have been done by one of our students as final thesis \cite{DAScheppokat}.

The central idea of the network data model is that movements are restricted to given networks. Cars use street networks and trains railway networks. It is natural for us to speech about the position of a place relative to the street network, instead of giving its absolute position in coordinates. In the network data model all positions are given relatively to the routes of the network. The temporal element is represented by a time sliced representation of the spatio-temporal elements.

The implementation of the network model in \secondo{} is splitted into two algebra modules. One containing the the spatial data types and operations (\file{NetworkAlgebra}), and one containing the spatio-temporal data types and operations (\file{TemporalNetAlgebra}). We describe first the implemented data types of both algebra modules in section \ref{sec:netdatatypes} and then the implemented operations on this data types in section \ref{sec:netoperations}.
\section{Implemented Data Types}
\label{sec:netdatatypes}
All data types we describe have a boolean parameter, telling if the object of the data type is well defined or not. 
\subsection{NetworkAlgebra}
The four implemented data types of the \file{NetworkAlgebra}-Module are: \dt{network}, \dt{gpoint}, \dt{gpoints}, and \dt{gline}.
\subsubsection{\dt{network}}
The data type \dt{network} is the central data type of the network data model. The network object contains all information's about the spatial structure of the (street) network. First of all there are three different relations (see tables \ref{tab:junctionsrel} - \ref{tab:sectionsrel}); one containing the routes data (streets), one the junctions data (crossings), and the least one the sections (street parts between two crossings or a crossing and the of the street) of the network. Furthermore the \dt{network} consists of four B-Trees, indexing the route identifiers of the routes, junctions, and sections relation. A spatial R-Tree, indexing the ROUTE\_CURVE attribute of the routes relation. A network identifier (\dt{int}). And two sets connecting section identifiers of sections which are adjacent\footnote{Two sections are adjacent if they are connected by a junction, and there exists a connection between the lanes of the two sections in the junction.}.
\begin{table}[H]
\begin{scriptsize}
\begin{tabular}{|l|c|p{9.5cm}|}
\hline
\textbf{Attribute} & \textbf{Data Type} & \textbf{Explanation} \\
\hline
JUNCTION\_ROUTE1\_ID & \dt{int} & Route identifier of the first\footnotemark route of the junction.\\
\hline
JUNCTION\_ROUTE1\_MEAS & \dt{real} & Length of the route part between the start of the route and the junction.\\
\hline
JUNCTION\_ROUTE2\_ID & \dt{int} & Route identifier of the second route of the junction.\\
\hline
JUNCTION\_ROUTE2\_MEAS & \dt{real} & Length of the route part between the start of the route and the junction.\\
\hline
JUNCTION\_CC & \dt{int} & The connectivity code\footnotemark tells us which transitions between the lanes of the streets exist in a junction.\\
\hline
JUNCTION\_POS &\dt{point} & Representing the spatial position of the junction in the 2D space.\\
\hline
JUNCTION\_ROUTE1\_RC &\dt{TupleIdenitfier}\footnotemark & Identifies the tuple of the first route of the junction in the routes relation.\\
\hline
JUNCTION\_ROUTE2\_RC &\dt{TupleIdenitfier} & Identifies the tuple of the second route of the junction in the routes relation.\\
\hline
JUNCTION\_SECTION\_AUP\_RC & \dt{TupleIdentifier} & Identifies the tuple of the section upwards of the junction on the first route in the sections relation. \\
\hline
JUNCTION\_SECTION\_ADOWN\_RC & \dt{TupleIdentifier} & Identifies the tuple of the section downwards of the junction on the first route in the sections relation. \\
\hline
JUNCTION\_SECTION\_BUP\_RC & \dt{TupleIdentifier} & Identifies the tuple of the section upwards of the junction on the second route in the sections relation. \\
\hline
JUNCTION\_SECTION\_BDOWN\_RC & \dt{TupleIdentifier} & Identifies the tuple of the section downwards of the junction on the second route in the sections relation. \\
\hline
\end{tabular}
\end{scriptsize}
\caption{The junctions relation of \dt{network}}
\label{tab:junctionsrel}
\end{table}
\addtocounter{footnote}{-2}
\footnotetext{The first route identifier of a junction will always be the lower route identifier of the two  routes which cross in the junction.}
\stepcounter{footnote}
\footnotetext{See \cite{1146465} for detailed information about the meaning of the different connectivity code values.}
\stepcounter{footnote}
\footnotetext{\dt{TupleIdentifier} is a \secondo{} data type identifying tuples in other relations.}
\begin{table}[H]
\begin{scriptsize}
\begin{tabular}{|l|c|p{10.5cm}|}
\hline
\textbf{Attribute} & \textbf{Data Type} & \textbf{Explanation} \\
\hline
ROUTE\_ID & \dt{int} & Route Identifier.\\
\hline
ROUTE\_LENGTH &\dt{real} & Length of the route. \\
\hline
ROUTE\_CURVE & \dt{sline}\footnotemark & Spatial geometry data of the route. \\
\hline
ROUTE\_DUAL & \dt{bool} & \true{} means that the both lanes of the street are separated.\\
\hline
ROUTE\_STARTSSMALLER & \dt{bool} & \true{} means the route starts at the lexicographical smaller endpoint\\
\hline
\end{tabular}
\end{scriptsize}
\caption{The routes relation of the data type \dt{network}}
\label{tab:routesrel}
\end{table}
\footnotetext{\dt{sline} is a set of half segments representing the curve of the route in the 2D plane.}
\begin{table}[h]
\begin{scriptsize}
\begin{tabular}{|l|c|p{9cm}|}
\hline
\textbf{Attribute} & \textbf{Data Type} & \textbf{Explanation} \\
\hline
SECTION\_RID&\dt{int}& Route identifier of the route the section belongs to. \\
\hline
SECTION\_MEAS1&\dt{real}& Length of the route part before the section start point from the begin of the route.\\
\hline
SECTION\_MEAS2&\dt{real}& Length of the route part before the section end point from the begin of the route.\\
\hline
SECTION\_DUAL&\dt{bool}& \true{} means that the both lanes of the section are separated.\\
\hline
SECTION\_CURVE&\dt{sline}& Spatial geometry of the section in the plane.\\
\hline
SECTION\_CURVE\_STARTS\_SMALLER&\dt{bool}&\\
\hline
SECTION\_RRC&\dt{TupleIdentifier}& Identifies the tuple of the route the section belongs to in the routes relation.\\
\hline
\end{tabular}
\end{scriptsize}
\caption{The sections relation of the data type \dt{network}}
\label{tab:sectionsrel}
\end{table}
\subsubsection {\dt{gpoint}}
A \dt{gpoint} describes a single position in the network. It consists of the network identifier (\dt{int}), the route identifier (\dt{int}), the position (\dt{real}), which is given by the length of the route part between the start of the route and the position, and a parameter side(\dt{side}). \dt{Side} has three possible values (Down, Up, None). Up(Down) means a position can only be reached from the up(down) side of a route. None means a position can be reached from both sides of the route. For example motorway service areas on German Highways can only be reached from one side of the highway.
\subsubsection{\dt{gpoints}}
\dt{gpoints} is a set of \dt{gpoint}. Implemented by Jianqiu Xu.
\subsubsection{\dt{gline}}
A \dt{gline} describes a part of the network. This part of the network might be a path between two \dt{gpoint} or a district of a town. The data type \dt{gline} consists of a network identifier (\dt{int}), a set of \dt{route intervals}, the length of the gline (\dt{real}), and a sorted flag (\dt{bool}). Every \dt{route interval} consists of a route identifier (\dt{int}), and two position values (\dt{real}). The positions are given by the distance of the position from the start of the route and represent the start and the end point of the \dt{route interval}\footnote{As you can see different from \cite{1146465} the \dt{side} value for \dt{route intervals} is not implemented yet.}.

The computation time of many algorithms on \dt{gline} values can be reduced if the set of \dt{route intervals} fullfills the following conditions:\label{sec:sortedgline}
\begin{itemize}
\item All \var{route intervals} are disjoint.
\item The \var{route intervals} are sorted by ascending route identifiers.
\item If two \var{route intervals} have the same route identifier the \var{route interval} with the smaller start position is stored first.
\item All start positions are less or equal to the end positions.
\end{itemize}

Unfortunately not all \dt{gline}s can be stored with sorted route intervals. If we describe a district or the parts of the network traversed by an \dt{mgpoint} (See \ref{sec:mgpoint}) it is regardless in which sequence we read the single parts of the district or the traversed route parts and we can store the route intervals sorted. But if the \dt{gline} represents a path between two \dt{gpoint} \var{a} and \var{b} the \dt{route intervals} must be stored exactly in the sequence they are used in the path. And this sequence will nearly never be a sorted sequence of route intervals. So we introduced a \dt{bool} sorted flag and whenever a \dt{gline} can be stored sorted we do so and set the sorted flag to \true{}. Algorithms which can take profit from sorted route intervals check the sorted flag and perform a binary scan for sorted and a linear scan for unsorted \dt{gline}s to find the route interval containing a given route identifier and / or position. The computation time is reduced from O(\var{r}) for unsorted to O($\log \var{r}$) for sorted \dt{gline} if \var{r} is the number of route intervals of the \dt{gline}.

We pay for the advantage of sorted \dt{gline} by the time complexity of algorithms which produce sorted \dt{gline}s, because sorting and compressing \dt{route intervals} takes time. But we think, that this time is well invested. Compressing and sorting a \dt{gline} is done once. But the sorted \dt{gline} can be used many times by other algorithms.
\subsection{TemporalNetAlgebra}
In the moment only the temporal version of the \dt{gpoint} the so called \dt{mgpoint} (short form from \dt{moving}(\dt{gpoint})) is implemented in the \file{TemporalNetAlgebra}. This includes the implementation of the \dt{unit}(\dt{gpoint}) (short \dt{ugpoint}) and the \dt{intime}(\dt{gpoint}) (short \dt{igpoint}). As explained in the following subsections.

Recently the \file{TemporalNetAlgebra} has been extended by a new data type \dt{mgpsecunit} and operations \op{mgpsecunits} to create \dt{stream}s of this data type from \dt{mgpoint} values. The new data type should be used in the context of traffic estimation.
\subsubsection{\dt{mgpoint}}
\label{sec:mgpoint}
The main parameter of a \dt{mgpoint} is a set of \dt{ugpoint}s (see \ref{sec:ugpoint}) with disjoint time intervals. The time intervals of the \dt{ugpoint}s must be disjoint, because nothing can be at two different places at the same time. The \dt{ugpoint}s are stored in the \dt{mgpoint} sorted by ascending time intervals. This allows us to perform a binary scan on the units of the \dt{mgpoint} to find a given time instant within the definition time of the \dt{mgpoint}. We can compute the approximated position of the \dt{mgpoint} in the network at every time instant within the definition time and return it as \dt{igpoint} (see \ref{sec:igpoint}), because every time the car changes the route or the speed a new unit is written to the \dt{mgpoint}.

In our experiments we extended the \dt{mgpoint} from \cite{1146465} with some additional parameters:
\begin{itemize}
\item length (\dt{real}). The length parameter stores the distance driven by the \dt{mgpoint}.
\item trajectory (sorted set of \dt{route intervals})\footnote{The \secondo{}DBMS doesn't allow us to use a \dt{gline} as parameter of the \dt{mgpoint}. So we used this work around for the implementation.}. Represents all the places ever traversed by the \dt{mgpoint}.
\item trajectory\_defined (\dt{bool}) \true{} if the trajectory parameter is well defined.
\item bbox (\dt{rect3} 3-dimensional rectangle) Representing the spatio-temporal bounding box of the \dt{mgpoint}.
\end{itemize}

The time used to decide if a \dt{mgpoint} ever passed a given place (\dt{gpoint} or \dt{gline}) or not is reduced by the trajectory parameter. Instead of linear checking all \var{m} units of the \dt{mgpoint} we can perform a binary scan on the much lower number \var{r} of route intervals in the trajectory parameter. So the time complexity is reduced from O(\var{m}) to O($\log \var{r}$) with $\var{r} \ll \var{m}$. The trajectory parameter is not maintenanced by every operation. So the boolean flag trajectory\_defined was introduced to tell us if the trajectory parameter is actually well defined and usable or if it has to be recomputed first.

In the network data model all spatial information is only stored in the network. Therefore it is very expensive to get spatial information's especially for \dt{mgpoint}s. Although the \dt{mgpoint} stays on the same route in every unit the \dt{mgpoint} may move in different spatial directions within a single unit. For example a car may drive downhill in serpentine. In this case it is not enough to translate only the spatial position of the start and end \dt{gpoint} of the unit to compute the spatial part of the bounding box. The complete route part passed in this unit must be inherited in the computation of the spatial part of the bounding box. That makes the computation of the bounding box of the \dt{mgpoint} which is the union of all the \dt{ugpoint} bounding boxes very expensive. We introduced the bbox parameter to save our computation work if we have done it once. The bbox value is not maintenanced at every change of the \dt{mgpoint} and it is only computed on demand using the trajectory of the \dt{mgpoint} or stored if we could get it for free. For example if we translate a \dt{mpoint} into a \dt{mgpoint} we can copy the bounding box of the \dt{mpoint} for our new \dt{mgpoint} bbox without computational effort.
\subsubsection{\dt{ugpoint}}
\label{sec:ugpoint}
The \dt{ugpoint} consists of a time interval, a start, and a end \dt{gpoint}, whereby both \dt{gpoint} have the same network and route identifiers.

The time interval consists of a starting time instant, a end time instant, and two boolean flags one for each of the both time instants. The boolean flags indicate if the starting (ending) time instant is part of the interval or not.

With help of this parameters we could compute the exact position of the \dt{ugpoint} at each time instant within the time interval. And, assumed the \dt{ugpoint} reaches the query \dt{gpoint} within the time interval, we can compute the time instant when a \dt{ugpoint} reaches a given \dt{gpoint}.
\subsubsection{\dt{igpoint}}
\label{sec:igpoint}
The \dt{igpoint} consists of a time instant and a \dt{gpoint} representing the position of the \dt{mgpoint} in the \dt{network} at the given time instant.
\subsubsection{\dt{mgpsecunit}}
The data type \dt{mgpsecunit} (see \ref{tab:mgpsecunit}) was introduced in November 2009 to support better traffic estimation. It reduces the complex information's given in a \dt{mgpoint} to the values which are useful for traffic estimation. Possibly this reduced information can be used to build a spatio-temporal index over \dt{mgpoint} values in a later \secondo{} version.
\begin{table}[H]
  \label{tab:mgpsecunit}
  \begin{tabular}{|l|l|p{11.5cm}|}
    \hline
    \var{secId} & \dt{int} & Section identifier for a network section\\
    \hline
    \var{partNo} & \dt{int} & Partition number on this section\footnotemark.\\
    \hline
    \var{direct} & \dt{int} & moving direction of the \dt{mgpoint} within this section part. (0 = Down, 1 = Up)\\
    \hline
    \var{avgSpeed} & \dt{real} & average speed of the \dt{mgpoint} within this section part\\
    \hline
    \var{time} & \dt{Interval<Instant>} & time interval the \dt{mgpoint} moved within this section\\
    \hline
  \end{tabular}
  \caption{Description of data type \dt{mgpsecunit}}
\end{table}
\footnotetext{The operation \op{mgpsecunits} (see \ref{sec:opmgpsecunits}) which construct the \dt{mgpsecunit}s has a parameter which gives a maximum section length. Sections which are longer than this value will be divided up into several parts of this length. The partitioning starts at the smaller point of the section and the first part has the number 1. The length of the last part might be shorter than the given length value.}
\section{Implemented Operations}
\label{sec:netoperations}
In the next subsections we describe the implemented operations of the network data model. For every operator we present its signature, a example call and information's about the used algorithms and the time complexity if they might be interesting.
\subsection{Network Constructor}
\begin{tabbing}
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\=xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\kill
\dt{int} $\times$ \dt{relation} $\times$ \dt{relation} $\rightarrow$ \dt{network} \>
\op{thenetwork}(\var{n}, \var{routes}, \var{junctions})\\
\end{tabbing}
The operator \op{thenetwork} is the construction operator which builds the \dt{network} object with the given identifier \var{n} or the next free identifier bigger than \var{n} from the data of the two given relations. One relation containing the streets (\var{routes}) and one the crossings (\var{junctions}) data of the (street) network. The two relations should contain the following attributes: 
\begin{itemize}
   \item \var{routes}: route identifier (\dt{int}), length of the route (\dt{real}), geometry of the route curve (\dt{sline}), dual and startssmaller (both \dt{bool})
   \item \var{junctions}: first route identifier (\dt{int}), position on first route (\dt{real}), second route identifier (\dt{int}), position on the second route (\dt{real}), and the connectivity code (\dt{int})
\end{itemize}
The operator \op{thenetwork} creates first an empty network object with the given network id \var{n}. The the tuples of \var{routes} are copied to the routes relation of the new network object and the B-Tree, indexing the route id entries of the routes relation and the R-Tree, indexing the geometry of the route curve attribute of the routes relation are created. Then every tuple of \var{junctions} is copied to the junctions relation of the network object and the \dt{TupleIdentifier}s of the both routes connected by a junction in the routes relation are stored at every junction of the junctions relation. The two B-Trees indexing the route identifiers of the first / second route in the junctions relation are created. After that for each junction of every route in the network routes relation: Compute the up and down section of the route, store it in the sections relation and store their \dt{TupleIdentifier} in the junctions relation. Create the B-Tree indexing the route identifiers of the sections relation. For every junction of the junctions relation we check the connectivity code and build adjacent section pairs and fill the corresponding \dt{TupleIdentifier}s in the adjacency lists.

If \var{r} is the number of routes and \var{j} is the number of junctions. The steps of the algorithm will take:
\begin{itemize}
\item O($\var{r} + \var{r} \log \var{r}$) time to fill the routes relation of the resulting network and build the routes relation B-Tree.
\item O($\var{j} + \var{j} \log \var{j}$) to fill the junctions relation of the resulting network and build the two junctions relation B-Trees.
\item O(\var{rj}) to fill the sections relation of the resulting network.
\item O(\var{j}) to fill adjacency lists of the resulting network.
\end{itemize}
For the complete algorithm we get a time complexity of:
O($\var{r} + \var{r} \log \var{r} + \var{j} + \var{j} \log \var{j} +\var{rj}+\var{j}$) =
O($\var{rj} + \var{r} \log \var{r} + \var{j} \log \var{j}$)
\subsection{Translation from 2D Space into Network Data Model}
The next operations are used to translate spatial and spatio-temporal data from the 2D plane data model \cite{594784,335426,352963} of the \secondo{}DBMS into the network data model representation. In \cite{1146465} this operations are all called \op{in\_network} with different signatures. All translations will only be successful if the 2D space data is aligned to the given network otherwise the network representation of the 2D object is not defined.
\begin{tabbing}
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\=xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\kill
\dt{network} $\times$ \dt{point} $\rightarrow$ \dt{gpoint} \> \op{point2gpoint}(\var{network}, \var{point})\\
\dt{network} $\times$ \dt{line} $\rightarrow$ \dt{gline} \> \op{line2gline}(\var{network},\var{line})\\
\dt{network} $\times$ \dt{mpoint} $\rightarrow$ \dt{mgpoint} \> \op{mpoint2mgpoint}(\var{network}, \var{mpoint})\\
\end{tabbing}
\subsubsection{\op{point2gpoint}}
The operation \op{point2gpoint} translates a \dt{point} value into a \dt{gpoint} value of the given network if possible. The algorithm uses the R-Tree of the routes relation to select the route closest connected to the point. And computes the position of the point on this route. If \var{r} is the number of routes in the routes relation and \var{k} is the number of possible candidate routes the worst case complexity of the algorithm is O($\var{k} + \log \var{r}$).
\subsubsection{\op{line2gline}}
The operation \dt{line2gline} translates a \dt{line} value into a sorted \dt{gline} value. The algorithm takes every half segment of the \dt{line} value and tries to find the start and end of the half segment on the same route using a variant of \op{point2gpoint}. The computed route intervals are sorted, merged and compressed with help of an \dt{RITree}\label{sec:ritree}\footnote{The RITree is a binary search tree for \dt{route intervals}. It is implemented in the NetworkAlgebra of \secondo{}to sort and compress \dt{route intervals} in O($\var{r} \log \var{k}$)  time, if \var{r} is the number of inserted \dt{route interval} values and \var{k} is the number of resulting \dt{route interval} values.} before the resulting \dt{gline} is returned.

The time complexity of the algorithm is O($\var{h}$O(\op{point2gpoint})$ + \var{h} \log \var{r}$), if \var{h} is the number of half segments of the \dt{line} value and \var{r} ($\var{r} \le \var{h}$) is the number of resulting \dt{route intervals}. The summand O($\var{h} \log \var{r}$) is caused by merging and sorting the \dt{route intervals} with the RITree. As mentioned before (see \ref{sec:sortedgline}) we think that the advantages of a sorted \dt{gline} compensate the additional computation time invested at this point.
\subsubsection{\op{mpoint2mgpoint}}
The operation \op{mpoint2mgpoint} translates a \dt{mpoint} value which is constrained by the network into a \dt{mgpoint} value. The algorithm uses \op{point2gpoint} to find start and end position of the first \var{mpoint} unit in the \var{network} on the same route and notices  the network values of this data for the actual \var{ugpoint} of the resulting \var{mgpoint}. For every following unit of the \var{mpoint} the algorithm first tries to find the end point of the upoint on the actual route. If this is successful it is checked if the \var{mpoint} changed the speed or the direction. If the speed and direction don't change the actual \var{ugpoint} is extended to include the current \var{upoint} value. If the speed or direction changed the actual \var{ugpoint} is written to the result and a new actual \var{ugpoint} is started with the network data of the actual \var{upoint}. If the end point of the \var{upoint} was not found on the same route. The actual \var{ugpoint} is written to the resulting \var{mgpoint} and we try to find the new route used by the \var{upoint} within the adjacent routes of the last known network position. If the network position is detected a new actual \var{ugpoint} is initialized with the network values of the \var{upoint}. At least we write the last actual \var{ugpoint} to the resulting \var{mgpoint} and return the result.

The time complexity to find the start position is O(\op{point2gpoint}). For the next \var{m} units the complexity in the worst case is O(\var{n}) for each unit if \var{n} is the maximum number of adjacent sections. We get a worst time complexity of O(O(\op{point2gpoint}) + \var{mn}) for the translation of an \dt{mpoint} into an \dt{mgpoint}.
\subsection{Translation from Network Data Model into 2D Space}
\label{sec:translops}
\begin{tabbing}
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\=xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\kill
\dt{gpoint} $\rightarrow$ \dt{point} \> \op{gpoint2point}(\var{gpoint}) \\
\dt{gline} $\rightarrow$ \dt{line} \> \op{gline2line}(\var{gline}) \\
\dt{mgpoint} $\rightarrow$ \dt{mpoint} \> \op{mgpoint2mpoint}(\var{mgpoint})\\
\end{tabbing}
In \cite{1146465} this operations are called \op{in\_space}. The translation from network constrained data type into free 2D space data types is always possible.
\subsubsection{\op{gpoint2point}}
The operation \dt{gpoint2point} translates a \dt{gpoint} value into a \dt{point} value. 
The algorithm scans the B-Tree of the routes relation to get the route curve of the route the \var{gpoint} is connected to and then computes the spatial position of the \var{gpoint} on this route.

The time complexity depends on the number \var{r} of routes in the network and the number \var{h} of half segments of the route curve the \var{gpoint} belongs to. It takes O($\log \var{r}$) time to get the right route curve to the route identifier of the \var{gpoint}. And in the worst case O(\var{h}) time to compute the 2D space x,y-coordinate of the \var{gpoint} with help of the halfsegments of the route curve. Alltogether we get a worst case time complexity of O($\var{h} + \log \var{r}$).
\subsubsection{\op{gline2line}}
The operation \op{gline2line} translates a \dt{gline} value into an spatial \dt{line} value. The algorithm uses the B-Tree index on the routes relation to get the corresponding route curve for every route interval of the \var{gline}. And computes the corresponding half segments which are put in the resulting \var{line}.

Let \var{m} be the number of route intervals of the \var{gline}, and \var{r} the number of routes in the network, and \var{h} the maximum number of half segments of a \dt{line} value for a route interval. For each route interval we need O($\log \var{r}$) time to get the route curve and O(\var{h}) time to get the half segments of the route interval. The time complexity of the whole operation is O($\var{m}(\var{h} + \log \var{r})$)
\subsubsection{\op{mgpoint2mpoint}}
The operation \op{mgpoint2mpoint} translates a \dt{mgpoint} value into a corresponding \dt{mpoint} value. It is not enough to compute only the \dt{point} values for the start and end \dt{gpoint} of every unit because if a \dt{ugpoint} passes different half segments of the route curve it must be divided up into different \dt{upoint}. Because at every new halfsegment it changes the moving direction and this must be saved in the \dt{mpoint}.

The algorithm gets the first \dt{ugpoint} of \var{mgpoint} and uses the BTree index of the routes relation to get the tuple with the \dt{ugpoint}s route curve. Find the first \dt{gpoint} of the \dt{ugpoint} on the route curve. For every \dt{ugpoint} of \var{mgpoint} check if the route identifier of actual route is equal to the route identifier of \dt{ugpoint}. If this is not the case use the BTree index of the routes relation of the \dt{network} to get the tuple with the \dt{ugpoint}s route curve. If the end position of the \dt{ugpoint} is on the same half segment of the route curve than the start position compute \dt{point} for end \dt{gpoint} and write unit to \dt{mpoint} and continue with the next unit of the \var{mgpoint}. If the end position of the \dt{ugpoint} is not on the same half segment of the route curve and the \dt{ugpoint} is moving up(down) compute the time instant the \dt{ugpoint} reaches the end(start) position of the actual half segment. Write the \dt{upoint} to the resulting \dt{mpoint}. Get next half segment of the route curve in up(down) direction repeat the last computation until the half segment containing the end point of the \dt{ugpoint} is reached.

Let \var{r} be the number of routes in the routes relation, and \var{m} the number of units of the \var{mgpoint}, and \var{h} the maximum number of half segments of a route curve. The worst case time complexity of the algorithm is O($\var{m}(\var{h} + \log\var{r})$).
\subsection{Extract Attributes}
\label{sec:lengthgline}
The operators of table \ref{tab:simpleop} return the attributes from the different data types in O(1) time.
\begin{table}[H]
\begin{scriptsize}
\begin{tabular}{|l|l|p{10cm}|}
\hline
\textbf{Operator}&\textbf{Signature}&\textbf{Explanation}\\
\hline
\op{routes}&\dt{network}$ \rightarrow$ \var{routes relation}& Returns the routes relation of the \var{network}\\
\hline
\op{junctions}&\dt{network} $\rightarrow$  \var{junctions relation}& Returns the junctions relation of the \var{network}\\
\hline
\op{sections}&\dt{network} $\rightarrow$ \var{sections relation}& Returns the sections relation of the \var{network}\\
\hline
\op{no\_components}&\dt{gline} $\rightarrow$ \dt{int}& Returns the number of \dt{route intervals} respectively units of the first argument.\\
&\dt{mgpoint} $\rightarrow$ \dt{int}& \\
\hline
\op{isempty}&\dt{gline} $\rightarrow$ \dt{bool}& Returns \true{} if the first argument \var{X} is not defined or \op{no\_components}(\var{X}) = 0.\\
&\dt{mgpoint} $\rightarrow$ \dt{bool}&  \\
\hline
\op{length}&\dt{gline} $\rightarrow$ \dt{real}& Returns the length of the \var{gline} or the driven distance of the \var{mgpoint}\\
&\dt{mgpoint} $\rightarrow$ \dt{real} & \\
\hline
\op{initial}&\dt{mgpoint}$\rightarrow$\dt{igpoint}& Returns the first position and start time of the \var{mgpoint}.\\
\hline
\op{final}&\dt{mgpoint}$\rightarrow$\dt{igpoint}& Returns the last position and end time of the \var{mgpoint}.\\
\hline
\op{unitrid}&\dt{ugpoint} $\rightarrow$ \dt{real}& Returns the route identifier of the \var{ugpoint}.\\
\hline
\op{unitstartpos}&\dt{ugpoint} $\rightarrow$ \dt{real} & Returns the start position of the \var{ugpoint}.\\
\hline
\op{unitendpos}&\dt{ugpoint} $\rightarrow$ \dt{real}& Returns the end position of the \var{ugpoint}.\\
\hline
\op{unitstarttime}&\dt{ugpoint} $\rightarrow$ \dt{real}& Returns the start time instant of the \var{ugpoint} as \dt{real} value.\\
\hline
\op{unitendtime}&\dt{ugpoint} $\rightarrow$ \dt{real} & Returns the end time instant on the \var{ugpoint} as \dt{real} value.\\
\hline
\op{startunitinst}&\dt{ugpoint} $\rightarrow$ \dt{instant}& Returns the start time instant of the \var{ugpoint}.\\
\hline
\op{endunitinst}&\dt{ugpoint} $\rightarrow$ \dt{real} & Returns the end time instant on the \var{ugpoint}.\\
\hline
\op{val}&\dt{igpoint} $\rightarrow$ \dt{gpoint} & Returns the \dt{gpoint} of the \var{igpoint} \\
\hline
\op{inst}&\dt{igpoint} $\rightarrow$ \dt{instant}& Returns the time instant of the \var{igpoint}\\
\hline
\end{tabular}
\end{scriptsize}
\caption{Operators returning simple attributes}
\label{tab:simpleop}
\end{table}
The following operators return the more complex attributes of the network data types.
\begin{tabbing}
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\=xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\kill
\dt{mgpoint} $\rightarrow$ \dt{gline} \> \op{trajectory}(\var{mgpoint})\\
\dt{mgpoint} $\rightarrow$ \dt{periods} \> \op{deftime}(\var{mgpoint})\\
\dt{ugpoint} $\rightarrow$ \dt{periods} \> \op{deftime}(\var{ugpoint})\\
\dt{mgpoint} $\rightarrow$ \dt{stream}(\dt{ugpoint}) \> \op{units}(\var{mgpoint})\\
\end{tabbing}
\subsubsection{\op{trajectory}}
The operation \op{trajectory} returns a sorted \dt{gline} value representing all the places traversed by the \var{mgpoint}. If the trajectory parameter is defined the route intervals are returned as a \dt{gline} value immediately. Otherwise the trajectory parameter is computed by a linear scan of the units of the \var{mgpoint}. In the last case the route intervals are sorted, merged and compressed with help of a RITree (see \ref{sec:ritree}).

If the trajectory is defined and \var{r} is the number of route intervals of the trajectory the time complexity is O(\var{r}). Otherwise the time complexity is O($\var{m} + \var{m} \log \var{r}$), if \var{m} is the number of units of the \var{mgpoint}. The last time complexity value could be reduced to O(\var{m}) if we store the computed route intervals immediately to the resulting \dt{gline} value without sorting and compressing. But as mentioned in \ref{sec:sortedgline} we think that the overhead in computation time for sorting and compressing is  well invested.
\subsubsection{\op{deftime}}
The operation \op{deftime} is defined for \dt{mgpoint} and \dt{ugpoint}. It returns the \dt{periods} representing the definition times of the the \var{mgpoint} respectively the \var{ugpoint}.

This takes O(1) time for \dt{ugpoint} value and O(\var{m}) time for a \dt{mgpoint} value with \var{m} units, because every unit of the \var{mgpoint} must be read to merge the definition times.
\subsubsection{\op{units}}
The operation \op{units} returns the \var{m} units of a \dt{mgpoint} value as \dt{stream} of \dt{ugpoint} in O(\var{m}) time.
\subsection{Bounding Boxes}
We know two different types of bounding boxes in the network data model. On the one hand spatio-temporal bounding boxes analogous to the \bmodb{} data model. And on the other hand network bounding boxes where route identifiers and positions become coordinates so that R-Trees can be abused to index non spatial network data.
\subsubsection{Spatio-Temporal Bounding Boxes}
\begin{tabbing}
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\=xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\kill
\dt{ugpoint} $\rightarrow$ \dt{rect3} \> \op{unitboundingbox}(\var{ugpoint})\\
\dt{mgpoint} $\rightarrow$ \dt{rect3} \> \op{mgpbbox}(\var{mgpoint})\\
\end{tabbing}
The operations return the spatio-temporal bounding boxes of \var{ugpoint} respectively \var{mgpoint} as three dimensional rectangle with coordinates $x_1, x_2, y_1, y_2, z_1$ and $z_2$ of data type \dt{real}.
\paragraph{\op{unitboundingbox}}
The spatial part of the unitbounding box (x-,y-coordinates) is defined as the spatial bounding box of the \dt{route interval} covered by the \var{ugpoint}. And the temporal part (z-coordinates) of the unitbounding box is given by the \dt{real} values representing the start and the end time instant of the time interval of the \dt{ugpoint}.  In detail the coordinates of the resulting rectangle are defined as follows:
\begin{itemize}
\item $x_1 =  \min(x-$coordinate of the bounding box of the \dt{route interval})
\item $x_2 =  \max(x-$coordinate of the bounding box of the \dt{route interval})
\item $y_1 =  \min(y-$coordinate of the bounding box of the \dt{route interval})
\item $y_2 =  \max(y-$coordinate of the bounding box of the \dt{route interval})
\item $z_1 = $start time instant as \dt{real}
\item $z_2 = $end time instant as \dt{real}
\end{itemize}
The computation takes O(\var{h}) time, if \var{h} is the number of halfsegments passed within the \dt{ugpoint}.
\paragraph{\op{mgpbbox}}
The spatial-temporal bounding box of the \var{mgpoint} is defined as the union of the bounding boxes of the units of the \var{mgpoint}. The computation would take a very long time if we use this definition for computation, because a \var{mgpoint} has many units. Therefore we introduced the parameter bbox to store a once computed spatio-temporal bounding box. Otherwise we use the trajectory parameter of the \var{mgpoint} to get the same result in much less time.

The algorithm first checks if the bounding box parameter is defined. If this is the case the bounding box is returned immediately in O(1) time. If the bounding box is not defined we distinguish between two cases:
\begin{enumerate}
\item If the trajectory is not defined we first compute the trajectory. And then use the trajectory as it has been defined before.
\item If the trajectory is defined we compute the union of the bounding boxes of the route intervals of the trajectory and extend the resulting two dimensional rectangle to a three dimensional rectangle computing the \dt{real} values of the start and the end time instant of the \var{mgpoint}.
\end{enumerate}
Let \var{r} be the number of \dt{route intervals} of the \var{mgpoint}, \var{m} the number of units of the \var{mgpoint}, and \var{h} the maximum number of half segments covered by a route interval. The algorithm needs  O($\var{r}\var{h}$) time in case 2 and O($ \var{r}\var{h}+\var{m} \log \var{r}$) time in case 1.
\subsubsection{Network Bounding Boxes}
The following operators return network bounding boxes respectively \dt{streams} of network bounding boxes.
\begin{tabbing}
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\=xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\kill
\dt{gpoint} $\rightarrow$ \dt{rect} \> \op{gpoint2rect}(\var{gpoint}) \\
\dt{gline} $\rightarrow$ \dt{stream}(\dt{rect}) \> \op{routeintervals}(\var{gline})\\
\dt{ugpoint} $\rightarrow$ \dt{rect3} \> \op{unitbox}(\var{ugpoint})\\
\dt{ugpoint} $\rightarrow$ \dt{rect} \> \op{unitbox2d}(\var{ugpoint})\\
\end{tabbing}
All network bounding boxes are two (network) respectively three (network-temporal) dimensional rectangles with coordinates ($x_1, x_2, y_1, y_2$) respectively ($x_1, x_2, y_1, y_2, z_1, z_2$). For network bounding boxes the both x-coordinates are always identically and defined by the route identifier of the object. The z-coordinates are defined as \dt{real} value representing the start ($z_1$) respectively end time ($z_2$) of the time interval of the \dt{ugpoint}.
\paragraph{\op{gpoint2rect}}
The operator \op{gpoint2rect} computes the network box of a \dt{gpoint} value in O(1) time. The y-coordinates are defined as $y_1 = position - 0.000001$ respectively $y_2 = position + 0.000001$. The small \dt{real} value is used to avoid problems with the computational inaccuracy of \dt{real} values.
\paragraph{\op{routeintervals}}
The operation \op{routeintervals} returns a stream of two network boxes, one for each route interval of the \var{gline}. The  y-coordinates are defined:  $y_1 = \min($start position, end position) and  $y_2 = \max($start position, end position).

The operation needs O(\var{r}) time if \var{r} is the number of route intervals of the  \var{gline}.
\paragraph{\op{unitbox2d}}
Returns a two dimensional rectangle for the \var{ugpoint} in O(1) time. The y-coordinates are given by $y_1 = \min($start position, end position) and $y_2 = \max($start position, end position).
\paragraph{\op{unitbox}}
Returns a three dimensional rectangle for the \var{ugpoint} in O(1) time. It extends the two dimensional rectangle of unitbox2d with z-coordinates defined by the \dt{real} values of the time instants of the \var{ugpoint}.
\subsection{Boolean Operations}
Boolean operations check if the arguments hold special characteristics or conditions and return \true{} if this is the case, \false{} elsewhere. A special case is the operation \op{inside} for \dt{mgpoint} because the argument and the returned value are \dt{moving} objects.
\begin{tabbing}
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\=xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\kill
\dt{gpoint} $\times$ \dt{gpoint} $\rightarrow$ \dt{bool} \> \var{gpoint1} \op{=} \var{gpoint2} \\
\dt{gline} $\times$ \dt{gline} $\rightarrow$ \dt{bool} \> \var{gline1} \op{=} \var{gline2} \\
\dt{gline} $\times$ \dt{gline} $\rightarrow$ \dt{bool} \> \op{intersects}(\var{gline1}, \var{gline2})\\
\dt{mgpoint} $\times$ \dt{gpoint} $\rightarrow$ \dt{bool} \> \var{mgpoint} \op{passes} \var{gpoint}\\
\dt{mgpoint} $\times$ \dt{gline} $\rightarrow$ \dt{bool} \> \var{mgpoint} \op{passes}\var{gline}\\
\dt{gpoint} $\times$ \dt{gline} $\rightarrow$ \dt{bool} \> \var{gpoint} \op{inside} \var{gline}\\
\dt{mgpoint} $\times$ \dt{gline} $\rightarrow$ \dt{mbool} \> \var{mgpoint} \op{inside} \var{gline}\\
\dt{mgpoint} $\times$ \dt{instant} $\rightarrow$ \dt{bool} \> \var{mgpoint} \op{present} \var{instant}\\
\dt{mgpoint} $\times$ \dt{periods} $\rightarrow$ \dt{bool} \> \var{mgpoint} \op{present} \var{periods}\\
\end{tabbing}
\subsubsection{\op{=}}
The operator \op{=} compares the parameters of the arguments and returns \true{} if they are equal, \false{} elsewhere. For two \dt{gpoint}s this can be done in O(1) time. For two \dt{gline} we have to compare all \var{r} \dt{route intervals} of the both \dt{gline} this will take O(\var{r}) time. But the computation will stop immediately if a difference between the two \dt{gline} is detected and \false{} returned.
\subsubsection{\op{intersects}}
The algorithm checks if there is a pair of \dt{route intervals} (one from \var{gline1} and one from \var{gline2}) that intersects. Because sorted \dt{gline} can reduce computation time the algorithm knows three cases:
\begin{enumerate}
\item If Both \var{gline}s are sorted, a parallel scan through the route intervals of both \dt{gline} is performed.
\item If only one \dt{gline} is sorted, a linear scan of the unsorted \var{gline} is performed. For each route interval of the unsorted \var{gline} a binary search for a overlapping route interval is performed on the sorted \var{gline}.
\item If both \var{gline} are not sorted, a linear scan of the first \var{gline} is performed. And for every route interval a linear scan for overlapping route intervals is performed on the second \var{gline}.
\end{enumerate}
In all three cases \true{} is returned and computation stops immediately if a intersecting pair of \dt{route intervals} has been detected.

If \var{r} is the number of \dt{route intervals} of \var{gline1} and \var{s} for \var{gline2}. We get the following time complexities for the three cases:
\begin{enumerate}
\item O($\var{r}+\var{s}$)
\item O($\var{r} \log \var{s}$) respectively O($\var{s} \log \var{r}$), depending on which of the both \var{gline} is sorted.
\item O($\var{rs}$)
\end{enumerate}
\subsubsection{\op{passes}}
The operation \op{passes} checks if the \var{mgpoint} ever passes the given \var{gpoint} respectively \var{gline}. The algorithm uses the trajectory parameter of the \var{mgpoint}. If the trajectory is not defined the trajectory is computed first with help of \op{trajectory}(\var{mgpoint}). In this case we must add the time complexity of the operator \op{trajectory} to the time complexity of \op{passes}. In the following we assume that the trajectory is defined.
\paragraph{\dt{gpoint}}
A binary search of a route interval that contains the \var{gpoint} is performed on the trajectory parameter. This will take O($\log \var{r}$) time, if \var{r} is the number of route intervals in the trajectory parameter.
\paragraph{\dt{gline}}
The algorithm is divided up into two cases:
\begin{enumerate}
\item If the \var{gline} is sorted a parallel scan of the route intervals of the \var{gline} and the route intervals of the trajectory parameter is performed to find a intersecting pair of route intervals.
\item If the \var{gline} is not sorted a linear scan of the route intervals of the \var{gline} is performed. And for every route interval a binary search of a intersecting route interval is performed on the trajectory parameter.
\end{enumerate}
In both cases the computation is stopped immediately and \true{} returned if a intersecting \dt{route interval} has been found.

If \var{r} is the number of route intervals of the \var{mgpoint}, and \var{s} is the number of route intervals of the \var{gline} we get for case 1 a time complexity of O($\var{s}+\var{r}$) and for case 2 a time complexity of O($\var{s} \log \var{r}$)
\subsubsection{Inside}
The operation checks if the \var{gpoint} respectively \var{mgpoint} is inside the \var{gline}.
\paragraph{\dt{gpoint}}
In case of the \dt{gpoint} the algorithm knows two different cases:
\begin{enumerate}
\item If the \var{gline} is sorted a binary search for a route interval containing the \var{gpoint} is performed on the route intervals of the \var{gline}.
\item If the \var{gline} is not sorted a linear scan of the route intervals of the \var{gline} is performed to find a route interval containing the \var{gpoint}.
\end{enumerate}
If \var{r} is the number of \dt{route intervals} of the \var{gline} the time complexity will be O($\log \var{r}$) for a sorted \var{gline} and O(\var{r}) for a unsorted \var{gline}.
\paragraph{\dt{mgpoint}}
For a \dt{mgpoint} a \dt{mbool}\footnote{Short form of \dt{moving}(\dt{bool}). A \dt{mbool} changes its \dt{bool} value within time. See \cite{594784} for more details.} which is \true{} every time interval the \var{mgpoint} moves inside \var{gline} and \false{} elsewhere is returned. The algorithm checks for every unit of the \var{mgpoint} if there is any intersection with the route intervals of the \var{gline}. Based on this values the resulting \var{mbool} is computed. The search for intersecting route intervals is different for sorted and unsorted \var{gline}.
\begin{itemize}
\item If the \var{gline} is sorted a binary search on the route intervals is performed.
\item If the \var{gline} is not sorted a linear scan on the route intervals is performed.
\end{itemize}
Let \var{m} be the number of units of \var{mgpoint} and \var{r} the number of route intervals of the \var{gline}. The operation takes O($\var{m} \log \var{r}$) time if the \var{gline} is sorted. And O(\var{mr}) time if the \var{gline} is not sorted.
\subsubsection{\op{present}}
The operation checks the temporal attribute of the \var{mgpoint}.
\paragraph{\dt{instant}}
The algorithm performs a binary search on the units of the \var{mgpoint} if a corresponding \dt{ugpoint} is found \true{} is returned, \false{} elsewhere. This takes O($\log \var{m}$) time if \var{m} is the number of units of the mgpoint.
\paragraph{\dt{periods}}
The algorithm performs a parallel scan through the units of the \var{mgpoint} and the \var{periods} if a intersecting time interval is found \true{} is returned, \false{} elsewhere. The worst case time complexity is O($\var{m} + \var{n}$) if \var{m} is the number of units of the  \var{mgpoint} and \var{n} the number of temporal units of the \var{periods}.
\subsection{Merging Data Objects}
\begin{tabbing}
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\=xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\kill
\dt{gline} $\times$ \dt{gline} $\rightarrow$ \dt{gline} \> \var{gline1} \op{union} \var{gline2} \\
\dt{mgpoint} $\times$ \dt{mgpoint} $\rightarrow$ \dt{mgpoint} \> \var{mgpoint1} \op{union} \var{mgpoint2}\\
\end{tabbing}
If possible \op{union} merges the two argument objects into one result object of the same data type.
\subsubsection{\dt{gline}}
The operation returns a sorted \var{gline} which contains the union of the route intervals of the both \var{gline}. The algorithm knows two cases:
\begin{itemize}
	\item both \var{gline} are sorted.
	\item one or both \var{gline} are not sorted.
\end{itemize}
If both \var{gline} are sorted we perform a parallel scan through the route intervals and compare the actual route intervals of the both \var{gline}. If the route intervals don't intersect the smaller route interval is added to the resulting \var{gline} and the next route interval from the \var{gline} the added route interval was from is taken to continue the scan. If the both route intervals intersect a single route interval containing both route intervals is created and new route intervals from both \var{gline} are taken. If one or both new route intervals intersect with the merged route interval the merged route interval is extended to contain the intersecting route interval and the next route interval from the \var{gline} the last merged route interval was from is taken. We continue merging route intervals until there is no more route interval intersecting with the merged route intervals. The the merged route interval is stored to the result and we continue the scan until all route intervals of both \var{gline} have been added to the resulting sorted \dt{gline}.

If one or both \var{gline} are not sorted. All route intervals of both \var{gline} are filled into a \dt{RItree} to sort and compress them and the resulting sorted \var{gline} is returned.

Let \var{r} respectively \var{s} be the number of route intervals of the both \var{gline} and \var{k} the number of resulting route intervals. If both \var{gline} are sorted the time complexity is  O($\var{r}+\var{s}$) in all other cases we get a time complexity of O($(\var{r}+\var{s}) \log \var{k})$).

If we don't want to store the resulting \dt{gline} sorted we could simply add every route interval of the both \var{gline} into the new \dt{gline} in O($\var{r}+\var{s}$) time. But as mentioned before in \ref{sec:sortedgline} many algorithms take profit from sorted \dt{gline} values. We think that the additional time is well invested.
\subsubsection{\dt{mgpoint}}
The operation merges two \var{mgpoint} if the time intervals of all units of the both \var{mgpoint} are disjoint or the units with the same time intervals have identical values. 
The algorithm performs a parallel scan through the units of the both \var{mgpoint} and writes the units of the \var{mgpoint}s in ascending order of their time intervals to the resulting \var{mgpoint}. If there are overlapping time intervals the algorithm checks if the both \dt{ugpoint}s are identically. If the \dt{ugpoint}s are identically one of them is written to the result and the other one ignored. If the \dt{ugpoint}s are not identically the computation is stopped and the result is undefined.
This takes O($\var{m}+\var{n}$) if \var{m} respectively \var{n} is the number of units of the both \var{mgpoint}.
\subsection{Path Computing}
\label{sec:shortestpath}
\begin{tabbing}
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\=xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\kill
\dt{gpoint} $\times$ \dt{gpoint} $\rightarrow$ \dt{gline} \> \op{shortest\_path}(\var{gpoint1}, \var{gpoint2})
\end{tabbing}
The operation computes the shortest path in the network between \var{gpoint1} and \var{gpoint2} using Dijkstras Algorithm of shortest paths \cite{dijkstra}. In the worst case this takes O($\var{s} + \var{j} \log \var{j}$) time if \var{j} be the number of junctions and \var{s} be the number of sections in the network.
\subsection{Distance Computing}
There is a big difference between the Euclidean Distance and the Network Distance between between two places \var{a} and \var{b}. The Euclidean Distance is given by the length of the beeline between the two places regardless from existing paths in the network between the two locations. Contrary to this the Network Distance is given by the length of the shortest path between \var{a} and \var{b} in the network. According to this, and contrary to the Euclidean Distance, the Network Distance from \var{a} to \var{b} might be another than the Network Distance from \var{b} to \var{a}. Because there might be one way routes in the shortest path from \var{a} to \var{b}, which cannot be used in the shortest path from \var{b} to \var{a}.
\subsubsection{Euclidean Distances}
\begin{tabbing}
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\=xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\kill
\dt{gpoint} $\times$ \dt{gpoint} $\rightarrow$ \dt{real} \> \op{distance}(\var{gpoint1}, \var{gpoint2}) \\
\dt{gline} $\times$ \dt{gline} $\rightarrow$ \dt{real} \> \op{distance}(\var{gline1}, \var{gline2}) \\
\dt{mgpoint} $\times$ \dt{mgpoint}  $\rightarrow$  \dt{mreal}\footnotemark \> \op{distance}(\var{mgpoint1}, \var{mgpoint2})\\
\end{tabbing}
\
\footnotetext {We have \dt{moving} data types so the result is also a moving data type. See \cite{594784} for detailed explanation of \dt{mreal}.}
Although Euclidean Distances don't make much sense in a network environment we implemented the \op{distance} operation which computes the Euclidean Distance of two \dt{gpoint}, \dt{gline}, or \dt{mgpoint} for network objects for convenience. All following algorithms for Euclidean Distance computing do first a translation of the network data types into equivalent 2D data types using the operators of \ref{sec:translops} before they use the existing distance operation of this equivalent 2D data types to compute the Euclidean distance between the network objects. The time complexity is therefore always given by the sum of the translation time and the time for the distance computation. We get the following time complexities:
\begin{itemize}
\item \dt{gpoint}: O( O(\op{gpoint2point}) + O(\op{distance} (\dt{point}, \dt{point}))).
\item \dt{gline}: O( O(\op{gline2line}) + O(\op{distance}(\dt{line}, \dt{line})))
\item \dt{mgpoint}:  O( O(\op{mgpoint2mpoint}) + O(\op{distance} (\dt{mpoint}, \dt{mpoint})).
\end{itemize}
\subsubsection{Network Distances}
\begin{tabbing}
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\=xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\kill
\dt{gpoint} $\times$ \dt{gpoint} $\rightarrow$ \dt{real} \> \op{netdistance}(\var{gpoint1}, \var{gpoint2}) \\
\dt{gline} $\times$ \dt{gline} $\rightarrow$ \dt{real} \> \op{netdistance}(\var{gline1}, \var{gline2}) \\
\end{tabbing}
As mentioned before the Network Distance is given by the length of the shortest path between the arguments. In the simple case of two \var{gpoint} we use \op{length} (\op{shortest\_path} (\var{gpoint1}, \var{gpoint2})) and get a time complexity of O( O(\op{shortest\_path} + O( \op{length} (\dt{gline}))\footnote{See \ref{sec:shortestpath} for information about \op{shortest\_path} respectively \ref{sec:lengthgline} for information about \op{length}(\dt{gline})}.

If the arguments are \dt{gline}s we have to return the length of the minimum shortest path between a \var{gpoint} from \var{gline1} and a \var{gpoint} from \var{gline2}. The algorithm first computes the bounding gpoints\footnote{Bounding gpoints means at least a set of \dt{gpoint}s. Where each \dt{gpoint} of the set must be passed by everyone who wants to reach the inside of the \dt{gline} from the outside of the \dt{gline} and vice versa. This bounding gpoints are the interesting \dt{gpoint}s for Network Distance computing between two \dt{gline}, because every other place inside a \dt{gline} can only be reached by passing one of the bounding gpoints of the \dt{gline}.} for each of the both \var{gline}. Then we check for each possible pair of bounding gpoints one of \var{gline1} and one of \var{gline2}:
\begin{itemize}
\item If one of the both \dt{gpoint} is inside the other \var{gline}. If this is the case, the both \var{gline}s intersect. The Network Distance is 0.0 and computation is stopped immediately.
\item If the \var{gline}s do not intersect the distance of the both \dt{gpoint} is computed using \op{netdistance}(\dt{gpoint}, \dt{gpoint})
\end{itemize}
If the distances of all pairs of bounding gpoints has been computed the minimal computed distance value is returned.

Let \var{s} be the number of sections covered by the route intervals of \var{gline1} and \var{t} the number of sections covered by route intervals of \var{gline2}. The computation of the bounding gpoints of both \dt{gline}s will take O($\var{s}+\var{t}$) time. Let \var{i} respectively \var{j} be the number of bounding gpoints of the both \var{gline}. The Network Distance computation between this points will take O($\var{i}\var{j}$ O(\op{netdistance}(\dt{gpoint}, \dt{gpoint}))) time. We get a time complexity of O( $\var{n} +\var{m} + \var{i}\var{j}$ O(\op{netdistance}(\dt{gpoint}, \dt{gpoint}))) for the whole operation.
\subsection{Restricting and Reducing}
The following operations restrict a \dt{mgpoint} to given times or places or reduce the number of units of the \dt{mgpoint}.
\begin{tabbing}
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\=xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\kill
\dt{mgpoint} $\times$ \dt{instant} $\rightarrow$ \dt{igpoint} \> \var{mgpoint} \op{atinstant} \var{periods}\\
\dt{mgpoint} $\times$ \dt{periods} $\rightarrow$ \dt{mgpoint} \> \var{mgpoint} \op{atperiods} \var{periods} \\
\dt{mgpoint} $\times$ \dt{gpoint} $\rightarrow$ \dt{mgpoint} \> \var{mgpoint} \op{at}(\var{gpoint})\\
\dt{mgpoint} $\times$ \dt{gline} $\rightarrow$ \dt{mgpoint} \> \var{mgpoint} \op{at}(\var{gline})\\
\dt{mgpoint} $\times$ \dt{mgpoint}  $\rightarrow$  \dt{mgpoint} \> \op{intersection}(\var{mgpoint1}, \var{mgpoint2})\\
\dt{mgpoint} $\times$ \dt{real} $\rightarrow$ \dt{mgpoint} \> \op{simplify}(\var{mgpoint},\var{real})\\
\end{tabbing}
\subsubsection{\op{atinstant}}
Restricts the \var{mgpoint} to the given time instant. Therefore a binary scan of the units of the \var{mgpoint} is performed to find the unit containing the given time instant. If a corresponding unit is found the resulting  \dt{igpoint} is computed. The time complexity depends on the number \var{m} of units of the \var{mgpoint} and is O($\log \var{m}$).
\subsubsection{\op{atperiods}}
Restricts the \var{mgpoint} to the given \var{periods}. Therefore a parallel scan of \var{periods} and the units of the \var{mgpoint} is performed. And the (parts) of units which are inside the \var{periods} value are written to the resulting \dt{mgpoint}. The time complexity is O($\var{m} + \var{p}$) if \var{m} is the number of units of the \var{mgpoint} and \var{p} is the number of time intervals of the \var{periods}.
\subsubsection{\op{at}}
Restricts the \var{mgpoint} to the times and places it passed a given \var{gpoint} respectively \var{gline}.
\paragraph{\dt{gpoint}}
The algorithm performs a linear scan on the units of the \var{mgpoint} and checks for every unit if the \var{mgpoint} passes the \var{gpoint}. If this is the case a \dt{ugpoint} for the time the \var{mgpoint} was at the \var{gpoint} is computed and added to the resulting \dt{mgpoint}.  The computation takes O(\var{m}) time if \var{m} is the number of units of the \var{mgpoint}.
\paragraph{\dt{gline}}
The algorithm performs a linear scan on the units of the \var{mgpoint}. If the \var{gline} is sorted a binary search on the route intervals of the \var{gline} is performed for each unit of the \var{mgpoint}. If the \var{gline} is not sorted a linear scan of the route intervals is performed for each unit of the \var{mgpoint}. In both cases it is checked if the actual \dt{ugpoint} passes any route interval of the \var{gline}. If this is the case the times and places of passing are computed as \dt{ugpoint}s and added to the resulting \dt{mgpoint}.

The time complexity for the operation is O($\var{m} \log \var{r}$) for sorted and O(\var{mr}) for unsorted \var{gline}, if \var{m} is the number of units of the \var{mgpoint}, and \var{r} the number of \dt{route intervals} of the \var{gline}.
\subsubsection{\op{intersection}}
Returns a \dt{mgpoint} value representing the times and places where both \var{mgpoint}s have been at the same time. The algorithm first computes the refinement partitions\footnote{Refinement partition means that the units of both \var{mgpoint} are parted, so that in the end the units of both \var{mgpoint} have the same time intervals for the times they both exist.} of the both \var{mgpoint}. Then it performs a parallel scan through the refinement partitions of the both \var{mgpoint} and checks for every pair of units if the positions intersect. If this is the case a \dt{ugpoint} with the intersection value is computed and written to the resulting \dt{mgpoint}.

Let \var{m} respectively \var{n} be the number of units of the both \var{mgpoint} and \var{r} the number of units of the refinement partitions. The time complexity of the algorithm is O($\var{m} + \var{n} + \var{r}$).
\subsubsection{\op{simplify}}
The operation reduces the number of units of the \var{mgpoint}, by merging the units, where the \var{mpoint} moves on the same route, in the same direction, and the speed difference is smaller as the given \var{real}. To do this a linear scan on the units of the \var{mpoint} is performed and the condition is checked for every unit. This will take O(\var{m}) time if \var{m} is the number of units of the \var{mgpoint}. Detailed information about the simplification can be taken from \cite{DAScheppokat}. 
\subsubsection{\op{mpgsecunits}, \op{mgpsecunits2}, and \op{mgpsecunits3}}
\label{sec:opmgpsecunits}
\begin{tabbing}
xxxxxxxxxxxxxxxxxxxxxxxxx\=xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\kill
\op{mgpsecunits}: \> \dt{rel}(\dt{tuple}(($a_1$ $x_1$)($a_2$ $x_2$)...($a_2$ $x_2$))) $\times a_i \times$ \dt{network} $\times$ \dt{real} $\rightarrow$ \dt{stream}(\dt{mgpsecunit}) \\
\op{mgpsecunits2}: \> \dt{mgpoint} $\times$ \dt{real} $\rightarrow$ \dt{stream}(\dt{mgpsecunit}) \\
\op{mgpsecunits3}: \> \dt{stream}(\dt{mgpoint}) $\times$ \dt{real} $\rightarrow$ \dt{stream}(\dt{mgpsecunit}) \\
\end{tabbing}
We implemented three different versions of the \op{mgpsecunits}. They all get different input values. While the second operation \op{mgpsecunits2} is provided to support later on a new spatio-temporal network index for \dt{mgpoint} values. The first (\op{mgpsecunits}) and the last (\op{mgpsecunits3}) should support traffic estimation operations. This traffic estimation operations will be part of another new algebra module called \file{TrafficAlgebra}.

The algorithm is for all three versions of the \op{mgpsecunits} operation almost the same. The input is a set of \dt{mgpoint} or in case of \op{mgpsecunits2} a single \dt{mgpoint} and the output a stream of \dt{mgpsecunit}s containing all the information's given by the input \dt{mgpoint}s. The algorithm computes for all units of every \dt{mgpoint} a corresponding set of \dt{mgpsecunit}s. The resulting \dt{mgpsecunit}s for a single \dt{mgpoint} are merged as far as possible. Merging means here that as long as the \dt{mgpoint} moves in the same section part in the same direction the different \dt{mgpsecunit}s are merged into one \dt{mgpsecunit}. At least the result is returned as \dt{stream} of \dt{mgpsecunit}s.
\subsection{\op{ugpoint2mgpoint}}
\begin{tabbing}
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\=xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\kill
\dt{ugpoint} $\rightarrow$ \dt{mgpoint}\> \op{ugpoint2mgpoint}(\dt{ugpoint})\\
\end{tabbing}
The operation constructs a \dt{mgpoint} from a single \dt{ugpoint}.
\subsection{\op{polygpoints}}
\begin{tabbing}
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\=xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\kill
\dt{gpoint} $\rightarrow$ \dt{stream}(\dt{gpoint}) \> \op{polygpoints}(\dt{gpoint})\\
\end{tabbing}
A problem of the network data model is that junctions belong to more than one route. Therefore they are represented by more than one \dt{gpoint}. Operators like \op{passes} or \op{inside} doesn't check if the query \var{gpoint} is a junction and probably has more than one representation, because the interpretation of passing a network junction in \cite{1146465} is slightly different from passing a \dt{point} in the 2D space. So if, for example, a \dt{mgpoint} passes a junction on the one route and the \dt{gpoint} representing the junction is given related to another route we get \false{} as result. This is correct in the network data model but doesn't correspond to the \op{passes} interpretation of the \bmodb{}.

We introduced the operation \op{polygpoints} to bypass this problem in the \bmodb{}. This operation returns for every given \var{gpoint} a \dt{stream} of \dt{gpoint}. This stream contains only the \var{gpoint} itself if the \var{gpoint} is not a junction, and the \var{gpoint} itself and all the alias \dt{gpoint}s representing the same place if the \var{gpoint} is a junction.

The algorithm \op{polygpoints} first copies the argument \var{gpoint} to the output stream. Then it checks if the \var{gpoint} represents a junction by selecting all junctions from the junctions relation which are on the route with the route identifier of the \var{gpoint} with help of the junctions relation B-Tree. This junctions are checked if they are identified by the \var{gpoint}. If this is the case all other \var{gpoint} values identifying the same junction on other routes are returned in the output stream.

The check if the \var{gpoint} is a junction takes O($\var{k} + \log \var{j}$) time, if the number of junctions in the network is \var{j} and the number of junctions on the route is \var{k}. If \var{i} is the number of related junctions we can find and return them in O($\var{i} + \log \var{k}$) time. Altogether we get a time complexity of O($\var{k} + \var{i} + \log \var{j} + \log \var{k}$) = O($\var{k} + \log \var{j}$), because it holds $\var{i}\leq \var{k} \leq \var{j}$.
\addcontentsline{toc}{section}{References}
\bibliography{NetworkDocumentation}{}
\bibliographystyle{plain}
\end{document}