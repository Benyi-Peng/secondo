open database berlinmod;

let Q5bOBA =
  QueryLicences1 feed {l1}
  loopsel[dataSNcar_Licence_btree dataSNcar exactmatch [.Licence_l1]
  projectextend[Licence; TrajLine: gline2line(trajectory(.Trip))]]{c1}
  QueryLicences2 feed {l2}
  loopsel[dataSNcar_Licence_btree dataSNcar exactmatch [.Licence_l2]
  projectextend[Licence; TrajLine: gline2line(trajectory(.Trip))]]{c2}
  product
  projectextend [Licence_c1, Licence_c2; Distance: distance(.TrajLine_c1, .TrajLine_c2)]
consume;

let Q7cOBA =
QueryPointsNet feed projectextend[Id, Pos; Prect: gpoint2rect(.Pos)] {a}
  QueryPointsNet feed projectextend[Id, Pos; Prect: gpoint2rect(.Pos)]
  loopsel [fun(t:TUPLE) dataSNcar_TrajBoxNet windowintersectsS[attr(t,Prect)]
  sort rdup dataSNcar gettuples
  filter [.Type = "passenger"]
  projectextend[; Id: attr(t,Id) , Instant: inst(initial(.Trip at attr(t,Pos)))]]
  filter[not(isempty(.Instant))]
  sortby[Id asc, Instant asc]
  groupby[Id; FirstTime: group feed min[Instant]]{b}
  symmjoin [.Id_a = ..Id_b]
  projectextend [Id_a, FirstTime_b, Pos_a; MBR: box3d(.Prect_a, .FirstTime_b)]
 loopjoin[dataSNcar_BoxNet_timespace windowintersectsS[.MBR]
  sort rdup dataSNcar gettuples]
  filter[.Type = "passenger"]
  projectextend[Licence, FirstTime_b, Id_a; Instant: inst(initial(.Trip at .Pos_a))]
  filter [not(isempty(.Instant))]
  filter[.Instant <= .FirstTime_b]
  project[Id_a, Licence]
 consume;

let Q13aOBA =
  dataSNcar feed {c}
  QueryRegions1Net feed filter[not(isempty(.Region))] {r}
  symmjoin[.Trip_c passes ..Region_r]
  projectextend[Licence_c, Id_r, Region_r; Trip: .Trip_c at .Region_r]
  QueryPeriods1 feed filter[not(isempty(.Period))]{p}
  symmjoin [.Trip present ..Period_p]
  projectextend[Id_r, Period_p; Licence: .Licence_c, Trip: .Trip atperiods .Period_p]
  filter [no_components(.Trip) > 0]
  project[Id_r, Period_p, Licence]
  sortby[Id_r asc, Period_p asc, Licence asc]
consume;

let Q14OBATest2 =
dataSNcar feed
QueryRegions1Net feed filter[not(isempty(.Region))]
symmjoin[.Trip passes ..Region] {R}
QueryInstant1 feed 
product
projectextend[Licence_R, Id_R, Region_R, Instant; PosX: (val(.Trip_R atinstant .Instant))]
projectextendstream[Licence_R, Id_R, Region_R, Instant; Pos: polygpoints(.PosX,B_NETWORK)]
filter[.Pos inside .Region_R]
project[Id_R, Instant, Licence_R]
sortby [Id_R asc, Instant asc, Licence_R asc]
krdup[Id_R, Instant, Licence_R]
consume;

let Q16bOBA =
 QueryLicences1 feed {l}
  loopjoin [dataSNcar_Licence_btree dataSNcar exactmatch [.Licence_l]] {c}
  QueryPeriods1 feed filter[not(isempty(.Period))]{p}
  symmjoin [.Trip_c present ..Period_p]
  projectextend[Id_p, Period_p; Licence: .Licence_c, Trip: .Trip_c atperiods .Period_p]
  filter [no_components(.Trip) > 0]
  QueryRegions1Net feed filter[not(isempty(.Region))] {r}
  symmjoin[.Trip passes ..Region_r]
  projectextend[Licence, Id_r, Region_r, Id_p, Period_p; Trip: .Trip at .Region_r]
  filter [no_components(.Trip) > 0]{a}
  QueryLicences2 feed {l}
  loopjoin [dataSNcar_Licence_btree dataSNcar exactmatch [.Licence_l]] {c}
  QueryPeriods1 feed filter[not(isempty(.Period))]{p}
  symmjoin [.Trip_c present ..Period_p]
  projectextend[Id_p, Period_p; Licence: .Licence_c, Trip: .Trip_c atperiods .Period_p]
  filter [no_components(.Trip) > 0]
  QueryRegions1Net feed filter[not(isempty(.Region))] {r}
  symmjoin[.Trip passes ..Region_r]
  projectextend[Licence, Id_r, Region_r, Id_p, Period_p; Trip: .Trip at .Region_r]
  filter [no_components(.Trip) > 0]{b}
  symmjoin[(.Id_r_a = ..Id_r_b) and (.Id_p_a = ..Id_p_b)]
  filter [.Licence_a # .Licence_b]
  filter[not(.Trip_a intersects .Trip_b)]
  project [Id_r_a, Period_p_a, Licence_a, Licence_b]
consume;

let Q5h1OBATest =
  QueryLicences1 feed {l1}
  loopsel[dataSNcar_Licence_btree dataSNcar exactmatch [.Licence_l1]
  projectextend[Licence; TrajLine: gline2line(trajectory(.Trip))]]
consume;
let Q5h2OBATest =
  QueryLicences2 feed {l2}
  loopsel[dataSNcar_Licence_btree dataSNcar exactmatch [.Licence_l2]
  projectextend[Licence; TrajLine: gline2line(trajectory(.Trip))]]
consume;
let Q5OBATest =
Q5h1OBATest feed {c1}
Q5h2OBATest feed {c2}
  product
  projectextend [Licence_c1, Licence_c2; Distance: distance(.TrajLine_c1, .TrajLine_c2)]
consume;

let Q7hOBATest =
  QueryPointsNet feed projectextend[Id, Pos; Prect: gpoint2rect(.Pos)]
  loopsel [fun(t:TUPLE) dataSNcar_TrajBoxNet windowintersectsS[attr(t,Prect)]
  sort rdup dataSNcar gettuples
  filter [.Type = "passenger"]
  projectextend[Licence; Id: attr(t,Id) , Instant: inst(initial(.Trip at attr(t,Pos)))]]
  filter[not(isempty(.Instant))]
  sortby[Id asc, Instant asc]
consume;

let Q7OBATest1 =
Q7hOBATest feed groupby[Id; FirstTime: group feed min[Instant]]{b}
Q7hOBATest feed {a}
 symmjoin [(..Id_a = .Id_b) and (..Instant_a <= .FirstTime_b)]
  project[Id_a, Licence_a]
 consume;

let Q13OBATest =
  dataSNcar feed {c}
  QueryRegions1Net feed filter[not(isempty(.Region))] {r}
  symmjoin[.Trip_c passes ..Region_r]
  projectextend[Licence_c, Id_r, Region_r; Trip: .Trip_c at .Region_r]
  QueryPeriods1 feed filter[not(isempty(.Period))]{p}
  symmjoin [.Trip present ..Period_p]
  filter [no_components(.Trip) > 0]
  project[Id_r, Period_p, Licence_c]
  sortby[Id_r asc, Period_p asc, Licence_c asc]
consume;

let Q7OBATest2 =
Q7hOBATest feed groupby[Id; FirstTime: group feed min[Instant]]{b}
Q7hOBATest feed {a}
 symmjoin [..Id_a = .Id_b]
filter[.Instant_a <= .FirstTime_b]
  project[Id_a, Licence_a]
 consume;

let Q14OBA =
  QueryRegions1Net feed filter[not(isempty(.Region))]
  projectextendstream[Id, Region; Rrect:  routeintervals(.Region)] {r}
  QueryInstant1 feed {i}
  product
  loopsel[fun(t:TUPLE) dataSNcar_BoxNet_timespace windowintersectsS[box3d(attr(t,Rrect_r), attr(t,Instant_i))]
  sort rdup dataSNcar gettuples
    filter[(val(.Trip atinstant (attr(t,Instant_i)))) inside (attr(t,Region_r))]
  projectextend [Licence;Instant: attr(t,Instant_i), Id: attr(t,Id_r)]]
  sortby [Id asc, Instant asc, Licence asc]
  krdup[Id, Instant, Licence]
consume;

let Q16h1OBATest =
 QueryLicences1 feed {l}
  loopjoin [dataSNcar_Licence_btree dataSNcar exactmatch [.Licence_l]] {c}
  QueryPeriods1 feed filter[not(isempty(.Period))]{p}
  symmjoin [.Trip_c present ..Period_p]
  projectextend[Id_p, Period_p; Licence: .Licence_c, Trip: .Trip_c atperiods .Period_p]
  filter [no_components(.Trip) > 0]
  QueryRegions1Net feed filter[not(isempty(.Region))] {r}
  symmjoin[.Trip passes ..Region_r]
  projectextend[Licence, Id_r, Region_r, Id_p, Period_p; Trip: .Trip at .Region_r]
  filter [no_components(.Trip) > 0]
consume;

let Q16h2OBATest = 
  QueryLicences2 feed {l}
  loopjoin [dataSNcar_Licence_btree dataSNcar exactmatch [.Licence_l]] {c}
  QueryPeriods1 feed filter[not(isempty(.Period))]{p}
  symmjoin [.Trip_c present ..Period_p]
  projectextend[Id_p, Period_p; Licence: .Licence_c, Trip: .Trip_c atperiods .Period_p]
  filter [no_components(.Trip) > 0]
  QueryRegions1Net feed filter[not(isempty(.Region))] {r}
  symmjoin[.Trip passes ..Region_r]
  projectextend[Licence, Id_r, Region_r, Id_p, Period_p; Trip: .Trip at .Region_r]
  filter [no_components(.Trip) > 0]
consume;

let Q16OBATest = 
Q16h1OBATest feed {a}
Q16h2OBATest feed {b}
  symmjoin[(.Id_r_a = ..Id_r_b) and (.Id_p_a = ..Id_p_b)]
  filter [.Licence_a # .Licence_b]
  filter[not(.Trip_a intersects .Trip_b)]
  project [Id_r_a, Period_p_a, Licence_a, Licence_b]
consume;

let Q14OBATest1 =
dataSNcar feed  
QueryInstant1 feed 
product
projectextend[Licence, Instant; PosX: val(.Trip atinstant .Instant)]
projectextendstream[Licence, Instant; Pos: polygpoints(.PosX,B_NETWORK)]
QueryRegions1Net feed filter[not(isempty(.Region))]
symmjoin[.Pos inside ..Region]
project[Id, Instant, Licence]
sortby [Id asc, Instant asc, Licence asc]
krdup[Id, Instant, Licence]
consume;


let Q14TBATest2 =
dataMNtrip feed
QueryRegions1Net feed filter[not(isempty(.Region))]
symmjoin[.Trip passes ..Region] {R}
QueryInstant1 feed 
symmjoin[.Trip_R present ..Instant]
projectextend[Moid_R, Id_R, Region_R, Instant; PosX: val(.Trip_R atinstant .Instant)]
projectextendstream[Moid_R, Id_R, Region_R, Instant; Pos: polygpoints(.PosX,B_NETWORK)]
filter[.Pos inside .Region_R]
project[Id_R, Instant, Moid_R]
sortby [Id_R asc, Instant asc, Moid_R asc]
krdup[Id_R, Instant, Moid_R]
loopjoin[dataMcar_Moid_btree dataMcar exactmatch [.Moid_R]]
project[Id_R, Instant, Licence]
consume;


let Q14TBA =
  QueryRegions1Net feed filter[not(isempty(.Region))] projectextendstream[Id, Region; Brect: routeintervals(.Region)]{r}
  QueryInstant1 feed {i}
  product
  projectextend[Id_r, Region_r, Instant_i; Box: box3d(.Brect_r, .Instant_i)]
  loopsel[fun(t:TUPLE) dataMNtrip_BoxNet_timespace windowintersectsS[attr(t,Box)]
  sort rdup dataMNtrip gettuples
  filter[(val(.Trip atinstant (attr(t,Instant_i)))) inside (attr(t,Region_r))]
  projectextend [Moid;Instant: attr(t,Instant_i), Id: attr(t,Id_r)]]{a}
  loopjoin[dataMcar_Moid_btree dataMcar exactmatch [.Moid_a]]
  projectextend[Licence; Id: .Id_a, Instant: .Instant_a]
  sortby [Id asc, Instant asc, Licence asc]
  krdup[Id, Instant, Licence]
consume;

let Q5aTBA =
  QueryLicences1 feed project[Licence] {LL1}
  loopsel[ fun(t:TUPLE)
    dataMcar_Licence_btree dataMcar exactmatch[attr(t,Licence_LL1)] {CAR}
    loopsel[dataMNtrip_Moid_btree dataMNtrip exactmatch[.Moid_CAR]]
    projectextend[;Traj: trajectory(.Trip)]
    aggregateB[Traj; fun(L1: gline, L2: gline) L1 union L2; [const gline value ()]]
    feed namedtransformstream[Traxj]
    extend[Licence: attr(t,Licence_LL1)]
  ]
  projectextend[Licence; Trax: gline2line(.Traxj)]{c1}
  QueryLicences2 feed project[Licence] {LL2}
  loopsel[ fun(s:TUPLE)
    dataMcar_Licence_btree dataMcar exactmatch[attr(s,Licence_LL2)] {CAR}
    loopsel[dataMNtrip_Moid_btree dataMNtrip exactmatch[.Moid_CAR]]
    projectextend[;Traj: trajectory(.Trip)]
    aggregateB[Traj; fun(L3: gline, L4: gline) L3 union L4; [const gline value ()]]
    feed namedtransformstream[Traxj]
    extend[Licence: attr(s,Licence_LL2)]
  ]
  projectextend[Licence; Trax: gline2line(.Traxj)]{c2}
  product
  projectextend [Licence_c1, Licence_c2; Distance: distance(.Trax_c1, .Trax_c2)]
consume;


let Q7ah1TBA =
  QueryPointsNet feed
  projectextend[Id, Pos; Prect: gpoint2rect(.Pos)]
  loopsel[fun(t:TUPLE) dataMNtrip_TrajBoxNet windowintersectsS[attr(t,Prect)]
  sort rdup dataMNtrip gettuples
  loopjoin[dataMcar_Moid_btree dataMcar exactmatch [.Moid]
  filter[.Type = "passenger"]
  project[Licence] {X}]
  projectextend[ Licence_X;TimeAtPos: inst(initial(.Trip at attr(t,Pos))), Id: attr(t, Id)]]
  sortby [Id asc, TimeAtPos asc]
consume;

query now();

let Q7aTBA =
  Q7ah1TBA feed {a}
  Q7ah1TBA feed
    groupby [Id; FirstTime: group feed min[TimeAtPos]]{b}
  symmjoin[(.Id_a = ..Id_b)]
  filter[.TimeAtPos_a <= .FirstTime_b]
  project [Id_a, Licence_X_a]
  sortby [Id_a asc, Licence_X_a asc]
  krdup [Id_a, Licence_X_a]
 consume;

let Q16bTBA =
  QueryLicences1 feed {l}
  loopjoin [dataMcar_Licence_btree dataMcar exactmatch[.Licence_l]] {a}
  loopjoin[dataMNtrip_Moid_btree dataMNtrip exactmatch[.Moid_a]]
  QueryPeriods1 feed filter[not(isempty(.Period))]{p}
  symmjoin [.Trip present ..Period_p]
  projectextend[Id_p, Period_p; Licence: .Licence_a, Trip: .Trip atperiods .Period_p]
  filter[no_components(.Trip)>0]
  QueryRegions1Net feed filter[not(isempty(.Region))]{r}
  symmjoin [.Trip passes ..Region_r]
  projectextend[Licence, Id_p, Period_p, Id_r; Trip: .Trip at .Region_r]
  filter [no_components(.Trip) > 0]{a}
  QueryLicences2 feed {l}
  loopjoin [dataMcar_Licence_btree dataMcar exactmatch[.Licence_l]]{a}
  loopjoin[dataMNtrip_Moid_btree dataMNtrip exactmatch[.Moid_a]]
  QueryPeriods1 feed filter[not(isempty(.Period))]{p}
  symmjoin [.Trip present ..Period_p]
  projectextend[Id_p, Period_p; Licence: .Licence_a, Trip: .Trip atperiods .Period_p]
  filter[no_components(.Trip)>0]
  QueryRegions1Net feed filter[not(isempty(.Region))]{r}
  symmjoin [.Trip passes ..Region_r]
  projectextend[Licence, Id_p, Id_r; Trip: .Trip at .Region_r]
  filter [no_components(.Trip) > 0]{b}
  symmjoin[(.Id_r_a = ..Id_r_b) and (.Id_p_a = ..Id_p_b)]
  filter[.Licence_a # .Licence_b]
  filter [not(.Trip_a intersects .Trip_b)]
  project [Id_r_a, Id_p_a, Period_p_a, Licence_a, Licence_b]
  sortby [Id_r_a asc, Id_p_a asc, Licence_a asc, Licence_b asc]
  krdup [Id_r_a, Id_p_a, Licence_a, Licence_b]
consume;

let Q14TBATest1 =
dataMNtrip feed
QueryInstant1 feed 
symmjoin[.Trip present ..Instant]
projectextend[Moid, Instant; PosX: val(.Trip atinstant .Instant)]
projectextendstream[Moid, Instant; Pos: polygpoints(.PosX,B_NETWORK)]
QueryRegions1Net feed filter[not(isempty(.Region))]
symmjoin[.Pos inside ..Region]
project[Id, Instant, Moid]
sortby [Id asc, Instant asc, Moid asc]
krdup[Id, Instant, Moid] {a}
loopjoin[dataMcar_Moid_btree dataMcar exactmatch [.Moid_a]]
project[Id_a, Instant_a, Licence]
consume;





let Q5h1TBATest =
  QueryLicences1 feed project[Licence] {LL1}
  loopsel[ fun(t:TUPLE)
    dataMcar_Licence_btree dataMcar exactmatch[attr(t,Licence_LL1)] {CAR}
    loopsel[dataMNtrip_Moid_btree dataMNtrip exactmatch[.Moid_CAR]]
    projectextend[;Traj: trajectory(.Trip)]
    aggregateB[Traj; fun(L1: gline, L2: gline) L1 union L2; [const gline value ()]]
    feed namedtransformstream[Traxj]
    extend[Licence: attr(t,Licence_LL1)]
  ]
  projectextend[Licence; Trax: gline2line(.Traxj)]
consume;

let Q5h2TBATest =
  QueryLicences2 feed project[Licence] {LL2}
  loopsel[ fun(s:TUPLE)
    dataMcar_Licence_btree dataMcar exactmatch[attr(s,Licence_LL2)] {CAR}
    loopsel[dataMNtrip_Moid_btree dataMNtrip exactmatch[.Moid_CAR]]
    projectextend[;Traj: trajectory(.Trip)]
    aggregateB[Traj; fun(L3: gline, L4: gline) L3 union L4; [const gline value ()]]
    feed namedtransformstream[Traxj]
    extend[Licence: attr(s,Licence_LL2)]
  ]
  projectextend[Licence; Trax: gline2line(.Traxj)]
consume;

let Q5TBATest = 
Q5h1TBATest feed {c1}
Q5h2TBATest feed {c2}
  product
  projectextend [Licence_c1, Licence_c2; Distance: distance(.Trax_c1, .Trax_c2)]
consume;

let Q7hTBATest =
  QueryPointsNet feed
  projectextend[Id, Pos; Prect: gpoint2rect(.Pos)]
  loopsel[fun(t:TUPLE) dataMNtrip_TrajBoxNet windowintersectsS[attr(t,Prect)]
  sort rdup dataMNtrip gettuples
  loopjoin[dataMcar_Moid_btree dataMcar exactmatch [.Moid]
  filter[.Type = "passenger"]
  project[Licence] {X}]
  projectextend[ Licence_X;TimeAtPos: inst(initial(.Trip at attr(t,Pos))), Id: attr(t, Id)]]
  sortby [Id asc, TimeAtPos asc]
consume;

query now();

let Q7TBATest =
  Q7hTBATest feed
    groupby [Id; FirstTime: group feed min[TimeAtPos]]{b}
  Q7hTBATest feed {a}
  symmjoin[(..Id_a = .Id_b)]
  filter[.TimeAtPos_a <= .FirstTime_b]
  project [Id_a, Licence_X_a]
  sortby [Id_a asc, Licence_X_a asc]
  krdup [Id_a, Licence_X_a]
 consume;

let Q16h1TBATest =
  QueryLicences1 feed {l}
  loopjoin [dataMcar_Licence_btree dataMcar exactmatch[.Licence_l]] {a}
  loopjoin[dataMNtrip_Moid_btree dataMNtrip exactmatch[.Moid_a]]
  QueryPeriods1 feed filter[not(isempty(.Period))]{p}
  symmjoin [.Trip present ..Period_p]
  projectextend[Id_p, Period_p; Licence: .Licence_a, Trip: .Trip atperiods .Period_p]
  filter[no_components(.Trip)>0]
  QueryRegions1Net feed filter[not(isempty(.Region))]{r}
  symmjoin [.Trip passes ..Region_r]
  projectextend[Licence, Id_p, Period_p, Id_r; Trip: .Trip at .Region_r]
  filter [no_components(.Trip) > 0]
consume;

let Q16h2TBATest = 
  QueryLicences2 feed {l}
  loopjoin [dataMcar_Licence_btree dataMcar exactmatch[.Licence_l]]{a}
  loopjoin[dataMNtrip_Moid_btree dataMNtrip exactmatch[.Moid_a]]
  QueryPeriods1 feed filter[not(isempty(.Period))]{p}
  symmjoin [.Trip present ..Period_p]
  projectextend[Id_p, Period_p; Licence: .Licence_a, Trip: .Trip atperiods .Period_p]
  filter[no_components(.Trip)>0]
  QueryRegions1Net feed filter[not(isempty(.Region))]{r}
  symmjoin [.Trip passes ..Region_r]
  projectextend[Licence, Id_p, Id_r; Trip: .Trip at .Region_r]
  filter [no_components(.Trip) > 0]
consume;

let Q16TestTBA = 
Q16h1TBATest feed {a}
Q16h2TBATest feed {b}
  symmjoin[(.Id_r_a = ..Id_r_b) and (.Id_p_a = ..Id_p_b)]
  filter[.Licence_a # .Licence_b]
  filter [not(.Trip_a intersects .Trip_b)]
  project [Id_r_a, Id_p_a, Period_p_a, Licence_a, Licence_b]
  sortby [Id_r_a asc, Id_p_a asc, Licence_a asc, Licence_b asc]
  krdup [Id_r_a, Id_p_a, Licence_a, Licence_b]
consume;


let Q7TBATest2 =
  Q7hTBATest feed
    groupby [Id; FirstTime: group feed min[TimeAtPos]]{b}
  Q7hTBATest feed {a}
  symmjoin[(..Id_a = .Id_b) and (..TimeAtPos_a <= .FirstTime_b)]
  project [Id_a, Licence_X_a]
  sortby [Id_a asc, Licence_X_a asc]
  krdup [Id_a, Licence_X_a]
 consume;


let Q14TBATest3 =
dataMNtrip feed  
QueryInstant1 feed 
symmjoin[.Trip present ..Instant]
projectextend[Moid, Instant; PosX: val(.Trip atinstant .Instant)]
projectextendstream[Moid, Instant; Pos: polygpoints(.PosX,B_NETWORK)]
QueryRegions1Net feed filter[not(isempty(.Region))]
symmjoin[.Pos inside ..Region]
project[Id, Instant, Moid]
sortby [Id asc, Instant asc, Moid asc]
krdup[Id, Instant, Moid] {a}
loopjoin[dataMcar_Moid_btree dataMcar exactmatch[.Moid_a]]
project[Id_a, Instant_a, Licence]
consume;

let EVAL_SEC2COMMANDS_NETOBA = SEC2COMMANDS feed consume;

save EVAL_SEC2COMMANDS_NETOBA to 'NetworkTestRunTimes.DAT';

delete EVAL_SEC2COMMANDS_NETOBA;

close database;
quit;
