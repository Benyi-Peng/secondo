open database berlinmod;

let Q10lOBA =
  QueryLicences1 feed
  loopsel[dataSNcar_Licence_btree dataSNcar exactmatch[.Licence]]
  projectextend[Licence, Trip; BBox: mgpbbox(.Trip)]
  projectextend[Licence, Trip; TripA: mgpoint2mpoint(.Trip), Box: rectangle2((minD(.BBox,1) - 3.0), (maxD(.BBox,1) + 3.0), (minD(.BBox,2) - 3.0), (maxD(.BBox,2) + 3.0)), Ts: inst(initial(.Trip)), Te: inst(final(.Trip))]
  loopsel[fun(t:TUPLE) B_NETWORK dataSNcar_MONTree dataSNcar windowtimeintersectsS[attr(t,Box), attr(t,Ts), attr(t,Te)] sort dataSNcar gettuplesdbl[Trip]
  filter[.Licence # attr(t,Licence)]
  projectextend[Licence; Licence_A: attr(t,Licence), Pos: attr(t,Trip) atperiods (deftime((distance(attr(t,TripA), mgpoint2mpoint(.Trip)) < 3.0) at TRUE))]
  filter[not(isempty(.Pos))]]
consume;

let Q10fTBA =
  QueryLicences1 feed
  loopsel[dataMcar_Licence_btree dataMcar exactmatch[.Licence]] {l}
  dataMNtrip feed
  symmjoin[.Moid_l = ..Moid]
  projectextend[Licence_l, Moid_l, Trip; BBox: mgpbbox(.Trip)]
  projectextend[Licence_l, Moid_l, Trip; TripA: mgpoint2mpoint(.Trip), Box: rectangle2((minD(.BBox,1) - 3.0), (maxD(.BBox,1) + 3.0), (minD(.BBox,2) - 3.0), (maxD(.BBox,2) + 3.0)), Ts: inst(initial(.Trip)), Te: inst(final(.Trip))]
  loopsel[fun(t:TUPLE) B_NETWORK dataMNtrip_MONTree dataMNtrip windowtimeintersectsS[attr(t,Box), attr(t,Ts), attr(t,Te)] sort dataMNtrip gettuplesdbl[Trip]
  filter[.Moid # attr(t,Moid_l)]
  projectextend[Moid; Licence_A:attr(t,Licence_l), Pos: attr(t,Trip) atperiods (deftime((distance(attr(t,TripA), mgpoint2mpoint(.Trip)) < 3.0) at TRUE))]
  filter[not(isempty(.Pos))]]
  sortby[Licence_A asc, Moid asc]
  groupby [Licence_A, Moid; AllPos: group feed aggregateB[Pos; fun(M1:mgpoint, M2:mgpoint) M1 union M2; [const mgpoint value()]]]
  project[Licence_A, Moid, AllPos]
  dataMcar feed {c}
  symmjoin[.Moid = ..Moid_c]
  project[Licence_A, Licence_c, AllPos]
consume;

let Q10f1TBA =
  QueryLicences1 feed
  loopsel[dataMcar_Licence_btree dataMcar exactmatch[.Licence]] {l}
  dataMNtrip feed
  symmjoin[.Moid_l = ..Moid]
  projectextend[Licence_l, Moid_l, Trip; BBox: mgpbbox(.Trip)]
  projectextend[Licence_l, Moid_l, Trip; TripA: mgpoint2mpoint(.Trip), Box: rectangle2((minD(.BBox,1) - 3.0), (maxD(.BBox,1) + 3.0), (minD(.BBox,2) - 3.0), (maxD(.BBox,2) + 3.0)), Ts: inst(initial(.Trip)), Te: inst(final(.Trip))]
  loopsel[fun(t:TUPLE) B_NETWORK dataMNtrip_MONTree dataMNtrip windowtimeintersectsS[attr(t,Box), attr(t,Ts), attr(t,Te)] sort rdup dataMNtrip gettuples
  filter[.Moid # attr(t,Moid_l)]
  projectextend[Moid; Licence_A:attr(t,Licence_l), Pos: attr(t,Trip) atperiods (deftime((distance(attr(t,TripA), mgpoint2mpoint(.Trip)) < 3.0) at TRUE))]
  filter[not(isempty(.Pos))]]
  sortby[Licence_A asc, Moid asc]
  groupby [Licence_A, Moid; AllPos: group feed aggregateB[Pos; fun(M1:mgpoint, M2:mgpoint) M1 union M2; [const mgpoint value()]]]
  project[Licence_A, Moid, AllPos]
  dataMcar feed {c}
  symmjoin[.Moid = ..Moid_c]
  project[Licence_A, Licence_c, AllPos]
consume;

let EVAL_SEC2COMMANDS_NETOBA = SEC2COMMANDS feed consume;

save EVAL_SEC2COMMANDS_NETOBA to 'NetworkMONTree.DAT';

delete EVAL_SEC2COMMANDS_NETOBA;

close database;
