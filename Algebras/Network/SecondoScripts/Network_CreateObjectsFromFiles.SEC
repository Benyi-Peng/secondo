#####################################################################
# Translate BerlinMOD Data to network representation
#####################################################################

create database berlinnetwork;
open database berlinnetwork;
restore streets from 'streets.obj';
restore dataScar from 'datascar.obj';
restore dataMtrip from 'datamtrip.obj';
restore dataMcar from 'datamcar.obj';
restore QueryPoints from 'querypoints.obj';
restore QueryRegions from 'queryregions.obj';
restore QueryLicences from 'querylicences.obj';
restore QueryPeriods from 'queryperiods.obj';
restore QueryInstants from 'queryinstants.obj';

######################################################################
# Build a network from street data.
######################################################################

let B_ROUTES =
streets feed projectextendstream[; geoData: .geoData polylines[TRUE]]
addcounter[id,1]
projectextend [id; lengt : size(.geoData), geometry: fromline(.geoData), dual: TRUE, startSmaller: TRUE]
consume;

let B_JUNCTIONS =
B_ROUTES feed {r1}
B_ROUTES feed {r2}
symmjoin [(.id_r1 < ..id_r2) and (.geometry_r1 intersects ..geometry_r2)]
projectextendstream[id_r1, geometry_r1, id_r2, geometry_r2; CROSSING_POINT: components(crossings(.geometry_r1, .geometry_r2))]
projectextend[; r1id: .id_r1, r1meas: atpoint(.geometry_r1, .CROSSING_POINT, TRUE), r2id: .id_r2, r2meas: atpoint(.geometry_r2, .CROSSING_POINT, TRUE), cc: 65535]
consume;

let B_NETWORK = thenetwork(1, B_ROUTES, B_JUNCTIONS);

#########################################################
#
# translate relation values in network representation
#
#########################################################

let dataSNcar = dataScar feed 
  projectextend[Licence, Model, Type; Trip: mpoint2mgpoint(B_NETWORK, .Trip)]
consume;

let dataMNtrip =
  dataMtrip feed
  projectextend [Moid; Trip: mpoint2mgpoint(B_NETWORK, .Trip)]
consume;

let QueryPointsNet =
  QueryPoints feed
  projectextend[Id; Pos: point2gpoint(B_NETWORK, .Pos)]
  projectextendstream[Id;  Pos: polygpoints(.Pos, B_NETWORK)]
 consume;

let QueryPoints1Net =
  QueryPoints feed head[10]
  projectextend[Id; Pos: point2gpoint(B_NETWORK, .Pos)]
  projectextendstream[Id;  Pos: polygpoints(.Pos, B_NETWORK)]
 consume;

###########
# build a single line value from all routes geometry slines

let routesline =
  components(routes(B_NETWORK) feed
    projectextend[;curve: toline(.curve)]
    aggregateB[curve; fun(L1: line, L2: line) union_new(L1, L2); [const line value()]])
  transformstream
  extend[NoSeg: no_segments(.elem)]
  sortby [NoSeg desc]
  extract [elem];

##########
# get the line values from the intersection of the QueryRegions with the routesline

let QRlines =
  QueryRegions feed
  projectextend [Id; lr: intersection_new(.Region, routesline)]
 consume;

#########
# transform the lines to gline values

let QueryRegionsNet =
  QRlines feed
  projectextend[Id; Region: line2gline(B_NETWORK, .lr)]
 consume;

delete routesline;
delete QRlines;

######################################################################
##Start building Indexes                                            ##
######################################################################

######################################################################
# Build btrees for licences for dataScar, dataMtrip and for moids of
# dataMcar and dataMNtrip objects
#

let dataSNcar_Licence_btree = dataSNcar createbtree[Licence];

let dataMcar_Licence_btree = dataMcar createbtree[Licence];

let dataMcar_Moid_btree = dataMcar createbtree[Moid];

let dataMNtrip_Moid_btree = dataMNtrip createbtree[Moid];

####################################################################
# For many queries of BerlinMOD only the first 10 Elements of
# QueryPoints, QueryRegions, QueryInstants, QueryPeriods are used.
# From QueryLicences the first and second 10 Elements are used.
# If we build this selections once we don't have to do it in every query again.

let QueryLicences1 = QueryLicences feed head[10] consume;

let QueryLicences2 = QueryLicences feed head[20] filter [.Id > 10] consume;

let QueryPeriods1 = QueryPeriods feed head[10] consume;

let QueryInstant1 = QueryInstants feed head[10] consume;

let QueryRegions1Net = QueryRegionsNet feed head[10] consume;

####################################################################
#For many queries of BerlinMod it is helpful to have spatio and/or temporal
# indexes of the used mgpoints.

let dataSNcar_BoxNet_timespace =
  dataSNcar feed
  addid
  projectextendstream[TID; UTrip: units(.Trip)]
  extend[Box: unitbox(.UTrip)]
  sortby[Box asc]
 bulkloadrtree[Box];

let dataMNtrip_BoxNet_timespace =
  dataMNtrip feed
  addid
  projectextendstream[TID; UTrip: units(.Trip)]
  extend[Box: unitbox(.UTrip)]
  sortby[Box asc]
 bulkloadrtree[Box];

let dataSNcar_TrajBoxNet =
  dataSNcar feed
  addid
  projectextendstream[TID; Box: routeintervals(trajectory(.Trip))]
  sortby [Box asc]
 bulkloadrtree[Box];

let dataMNtrip_TrajBoxNet =
  dataMNtrip feed
  addid
  projectextendstream[TID; Box: routeintervals(trajectory(.Trip))]
  sortby [Box asc]
 bulkloadrtree[Box];

# for experimental use query 10
let dataSNcar_SpatioTemp =
  dataSNcar feed
  addid
  projectextend[TID; Box: mgpbbox(.Trip)]
  sortby [Box asc]
 bulkloadrtree[Box];

let dataMNtrip_SpatioTemp =
  dataMNtrip feed
  addid
  projectextend[TID; Box: mgpbbox(.Trip)]
  sortby [Box asc]
 bulkloadrtree[Box];

#let dataSNcar_MONTree = B_NETWORK dataSNcar createmontree[Trip];

#let dataMNtrip_MONTree = B_NETWORK dataMNtrip createmontree[Trip];

#let dataSNcar_SpatioTempUnit =
#  dataSNcar feed addid
#  projectextendstream[TID; UTrip: units(.Trip)]
#  projectextend[TID; Box: unitboundingbox(.UTrip)]
#  sortby[Box asc]
# bulkloadrtree[Box];

#let dataMNtrip_SpatioTempUnit =
#  dataMNtrip feed addid
#  projectextendstream[TID; UTrip: units(.Trip)]
#  projectextend[TID; Box: unitboundingbox(.UTrip)]
#  sortby[Box asc]
# bulkloadrtree[Box];

close database;
