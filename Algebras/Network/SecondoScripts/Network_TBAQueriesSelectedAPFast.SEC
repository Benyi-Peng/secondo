open database berlinmod;

query now();
let Q10eTBA =
  QueryLicences1 feed project[Licence] {V1}
  loopsel[ fun(t:TUPLE)
    dataMcar_Licence_btree dataMcar exactmatch[attr(t,Licence_V1)]
    project[Moid]
    loopjoin[dataMNtrip_Moid_btree dataMNtrip exactmatch[.Moid] remove[Moid]] {V3}
    extend[t3bbx: mgpbbox(.Trip_V3)]
    extend[ptripA: mgpoint2mpoint(.Trip_V3)]
    loopjoin[ fun(u:TUPLE)
      dataMNtrip_SpatioTemp
      windowintersectsS[rectangle3(
        minD(attr(u,t3bbx),1) - 3.0,
        maxD(attr(u,t3bbx),1) + 3.0,
        minD(attr(u,t3bbx),2) - 3.0,
        maxD(attr(u,t3bbx),2) + 3.0,
        minD(attr(u,t3bbx),3),
        maxD(attr(u,t3bbx),3))
      ] sort rdup
      dataMNtrip gettuples
      filter[.Moid # attr(u, Moid_V3)]
      projectextend[Moid; Times: deftime((distance(attr(u, ptripA), mgpoint2mpoint(.Trip)) < 3.0) at TRUE)]
      filter[not(isempty(.Times))]
      loopjoin[dataMcar_Moid_btree dataMcar exactmatch[.Moid] project[Licence]]
    ]
    projectextend[Times, Trip_V3; QueryLicence:
      attr(t, Licence_V1), OtherLicence: .Licence]
    projectextend[QueryLicence, OtherLicence; Pos: .Trip_V3 atperiods .Times]
    filter[not(isempty(.Pos))]
  ]
  sortby[QueryLicence asc, OtherLicence asc]
  groupby [QueryLicence, OtherLicence; AllPos: group feed
    aggregateB[Pos; fun(M1:mgpoint, M2:mgpoint) M1 union M2; [const mgpoint value()]]]
  project[QueryLicence, OtherLicence, AllPos]
  consume;

# Query 1: What are the models of the vehicles with license plate numbers from QueryLicence?
query now();
let Q1TBA =
  QueryLicences feed {l}
  loopjoin [dataMcar_Licence_btree dataMcar exactmatch[.Licence_l]]
  project [Licence, Model]
consume;

query now();
# Query 2: How many vehicles exit that are passenger cars?
query now();
let Q2TBA =
  dataMcar feed
  filter [.Type = "passenger"]
count;

query now();
# Query 3: Where have the vehicles with licenses from QueryLicence1 been at each  instant from QueryInstant1?
query now();
let Q3TBA =
  QueryLicences1 feed {l}
  loopsel[dataMcar_Licence_btree dataMcar exactmatch[.Licence_l]
    project[Licence, Moid] {ll}]
  loopjoin[dataMNtrip_Moid_btree dataMNtrip exactmatch[.Moid_ll]]
  QueryInstant1 feed {i}
  symmjoin [.Trip present ..Instant_i]
  projectextend[Instant_i, Licence_ll; Pos: val(.Trip atinstant .Instant_i)]
  sortby [Licence_ll asc, Instant_i asc]
consume;
query now();

# Query 4: Which license plate numbers belong to vehicles that have passed the points from QueryPoints?

query now();

let Q4TBA =
  QueryPointsNet feed projectextend[Id; Elem: gpoint2rect(.Pos)]
  loopjoin[dataMNtrip_TrajBoxNet windowintersectsS[.Elem]
  sort rdup dataMNtrip gettuples]
  project [Moid, Id]
  loopsel[fun(t:TUPLE) dataMcar_Moid_btree dataMcar exactmatch[attr(t, Moid)]
  projectextend[Licence; Id: attr(t,Id)]]
  sortby [Id asc, Licence asc]
  krdup[Id, Licence]
consume;

query now();

# Query 5: What is the minimum distance between places, where a vehicle with a license from QueryLicences1 and a vehicle with Licenses
# from QueryLicence2 have been?

query now();

let Q5h1TBA =
  QueryLicences1 feed project[Licence] {LL1}
  loopsel[ fun(t:TUPLE)
    dataMcar_Licence_btree dataMcar exactmatch[attr(t,Licence_LL1)] {CAR}
    loopsel[dataMNtrip_Moid_btree dataMNtrip exactmatch[.Moid_CAR]]
    projectextend[;Traj: trajectory(.Trip)]
    aggregateB[Traj; fun(L1: gline, L2: gline)
     L1 union L2; [const gline value ()]]
    feed namedtransformstream[Traxj]
    extend[Licence: attr(t,Licence_LL1)]
  ]
  projectextend[Licence; Trax: gline2line(.Traxj)]
  consume;

query now();

let Q5h2TBA =
  QueryLicences2 feed project[Licence] {LL1}
  loopsel[ fun(t:TUPLE)
    dataMcar_Licence_btree dataMcar exactmatch[attr(t,Licence_LL1)] {CAR}
    loopsel[dataMNtrip_Moid_btree dataMNtrip exactmatch[.Moid_CAR]]
    projectextend[;Traj: trajectory(.Trip)]
    aggregateB[Traj; fun(L1: gline, L2: gline)
     L1 union L2; [const gline value ()]]
    feed namedtransformstream[Traxj]
    extend[Licence: attr(t,Licence_LL1)]
  ]
  projectextend[Licence; Trax: gline2line(.Traxj)]
  consume;

query now();

let Q5TBA =
  Q5h1TBA feed {c1}
  Q5h2TBA feed {c2}
  product
  projectextend [Licence_c1, Licence_c2; Distance: distance(.Trax_c1, .Trax_c2)]
consume;

query now();

delete Q5h1TBA;
delete Q5h2TBA;


let Q10fTBA =
  QueryLicences1 feed
  loopsel[dataMcar_Licence_btree dataMcar exactmatch[.Licence]] {l}
  dataMNtrip feed
  symmjoin[.Moid_l = ..Moid]
  projectextend[Licence_l, Moid_l, Trip; BBox: mgpbbox(.Trip)]
  projectextend[Licence_l, Moid_l, Trip; TripA: mgpoint2mpoint(.Trip), Box: rectangle2((minD(.BBox,1) - 3.0), (maxD(.BBox,1) + 3.0), (minD(.BBox,2) - 3.0), (maxD(.BBox,2) + 3.0)), Ts: inst(initial(.Trip)), Te: inst(final(.Trip))]
  loopsel[fun(t:TUPLE) B_NETWORK dataMNtrip_MONTree dataMNtrip windowtimeintersectsS[attr(t,Box), attr(t,Ts), attr(t,Te)] sort dataMNtrip gettuplesdbl[Trip]
  filter[.Moid # attr(t,Moid_l)]
  projectextend[Moid; Licence_A:attr(t,Licence_l), Pos: attr(t,Trip) atperiods (deftime((distance(attr(t,TripA), mgpoint2mpoint(.Trip)) < 3.0) at TRUE))]
  filter[not(isempty(.Pos))]]
  sortby[Licence_A asc, Moid asc]
  groupby [Licence_A, Moid; AllPos: group feed aggregateB[Pos; fun(M1:mgpoint, M2:mgpoint) M1 union M2; [const mgpoint value()]]]
  project[Licence_A, Moid, AllPos]
  dataMcar feed {c}
  symmjoin[.Moid = ..Moid_c]
  project[Licence_A, Licence_c, AllPos]
consume;

# Query 6: What are the pairs of license plate numbers of "trucks", that have been as close as 10m or less to each other?

#query now();

let Q6h1TBA =
  dataMcar feed filter [.Type = "truck"]
  project [Licence, Moid] {c}
  loopjoin[dataMNtrip_Moid_btree dataMNtrip exactmatch[.Moid_c]]
  projectextend[;Licence: .Licence_c, ptrip: mgpoint2mpoint(.Trip), DT: deftime(.Trip)]
  projectextend[Licence, ptrip, DT; BBox: bbox(.ptrip)]
  projectextend[Licence, ptrip, DT; Box: rectangle2(
    (minD(.BBox,1) - 5.0), (maxD(.BBox,1) + 5.0), (minD(.BBox,2) - 5.0), (maxD(.BBox,2) + 5.0))]
consume;

#query now();

let Q6TBA =
  Q6h1TBA feed {c1}
  Q6h1TBA feed {c2}
  symmjoin[(.Box_c1 intersects ..Box_c2) and (.DT_c1 intersects ..DT_c2) and (.Licence_c1 < ..Licence_c2)]
  filter [everNearerThan(.ptrip_c1, .ptrip_c2, 10.0)]
  project [Licence_c1, Licence_c2]
  sortby [Licence_c1 asc, Licence_c2 asc]
  krdup [Licence_c1, Licence_c2]
consume;

# Query 7: What are the license plate numbers of the "passenger" cars that  have reached points from QueryPoints first of all "passenger"
# cars  during the complete observation period?
query now();

let Q7h1TBA =
  QueryPointsNet feed
  projectextend[Id, Pos; Prect: gpoint2rect(.Pos)]
  loopsel[fun(t:TUPLE) dataMNtrip_TrajBoxNet windowintersectsS[attr(t,Prect)]
  sort rdup dataMNtrip gettuples
  loopjoin [dataMcar_Moid_btree dataMcar exactmatch[.Moid]
  filter[.Type = "passenger"]
  project [Licence] {X}]
  projectextend [Licence_X; FirstTime: inst(initial(.Trip at attr(t,Pos))), Id: attr(t,Id)]]
 consume;

query now();

let Q7TBA =
  Q7h1TBA feed {a}
  Q7h1TBA feed project[Id, FirstTime]
  sortby [Id asc, FirstTime asc] groupby [Id; FirstTime: group feed min[FirstTime]]{f}
  symmjoin [(.Id_a = ..Id_f) and (.FirstTime_a <= ..FirstTime_f)]
  project [Id_a, Licence_X_a, FirstTime_a]
  sortby [Id_a asc, Licence_X_a asc, FirstTime_a asc]
  krdup [Id_a, Licence_X_a, FirstTime_a]
consume;

query now();

delete Q7h1TBA;

# Query 8: What are the overall traveled distances of the vehicles with  license plate numbers from QueryLicences1 during the periods from
# QueryPeriods1?
query now();

let Q8TBA =
  QueryLicences1 feed {l}
  loopjoin[dataMcar_Licence_btree dataMcar exactmatch[.Licence_l]]
  project[Licence, Moid]
  loopsel[fun(t:TUPLE) dataMNtrip_Moid_btree dataMNtrip exactmatch[attr(t, Moid)]
  projectextend[Trip; Licence: attr(t,Licence)]]
  QueryPeriods1 feed
  symmjoin [.Trip present ..Period]
  projectextend [Licence, Period, Id; Distance: length(.Trip atperiods .Period)]
  sortby [Id asc, Licence asc, Distance desc]
  groupby[Id, Period, Licence; Dist: group feed sum[Distance]]
  project[Licence, Period, Dist]
  sortby [Licence asc, Period asc]
consume;

# Query 9: What is the longest distance that was traveled by a vehicle during  each of the periods from QueryPeriods?
query now();

let Q9TBA =
  dataMNtrip feed {c}
  QueryPeriods feed
  filter[not(isempty(.Period))]{p}
  symmjoin[.Trip_c present ..Period_p]
  projectextend [Moid_c, Id_p, Period_p; Distance: length(.Trip_c atperiods .Period_p)]
  sortby [Id_p asc, Moid_c asc, Distance desc]
  groupby[Period_p, Moid_c; Dist: group feed sum[Distance]]
  groupby[Period_p; Dista: group feed max[Dist]]
  project[Period_p, Dista]
consume;

query now();

# Query 10: When and where did the vehicles with license plate numbers from QueryLicences1 meet other vehicles (distance < 3m) and
#   what are the latter licenses?
query now();
let Q10TBA =
  dataMNtrip feed
  projectextend [Moid; ptrip: mgpoint2mpoint(.Trip), Box3: mgpbbox(.Trip)] {c2}
  QueryLicences1 feed {l}
  loopjoin[dataMcar_Licence_btree dataMcar exactmatch[.Licence_l]]
  project [Licence, Moid] {a}
  loopjoin [dataMNtrip_Moid_btree dataMNtrip exactmatch [.Moid_a]]
  projectextend [Trip; Licence: .Licence_a, Moid: .Moid_a, BBox: mgpbbox(.Trip)]
  projectextend[Licence, Moid, Trip; ptrip: mgpoint2mpoint(.Trip), Box3: rectangle3((minD(.BBox,1) - 3.0), (maxD(.BBox,1) + 3.0), (minD(.BBox,2) - 3.0), (maxD(.BBox,2) + 3.0), minD(.BBox,3), maxD(.BBox,3))]{c1}
  symmjoin [.Box3_c2 intersects ..Box3_c1]
  filter [.Moid_c2 # .Moid_c1]
  projectextend [Licence_c1, Moid_c2, Trip_c1; Times: deftime((distance(.ptrip_c1, .ptrip_c2) < 3.0) at TRUE)]
  filter [not(isempty(.Times))]
  projectextend[Licence_c1, Moid_c2; Pos: .Trip_c1 atperiods .Times]
  filter [not(isempty(.Pos))]
  sortby [Licence_c1 asc, Moid_c2 asc]
  loopjoin[dataMcar_Moid_btree dataMcar exactmatch[.Moid_c2]]
  project [Licence_c1, Licence, Pos]
  sortby[Licence_c1 asc, Licence asc]
  groupby[Licence_c1, Licence; AllPos: group feed
    aggregateB[Pos; fun(M1:mgpoint, M2:mgpoint) M1 union M2; [const mgpoint value()]]]
  project[Licence_c1, Licence, AllPos]
consume;

#let Q10gTBA =
#  QueryLicences1 feed
#  loopsel[dataMcar_Licence_btree dataMcar exactmatch[.Licence]] {l}
#  dataMNtrip feed 
#  symmjoin[.Moid_l = ..Moid]
#  projectextendstream[Licence_l, Moid_l; Unit: units(.Trip)]
#  projectextend[Licence_l, Moid_l, Unit; BBox: unitboundingbox(.Unit)]
#  projectextend[Licence_l, Moid_l; Box: rectangle2((minD(.BBox,1) - 3.0), (maxD(.BBox,1) + 3.0), (minD(.BBox,2) - 3.0), (maxD(.BBox,2) + 3.0)), Ts: startunitinst(.Unit), Te: endunitinst(.Unit)]
#  loopsel[fun(t:TUPLE) B_NETWORK dataMNtrip_MONTree dataMNtrip windowtimeintersectsS[attr(t,Box), attr(t,Ts), attr(t,Te)] sort dataMNtrip gettuplesdbl[Trip]
#  projectextend[Moid; TripB: mpoint2mgpoint(.Trip), Moid_A: attr(t,Moid_l), Licence_A: attr(t,Licence_l), Trip: attr(t,Trip), TripA: attr(t,TripA)]
# filter[.Moid # ..Moid_A]
#  projectextend[Licence_A, Moid: Trip: .Trip atperiods (deftime((distance(.TripA, .TripB) < 3.0) at TRUE))]
#  filter[not(isempty(.Trip))]
#  sortby[Licence_A asc, Moid asc]
#  groupby [Licence_A, Moid; AllPos: group feed aggregateB[Pos; fun(M1:mgpoint, M2:mgpoint) M1 union M2; [const mgpoint value()]]]
#  project[Licence_A, Moid, AllPos]
#  dataMcar feed {c}
#  symmjoin[.Moid = ..Moid_c]
#  project[Licence_A, Licence, AllPos]]
#consume;

# Query 11: Which vehicles passed a point from QueryPoints1 at one of the instants from QueryInstant1?
query now();
let Q11TBA =
  QueryInstant1 feed {i}
  QueryPoints1Net feed projectextend[Id, Pos; Prect: gpoint2rect(.Pos)]{p}
  product
  loopsel[fun(t:TUPLE) dataMNtrip_BoxNet_timespace windowintersectsS[box3d(attr(t,Prect_p), attr(t,Instant_i))]
  sort rdup dataMNtrip gettuples
  projectextend [Moid; Id: attr(t,Id_p), Pos: attr(t,Pos_p), Instant: attr(t,Instant_i)]] {a}
  loopjoin[dataMcar_Moid_btree dataMcar exactmatch[.Moid_a]]
  project[Id_a, Instant_a, Licence]
  sortby [Id_a asc, Instant_a asc, Licence asc]
  krdup [Id_a, Instant_a, Licence]
consume;

query now();


query now();
# Query 12: Which vehicles met at a point from QueryPoints1 at an instant from  QueryInstant1?
query now();
let Q12h1TBA =
  QueryPoints1Net feed projectextend[Id, Pos; Prect: gpoint2rect(.Pos)]{p}
  QueryInstant1 feed {i}
  product
  loopsel[fun(t:TUPLE) dataMNtrip_BoxNet_timespace windowintersectsS[box3d(attr(t,Prect_p), attr(t,Instant_i))]
  sort rdup dataMNtrip gettuples
  projectextend [Moid; Id: attr(t,Id_p), Pos: attr(t,Pos_p), Instant: attr(t,Instant_i)]]{a}
  loopjoin[dataMcar_Moid_btree dataMcar exactmatch[.Moid_a]]
  projectextend[Moid, Licence; Id: .Id_a, Instant: .Instant_a]
consume;

query now();
let Q12TBA =
  Q12h1TBA feed {A}
  Q12h1TBA feed {B}
  symmjoin [(.Id_A = ..Id_B) and (.Instant_A = ..Instant_B) and (.Moid_A < ..Moid_B)]
  project [Id_A, Instant_A, Licence_A, Licence_B]
  sortby [Id_A asc, Instant_A asc, Licence_B asc]
consume;

query now();
delete Q12h1TBA;

# Query 13: Which vehicles traveled within one of the regions from QueryRegions1 during the periods from QueryPeriods1?
query now();
let Q13TBA =
  QueryPeriods1 feed filter[not(isempty(.Period))]{t}
  QueryRegions1Net feed filter [not(isempty(.Region))]
   projectextendstream[Id, Region; Rrect: routeintervals(.Region)]{r}
  product
  loopsel[fun(t:TUPLE) dataMNtrip_BoxNet_timespace windowintersectsS[box3d(attr(t,Rrect_r), attr(t,Period_t))]
  sort rdup dataMNtrip gettuples
  filter[not(isempty((.Trip atperiods (attr(t,Period_t))) at (attr(t,Region_r))))]
  projectextend [Moid; Id: attr(t,Id_r), Period: attr(t,Period_t)]]{a}
  loopjoin [dataMcar_Moid_btree dataMcar exactmatch[.Moid_a]]
  projectextend[Licence; Id: .Id_a, Period: .Period_a]
  sortby [Id asc, Period asc, Licence asc]
  krdup [Id, Period, Licence]
consume;

query now();


query now();
# Query 14: Which vehicles traveled within one of the regions from QueryRegions1 at one of the instants from QueryInstant1?
query now();
let Q14TBA =
  QueryRegions1Net feed filter[not(isempty(.Region))] projectextendstream[Id, Region; Brect: routeintervals(.Region)]{r}
  QueryInstant1 feed {i}
  product
  loopsel[fun(t:TUPLE) dataMNtrip_BoxNet_timespace windowintersectsS[box3d(attr(t,Brect_r), attr(t,Instant_i))]
  sort rdup dataMNtrip gettuples
  filter[(val(.Trip atinstant (attr(t,Instant_i)))) inside (attr(t,Region_r))]
  projectextend [Moid;Instant: attr(t,Instant_i), Id: attr(t,Id_r)]]{a}
  loopjoin[dataMcar_Moid_btree dataMcar exactmatch [.Moid_a]]
  projectextend[Licence; Id: .Id_a, Instant: .Instant_a]
  sortby [Id asc, Instant asc, Licence asc]
  krdup[Id, Instant, Licence]
  project[Id, Instant, Licence]
consume;

query now();

query now();
# Query 15: Which vehicles passed a point from QueryPoints1 during a period from QueryPeriods1?
query now();
let Q15TBA =
  QueryPoints1Net feed projectextend [Id, Pos; Prect: gpoint2rect(.Pos)] {p}
  QueryPeriods1 feed filter[not(isempty(.Period))]{t}
  product
  loopsel[fun(t:TUPLE) dataMNtrip_BoxNet_timespace windowintersectsS[box3d(attr(t,Prect_p), attr(t,Period_t))]
  sort rdup dataMNtrip gettuples
  filter[(.Trip atperiods (attr(t,Period_t))) passes (attr(t,Pos_p))]
  projectextend [Moid;Period: attr(t,Period_t), Id: attr(t,Id_p)]]{a}
  loopjoin[dataMcar_Moid_btree dataMcar exactmatch [.Moid_a]]
  projectextend[Licence; Id: .Id_a, Period: .Period_a]
  sortby [Id asc, Period asc, Licence asc]
  krdup[Id, Period, Licence]
  project[Licence, Id, Period]
consume;

query now();

# Query 16: List the pairs of licenses for vehicles the first from  QueryLicences1, the second from QueryLicences2, where the corresponding
# vehicles are both present within a Region from  QueryRegions1 during a period from QueryPeriod1, but do not meet  each other
# there and then.
query now();
let Q16h1TBA =
  QueryLicences1 feed {l}
  loopjoin [dataMcar_Licence_btree dataMcar exactmatch[.Licence_l]]
  project [Licence, Moid] {a}
  loopjoin[dataMNtrip_Moid_btree dataMNtrip exactmatch[.Moid_a]]
  project[Licence_a, Trip] {c}
  QueryRegions1Net feed filter[not(isempty(.Region))]{r}
  symmjoin [.Trip_c passes ..Region_r]
  projectextend[Licence_a_c, Id_r; Trip: .Trip_c at .Region_r]
  QueryPeriods1 feed {p}
  symmjoin [.Trip present ..Period_p]
  projectextend[Id_r, Id_p, Period_p; Licence: .Licence_a_c, Trip: .Trip atperiods .Period_p]
  filter [no_components(.Trip) > 0]
consume;

query now();
let Q16h2TBA =
  QueryLicences2 feed {l}
  loopjoin [dataMcar_Licence_btree dataMcar exactmatch[.Licence_l]]
  project [Licence, Moid] {a}
  loopjoin[dataMNtrip_Moid_btree dataMNtrip exactmatch[.Moid_a]]
  project[Licence_a, Trip] {c}
  QueryRegions1Net feed filter[not(isempty(.Region))]{r}
  symmjoin [.Trip_c passes ..Region_r]
  projectextend[Licence_a_c, Id_r; Trip: .Trip_c at .Region_r]
  QueryPeriods1 feed {p}
  symmjoin [.Trip present ..Period_p]
  projectextend[Id_r, Id_p, Period_p; Licence: .Licence_a_c, Trip: .Trip atperiods .Period_p]
  filter [no_components(.Trip) > 0]
consume;

query now();
let Q16TBA =
  Q16h1TBA feed {a}
  Q16h2TBA feed {b}
  symmjoin[(.Id_r_a = ..Id_r_b) and (.Id_p_a = ..Id_p_b) and (.Licence_a # ..Licence_b) and
  (isempty(deftime(intersection(.Trip_a,..Trip_b))))]
  project [Id_r_a, Id_p_a, Period_p_a, Licence_a, Licence_b]
  sortby [Id_r_a asc, Id_p_a asc, Licence_a asc, Licence_b asc]
  krdup [Id_r_a, Id_p_a, Licence_a, Licence_b]
  project[Id_r_a, Period_p_a, Licence_a, Licence_b]
consume;

query now();
delete Q16h1TBA;
delete Q16h2TBA;

#Query 17: Which points from QueryPoints have been visited by a maximum number of different vehicles?
query now();
let Q17h1TBA =
  QueryPointsNet feed
  projectextend[Id; Elem: gpoint2rect(.Pos)]
  loopsel[fun(t:TUPLE) dataMNtrip_TrajBoxNet windowintersectsS[attr(t,Elem)]
  sort rdup dataMNtrip gettuples
  projectextend [Moid; Id_p: attr(t,Id)]]
  sortby [Id_p asc, Moid asc]
  krdup[Id_p, Moid]
  groupby[Id_p; Hits: group feed count]
consume;

query now();
let Q17TBA =
  Q17h1TBA feed
  filter [.Hits = (Q17h1TBA feed max[Hits])]
  project [Id_p, Hits]
consume;

query now();
delete Q17h1TBA;


query now();
#alternative Query

let Q3aTBA =
  QueryLicences1 feed {l}
  loopsel[dataMcar_Licence_btree dataMcar exactmatch[.Licence_l]
    project[Licence, Moid] {ll}]
  loopjoin[dataMNtrip_Moid_btree dataMNtrip exactmatch[.Moid_ll]]
  QueryInstant1 feed {i}
  symmjoin [.Trip present ..Instant_i]
  projectextend[Instant_i, Licence_ll; Pos: val(.Trip atinstant .Instant_i)]
consume;


let Q5aTBA =
  QueryLicences1 feed project[Licence] {LL1}
  loopsel[ fun(t:TUPLE)
    dataMcar_Licence_btree dataMcar exactmatch[attr(t,Licence_LL1)] {CAR}
    loopsel[dataMNtrip_Moid_btree dataMNtrip exactmatch[.Moid_CAR]]
    projectextend[;Traj: trajectory(.Trip)]
    aggregateB[Traj; fun(L1: gline, L2: gline) L1 union L2; [const gline value ()]]
    feed namedtransformstream[Traxj]
    extend[Licence: attr(t,Licence_LL1)]
  ]
  projectextend[Licence; Trax: gline2line(.Traxj)]{c1}
  QueryLicences2 feed project[Licence] {LL2}
  loopsel[ fun(s:TUPLE)
    dataMcar_Licence_btree dataMcar exactmatch[attr(s,Licence_LL2)] {CAR}
    loopsel[dataMNtrip_Moid_btree dataMNtrip exactmatch[.Moid_CAR]]
    projectextend[;Traj: trajectory(.Trip)]
    aggregateB[Traj; fun(L3: gline, L4: gline) L3 union L4; [const gline value ()]]
    feed namedtransformstream[Traxj]
    extend[Licence: attr(s,Licence_LL2)]
  ]
  projectextend[Licence; Trax: gline2line(.Traxj)]{c2}
  product
  projectextend [Licence_c1, Licence_c2; Distance: distance(.Trax_c1, .Trax_c2)]
consume;


let Q6aTBA =
  Q6h1TBA feed {c1}
  Q6h1TBA feed {c2}
  symmjoin[(.Box_c1 intersects ..Box_c2) and (.DT_c1 intersects ..DT_c2) and (.Licence_c1 < ..Licence_c2) and (everNearerThan(.ptrip_c1, ..ptrip_c2, 10.0))]
  project [Licence_c1, Licence_c2]
  sortby [Licence_c1 asc, Licence_c2 asc]
  krdup [Licence_c1, Licence_c2]
consume;


#query now();
delete Q6h1TBA;


#alternative Query

query now();

let Q7ah1TBA =
  QueryPointsNet feed
  projectextend[Id, Pos; Prect: gpoint2rect(.Pos)]
  loopsel[fun(t:TUPLE) dataMNtrip_TrajBoxNet windowintersectsS[attr(t,Prect)]
  sort rdup dataMNtrip gettuples
  loopjoin[dataMcar_Moid_btree dataMcar exactmatch [.Moid]
  filter[.Type = "passenger"]
  project[Licence] {X}]
  projectextend[ Licence_X;TimeAtPos: inst(initial(.Trip at attr(t,Pos))), Id: attr(t, Id)]]
  sortby [Id asc, TimeAtPos asc]
consume;

query now();

let Q7aTBA =
  Q7ah1TBA feed {a}
  Q7ah1TBA feed
    groupby [Id; FirstTime: group feed min[TimeAtPos]]{b}
  symmjoin[(.Id_a = ..Id_b) and (.TimeAtPos_a <= ..FirstTime_b)]
  project [Id_a, Licence_X_a]
  sortby [Id_a asc, Licence_X_a asc]
  krdup [Id_a, Licence_X_a]
 consume;

delete Q7ah1TBA;
delete Q7ah2TBA;

#alternative

let Q8aTBA =
  QueryLicences1 feed {l}
  loopjoin[dataMcar_Licence_btree dataMcar exactmatch[.Licence_l]]
  project[Licence, Moid]
  loopsel[fun(t:TUPLE) dataMNtrip_Moid_btree dataMNtrip exactmatch[attr(t, Moid)]
  projectextend[Trip; Licence: attr(t,Licence)]]
  QueryPeriods1 feed
  symmjoin [.Trip present ..Period]
  projectextend [Licence, Period, Id; Distance: length(.Trip atperiods .Period)]
  sortby [Id asc, Licence asc, Distance desc]
  groupby[Id, Period, Licence; Dist: group feed sum[Distance]]
  project[Licence, Period, Dist]
consume;

query now();

let Q10aTBA =
  dataMNtrip feed
  projectextend [Moid; ptrip: mgpoint2mpoint(.Trip), Box3: mgpbbox(.Trip)] {c2}
  QueryLicences1 feed {l}
  loopjoin[dataMcar_Licence_btree dataMcar exactmatch[.Licence_l]]
  project [Licence, Moid] {a}
  loopjoin [dataMNtrip_Moid_btree dataMNtrip exactmatch [.Moid_a]]
  projectextend [Trip; Licence: .Licence_a, Moid: .Moid_a, BBox: mgpbbox(.Trip)]
  projectextend[Licence, Moid, Trip;ptrip: mgpoint2mpoint(.Trip), Box3: rectangle3((minD(.BBox,1) - 3.0), (maxD(.BBox,1) + 3.0), (minD(.BBox,2) - 3.0), (maxD(.BBox,2) + 3.0), minD(.BBox,3), maxD(.BBox,3))]{c1}
  symmjoin [(.Box3_c2 intersects ..Box3_c1) and (.Moid_c2 # ..Moid_c1)]
  projectextend [Licence_c1, Moid_c2; Pos: .Trip_c1 atperiods (deftime((distance(.ptrip_c1, .ptrip_c2) < 3.0) at TRUE))]
  filter [not(isempty(.Pos))]
  sortby [Licence_c1 asc, Moid_c2 asc]
  loopjoin[dataMcar_Moid_btree dataMcar exactmatch[.Moid_c2]]
  project [Licence_c1, Licence, Pos]
  sortby[Licence_c1 asc, Licence asc]
  groupby[Licence_c1, Licence; AllPos: group feed
    aggregateB[Pos; fun(M1:mgpoint, M2:mgpoint) M1 union M2; [const mgpoint value()]]]
  project[Licence_c1, Licence, AllPos]
consume;

query now();
#alternativ Query
query now();

let Q11aTBA =
  QueryInstant1 feed {i}
  QueryPoints1Net feed projectextend[Id, Pos; Prect: gpoint2rect(.Pos)]{p}
  product
  projectextend [Instant_i, Id_p, Pos_p; BBox: box3d(.Prect_p, .Instant_i)]
  loopsel[fun(t:TUPLE) dataMNtrip_BoxNet_timespace windowintersectsS[attr(t,BBox)]
  sort rdup dataMNtrip gettuples
  projectextend [Moid; Id: attr(t,Id_p), Instant: attr(t,Instant_i)]]{a}
  loopjoin[dataMcar_Moid_btree dataMcar exactmatch[.Moid_a]]
  project[Id_a, Instant_a, Licence]
  sortby [Id_a asc, Instant_a asc, Licence asc]
  krdup [Id_a, Instant_a, Licence]
consume;


#alternative Query
query now();
let Q12ah1TBA =
  QueryPoints1Net feed projectextend[Id, Pos; Prect: gpoint2rect(.Pos)]{p}
  QueryInstant1 feed {i}
  product
  projectextend [Id_p, Pos_p, Instant_i; Box: box3d(.Prect_p, .Instant_i)]
  loopsel[fun(t:TUPLE) dataMNtrip_BoxNet_timespace windowintersectsS[attr(t,Box)]
  sort rdup dataMNtrip gettuples
  projectextend [Moid; Id: attr(t,Id_p), Instant: attr(t,Instant_i)]]{a}
  loopjoin[dataMcar_Moid_btree dataMcar exactmatch[.Moid_a]]
  projectextend[Moid, Licence; Id: .Id_a, Instant: .Instant_a]
consume;

query now();
let Q12aTBA =
  Q12ah1TBA feed {A}
  Q12ah1TBA feed {B}
  symmjoin [(.Id_A = ..Id_B) and (.Instant_A = ..Instant_B) and (.Moid_A < ..Moid_B)]
  project [Id_A, Instant_A, Licence_A, Licence_B]
  sortby [Id_A asc, Instant_A asc, Licence_B asc]
consume;

query now();

delete Q12ah1TBA;

#alternative Query
query now();

let Q13aTBA =
  QueryPeriods1 feed filter[not(isempty(.Period))]{t}
  QueryRegions1Net feed filter [not(isempty(.Region))]
   projectextendstream[Id, Region; Rrect: routeintervals(.Region)]{r}
  product
  projectextend[Id_r, Region_r, Period_t; Box: box3d(.Rrect_r, .Period_t)]
  loopsel[fun(t:TUPLE) dataMNtrip_BoxNet_timespace windowintersectsS[attr(t,Box)]
  sort rdup dataMNtrip gettuples
  filter[not(isempty((.Trip atperiods (attr(t,Period_t))) at (attr(t,Region_r))))]
  projectextend [Moid; Id: attr(t,Id_r), Period: attr(t,Period_t)]]{a}
  loopjoin [dataMcar_Moid_btree dataMcar exactmatch[.Moid_a]]
  projectextend[Licence; Id: .Id_a, Period: .Period_a]
  sortby [Id asc, Period asc, Licence asc]
  krdup [Id, Period, Licence]
consume;

#alternative Query
query now();
let Q14aTBA =
  QueryRegions1Net feed filter[not(isempty(.Region))] projectextendstream[Id, Region; Brect: routeintervals(.Region)]{r}
  QueryInstant1 feed {i}
  product
  projectextend[Id_r, Region_r, Instant_i; Box: box3d(.Brect_r, .Instant_i)]
  loopsel[fun(t:TUPLE) dataMNtrip_BoxNet_timespace windowintersectsS[attr(t,Box)]
  sort rdup dataMNtrip gettuples
   filter[(val(.Trip atinstant (attr(t,Instant_i)))) inside (attr(t,Region_r))]
  projectextend [Moid;Instant: attr(t,Instant_i), Id: attr(t,Id_r)]]{a}
  loopjoin[dataMcar_Moid_btree dataMcar exactmatch [.Moid_a]]
  projectextend[Licence; Id: .Id_a, Instant: .Instant_a]
  sortby [Id asc, Instant asc, Licence asc]
  krdup[Id, Instant, Licence]
  project[Licence, Instant, Id]
consume;

#alternativ Query
query now();
let Q15aTBA =
  QueryPoints1Net feed projectextend [Id, Pos; Prect: gpoint2rect(.Pos)] {p}
  QueryPeriods1 feed filter[not(isempty(.Period))]{t}
  product
  projectextend[Id_p, Pos_p, Period_t; Box: box3d(.Prect_p, .Period_t)]
  loopsel[fun(t:TUPLE) dataMNtrip_BoxNet_timespace windowintersectsS[attr(t,Box)]
  sort rdup dataMNtrip gettuples
  filter[(.Trip atperiods (attr(t,Period_t))) passes (attr(t,Pos_p))]
  projectextend [Moid;Period: attr(t,Period_t), Id: attr(t,Id_p)]]{a}
  loopjoin[dataMcar_Moid_btree dataMcar exactmatch [.Moid_a]]
  projectextend[Licence; Id: .Id_a, Period: .Period_a]
  sortby [Id asc, Period asc, Licence asc]
  krdup[Id, Period, Licence]
  project[Licence, Id, Period]
consume;


let Q16ah1TBA =
  QueryLicences1 feed {l}
  loopjoin [dataMcar_Licence_btree dataMcar exactmatch[.Licence_l]] {a}
  loopjoin[dataMNtrip_Moid_btree dataMNtrip exactmatch[.Moid_a]]
  QueryRegions1Net feed filter[not(isempty(.Region))]{r}
  symmjoin [.Trip passes ..Region_r]
  projectextend[Licence_a, Id_r; Trip: .Trip at .Region_r]
  QueryPeriods1 feed {p}
  symmjoin [.Trip present ..Period_p]
  projectextend[Id_r, Id_p, Period_p; Licence: .Licence_a, Trip: .Trip atperiods .Period_p]
  filter [no_components(.Trip) > 0]
consume;

query now();
let Q16ah2TBA =
  QueryLicences2 feed {l}
  loopjoin [dataMcar_Licence_btree dataMcar exactmatch[.Licence_l]]{a}
  loopjoin[dataMNtrip_Moid_btree dataMNtrip exactmatch[.Moid_a]]
  QueryRegions1Net feed filter[not(isempty(.Region))]{r}
  symmjoin [.Trip passes ..Region_r]
  projectextend[Licence_a, Id_r; Trip: .Trip at .Region_r]
  QueryPeriods1 feed {p}
  symmjoin [.Trip present ..Period_p]
  projectextend[Id_r, Id_p, Period_p; Licence: .Licence_a, Trip: .Trip atperiods .Period_p]
  filter [no_components(.Trip) > 0]
consume;

query now();
let Q16aTBA =
  Q16ah1TBA feed {a}
  Q16ah2TBA feed {b}
  symmjoin[(.Id_r_a = ..Id_r_b) and (.Id_p_a = ..Id_p_b) and (.Licence_a # ..Licence_b) and
  (isempty(deftime(intersection(.Trip_a,..Trip_b))))]
  project [Id_r_a, Id_p_a, Period_p_a, Licence_a, Licence_b]
  sortby [Id_r_a asc, Id_p_a asc, Licence_a asc, Licence_b asc]
  krdup [Id_r_a, Id_p_a, Licence_a, Licence_b]
consume;

query now();
delete Q16ah1TBA;
delete Q16ah2TBA;


#alternative Query
query now();

let Q6bh1TBA =
  dataMcar feed filter [.Type = "truck"]
  project [Licence, Moid] {c}
  loopjoin[dataMNtrip_Moid_btree dataMNtrip exactmatch[.Moid_c]]
  projectextend [;Licence: .Licence_c, BBox: mgpbbox(.Trip), ptrip: mgpoint2mpoint(.Trip)]
  projectextend[Licence, ptrip; Box: rectangle3(
    (minD(.BBox,1) - 5.0), (maxD(.BBox,1) + 5.0), (minD(.BBox,2) - 5.0), (maxD(.BBox,2) + 5.0), minD(.BBox,3), maxD(.BBox,3))]
consume;

query now();

let Q6bTBA =
  Q6bh1TBA feed {c1}
  Q6bh1TBA feed {c2}
  symmjoin[(.Box_c1 intersects ..Box_c2) and (.Licence_c1 < ..Licence_c2)]
  filter [everNearerThan(.ptrip_c1, .ptrip_c2, 10.0)]
  project [Licence_c1, Licence_c2]
  sortby [Licence_c1 asc, Licence_c2 asc]
  krdup [Licence_c1, Licence_c2]
consume;

query now();
delete Q6bh1TBA;


query now();

let Q7bTBA =
  QueryPointsNet feed
  projectextend[Id, Pos; Prect: gpoint2rect(.Pos)]
  loopsel[fun(t:TUPLE) dataMNtrip_TrajBoxNet windowintersectsS[attr(t,Prect)]
  sort rdup dataMNtrip gettuples
  loopjoin[dataMcar_Moid_btree dataMcar exactmatch [.Moid]
  filter[.Type = "passenger"]
  project[Licence] {X}]
  projectextend[ Licence_X;TimeAtPos: inst(initial(.Trip at attr(t,Pos))), Id: attr(t, Id)]]
  sortby [Id asc, TimeAtPos asc] {b}
  QueryPointsNet feed
  projectextend[Id, Pos; Prect: gpoint2rect(.Pos)]
  loopsel[fun(s:TUPLE) dataMNtrip_TrajBoxNet windowintersectsS[attr(s,Prect)]
  sort rdup dataMNtrip gettuples
  loopjoin[dataMcar_Moid_btree dataMcar exactmatch [.Moid]
  filter[.Type = "passenger"]
  project[Licence] {X}]
  projectextend[ Licence_X;TimeAtPos: inst(initial(.Trip at attr(s,Pos))), Id: attr(s, Id)]]
  sortby [Id asc, TimeAtPos asc]
  groupby [Id; FirstTime: group feed min[TimeAtPos]] {a}
  symmjoin[(..Id_a = .Id_b) and (.TimeAtPos_b <= ..FirstTime_a)]
  project [Id_a, Licence_X_b]
  sortby [Id_a asc, Licence_X_b asc]
  krdup [Id_a, Licence_X_b]
 consume;

query now();

let Q10bTBA =
  QueryLicences1 feed {l}
  loopjoin[dataMcar_Licence_btree dataMcar exactmatch[.Licence_l]]
  project [Licence, Moid] {a}
  loopjoin [dataMNtrip_Moid_btree dataMNtrip exactmatch [.Moid_a]]
  projectextend [Trip; Licence: .Licence_a, Moid: .Moid_a, BBox: mgpbbox(.Trip)]
  projectextend[Licence, Moid, Trip;ptrip: mgpoint2mpoint(.Trip), Box: rectangle3((minD(.BBox,1) - 3.0), (maxD(.BBox,1) + 3.0), (minD(.BBox,2) - 3.0), (maxD(.BBox,2) + 3.0), minD(.BBox,3), maxD(.BBox,3))] {a}
  loopjoin[fun(t:TUPLE) dataMNtrip_SpatioTemp windowintersectsS[attr(t,Box_a)]
  sort rdup dataMNtrip gettuples
  filter [.Moid # attr(t,Moid_a)]]
  projectextend[Moid, Licence_a, Trip_a, ptrip_a; ptrip_b: mgpoint2mpoint(.Trip)]
  projectextend [Licence_a, Moid, Trip_a; Times: deftime((distance(.ptrip_a, .ptrip_b) < 3.0) at TRUE)]
  filter [not(isempty(.Times))]
  projectextend[Licence_a, Moid; Pos: .Trip_a atperiods .Times]
  filter [not(isempty(.Pos))]{a}
  loopjoin[dataMcar_Moid_btree dataMcar exactmatch[.Moid_a]]
  project [Licence_a_a, Licence, Pos_a]
  sortby [Licence_a_a asc, Licence asc]
  groupby [Licence_a_a, Licence; AllPos: group feed
    aggregateB[Pos_a; fun(M1:mgpoint, M2:mgpoint) M1 union M2; [const mgpoint value()]]]
  project[Licence_a_a, Licence, AllPos]
consume;


query now();

let Q13bTBA =
  QueryPeriods1 feed filter[not(isempty(.Period))]{t}
  QueryRegions1Net feed filter [not(isempty(.Region))]
   projectextendstream[Id, Region; Rrect: routeintervals(.Region)]{r}
  product
  projectextend[Id_r, Region_r, Period_t; Box: box3d(.Rrect_r, .Period_t)]
  loopsel[fun(t:TUPLE) dataMNtrip_BoxNet_timespace windowintersectsS[attr(t,Box)]
  sort rdup dataMNtrip gettuples {a}
  filter[not(isempty((.Trip_a atperiods (attr(t,Period_t))) at (attr(t,Region_r))))]
  loopjoin [dataMcar_Moid_btree dataMcar exactmatch[.Moid_a]]
  projectextend[Licence; Id: attr(t,Id_r), Period: attr(t,Period_t)]]
  sortby [Id asc, Period asc, Licence asc]
  krdup [Id, Period, Licence]
consume;

let Q14bTBA =
  QueryRegions1Net feed filter[not(isempty(.Region))] projectextendstream[Id, Region; Brect: routeintervals(.Region)]{r}
  QueryInstant1 feed {i}
  product
  projectextend[Id_r, Region_r, Instant_i; Box: box3d(.Brect_r, .Instant_i)]
  loopsel[fun(t:TUPLE) dataMNtrip_BoxNet_timespace windowintersectsS[attr(t,Box)]
  sort rdup dataMNtrip gettuples
  filter[(val(.Trip atinstant (attr(t,Instant_i)))) inside (attr(t,Region_r))]
  projectextend [Moid;Instant: attr(t,Instant_i), Id: attr(t,Id_r)]]{a}
  loopjoin[dataMcar_Moid_btree dataMcar exactmatch [.Moid_a]]
  projectextend[Licence; Id: .Id_a, Instant: .Instant_a]
  sortby [Id asc, Instant asc, Licence asc]
  krdup[Id, Instant, Licence]
consume;

let Q15bTBA =
  QueryPoints1Net feed projectextend [Id, Pos; Prect: gpoint2rect(.Pos)] {p}
  QueryPeriods1 feed filter[not(isempty(.Period))]{t}
  product
  projectextend[Id_p, Pos_p, Period_t; Box: box3d(.Prect_p, .Period_t)]
  loopsel[fun(t:TUPLE) dataMNtrip_BoxNet_timespace windowintersectsS[attr(t,Box)]
  sort rdup dataMNtrip gettuples
  filter[(.Trip atperiods (attr(t,Period_t))) passes (attr(t,Pos_p))]
  projectextend [Moid;Period: attr(t,Period_t), Id: attr(t,Id_p)]]{a}
  loopjoin[dataMcar_Moid_btree dataMcar exactmatch [.Moid_a]]
  projectextend[Licence; Id: .Id_a, Period: .Period_a]
  sortby [Id asc, Period asc, Licence asc]
  krdup[Id, Period, Licence]
consume;


let Q16bTBA =
  QueryLicences1 feed {l}
  loopjoin [dataMcar_Licence_btree dataMcar exactmatch[.Licence_l]] {a}
  loopjoin[dataMNtrip_Moid_btree dataMNtrip exactmatch[.Moid_a]]
  QueryRegions1Net feed filter[not(isempty(.Region))]{r}
  symmjoin [.Trip passes ..Region_r]
  projectextend[Licence_a, Id_r; Trip: .Trip at .Region_r]
  QueryPeriods1 feed {p}
  symmjoin [.Trip present ..Period_p]
  projectextend[Id_r, Id_p, Period_p; Licence: .Licence_a, Trip: .Trip atperiods .Period_p]
  filter [no_components(.Trip) > 0]{a}
  QueryLicences2 feed {l}
  loopjoin [dataMcar_Licence_btree dataMcar exactmatch[.Licence_l]]{a}
  loopjoin[dataMNtrip_Moid_btree dataMNtrip exactmatch[.Moid_a]]
  QueryRegions1Net feed filter[not(isempty(.Region))]{r}
  symmjoin [.Trip passes ..Region_r]
  projectextend[Licence_a, Id_r; Trip: .Trip at .Region_r]
  QueryPeriods1 feed {p}
  symmjoin [.Trip present ..Period_p]
  projectextend[Id_r, Id_p, Period_p; Licence: .Licence_a, Trip: .Trip atperiods .Period_p]
  filter [no_components(.Trip) > 0]{b}
  symmjoin[(.Id_r_a = ..Id_r_b) and (.Id_p_a = ..Id_p_b) and (.Licence_a # ..Licence_b) and
  (isempty(deftime(intersection(.Trip_a,..Trip_b))))]
  project [Id_r_a, Id_p_a, Period_p_a, Licence_a, Licence_b]
  sortby [Id_r_a asc, Id_p_a asc, Licence_a asc, Licence_b asc]
  krdup [Id_r_a, Id_p_a, Licence_a, Licence_b]
consume;


#alternative

let Q6ch1TBA =
  dataMcar feed filter [.Type = "truck"]
  project [Licence, Moid] {c}
  loopjoin[dataMNtrip_Moid_btree dataMNtrip exactmatch[.Moid_c]]
  projectextend [;Licence: .Licence_c, Trajline: gline2line(trajectory(.Trip)), DT: deftime(.Trip), ptrip: mgpoint2mpoint(.Trip)]
consume;

#query now();

let Q6cTBA =
  Q6ch1TBA feed {c1}
  Q6ch1TBA feed {c2}
  symmjoin[(.DT_c1 intersects ..DT_c2) and  (.Licence_c1 < ..Licence_c2) and (distance(.Trajline_c1,..Trajline_c2)<=10.0)]
  filter [everNearerThan(.ptrip_c1, .ptrip_c2, 10.0)]
  project [Licence_c1, Licence_c2]
  sortby [Licence_c1 asc, Licence_c2 asc]
  krdup [Licence_c1, Licence_c2]
consume;

query now();

let Q7cTBA =
  QueryPointsNet feed
  projectextend[Id, Pos; Prect: gpoint2rect(.Pos)]
  loopsel[fun(t:TUPLE) dataMNtrip_TrajBoxNet windowintersectsS[attr(t,Prect)]
  sort rdup dataMNtrip gettuples
  loopsel[fun(s:TUPLE) dataMcar_Moid_btree dataMcar exactmatch [attr(s,Moid)]
  filter[.Type = "passenger"]
  projectextend[ Licence;TimeAtPos: inst(initial(attr(s,Trip) at attr(t,Pos))), Id: attr(t, Id)]]]
  sortby [Id asc, TimeAtPos asc] {b}
  QueryPointsNet feed
  projectextend[Id, Pos; Prect: gpoint2rect(.Pos)]
  loopsel[fun(u:TUPLE) dataMNtrip_TrajBoxNet windowintersectsS[attr(u,Prect)]
  sort rdup dataMNtrip gettuples {a}
  loopsel[fun(r:TUPLE) dataMcar_Moid_btree dataMcar exactmatch [attr(r,Moid_a)]
  filter[.Type = "passenger"]
  projectextend[Licence;TimeAtPos: inst(initial(attr(r,Trip_a) at attr(u,Pos))), Id: attr(u, Id)]]]
  sortby [Id asc, TimeAtPos asc]
  groupby [Id; FirstTime: group feed min[TimeAtPos]]{a}
  symmjoin[(..Id_a = .Id_b) and (.TimeAtPos_b <= ..FirstTime_a)]
  project [Id_a, Licence_b]
  sortby [Id_a asc, Licence_b asc]
  krdup [Id_a, Licence_b]
 consume;


let Q10cTBA =
  QueryLicences1 feed {l}
  loopjoin[dataMcar_Licence_btree dataMcar exactmatch[.Licence_l]]
  project [Licence, Moid] {a}
  loopjoin [dataMNtrip_Moid_btree dataMNtrip exactmatch [.Moid_a]]
  projectextend [Trip; Licence: .Licence_a, Moid: .Moid_a,  BBox: mgpbbox(.Trip)]
  projectextend[Licence, Moid, Trip;ptrip: mgpoint2mpoint(.Trip), Box: rectangle3((minD(.BBox,1) - 3.0), (maxD(.BBox,1) + 3.0), (minD(.BBox,2) - 3.0), (maxD(.BBox,2) + 3.0), minD(.BBox,3), maxD(.BBox,3))] {a}
  loopjoin[fun(t:TUPLE) dataMNtrip_SpatioTemp windowintersectsS[attr(t,Box_a)]
  sort rdup dataMNtrip gettuples
  filter [.Moid # attr(t,Moid_a)]]
  projectextend [Licence_a, Moid; Pos: .Trip_a atperiods (deftime((distance(.ptrip_a, mgpoint2mpoint(.Trip)) < 3.0) at TRUE))]
  filter [not(isempty(.Pos))]{a}
  loopjoin[dataMcar_Moid_btree dataMcar exactmatch[.Moid_a]]
  project [Licence_a_a, Licence, Pos_a]
  sortby [Licence_a_a asc, Licence asc]
  groupby [Licence_a_a, Licence; AllPos: group feed
    aggregateB[Pos_a; fun(M1:mgpoint, M2:mgpoint) M1 union M2; [const mgpoint value()]]]
  project[Licence_a_a, Licence, AllPos]
consume;

query now();
query now();

let Q13cTBA =
  dataMNtrip feed {c}
  QueryRegions1Net feed filter[not(isempty(.Region))] {r}
  symmjoin[.Trip_c passes ..Region_r]
  projectextend[Moid_c, Id_r; Trip: .Trip_c at .Region_r]
  QueryPeriods1 feed filter[not(isempty(.Period))]{p}
  symmjoin [.Trip present ..Period_p]
  loopjoin [dataMcar_Moid_btree dataMcar exactmatch[.Moid_c]]
  project[Licence, Id_r, Period_p]
  sortby [Id_r asc, Period_p asc, Licence asc]
  krdup [Id_r, Period_p, Licence]
consume;

let Q14cTBA =
  QueryRegions1Net feed filter[not(isempty(.Region))] projectextendstream[Id, Region; Brect: routeintervals(.Region)]{r}
  QueryInstant1 feed {i}
  product
  projectextend[Id_r, Region_r, Instant_i; Box: box3d(.Brect_r, .Instant_i)]
  loopsel[fun(t:TUPLE) dataMNtrip_BoxNet_timespace windowintersectsS[attr(t,Box)]
  sort rdup dataMNtrip gettuples {a}
   filter[(val(.Trip_a atinstant (attr(t,Instant_i)))) inside (attr(t,Region_r))]
  loopjoin[dataMcar_Moid_btree dataMcar exactmatch [.Moid_a]]
  projectextend[Licence; Id: attr(t,Id_r), Instant: attr(t,Instant_i)]]
  sortby [Id asc, Instant asc, Licence asc]
  krdup[Id, Instant, Licence]
consume;

let Q15cTBA =
  QueryPoints1Net feed projectextend [Id, Pos; Prect: gpoint2rect(.Pos)] {p}
  QueryPeriods1 feed filter[not(isempty(.Period))]{t}
  product
  projectextend[Id_p, Pos_p, Period_t; Box: box3d(.Prect_p, .Period_t)]
  loopsel[fun(t:TUPLE) dataMNtrip_BoxNet_timespace windowintersectsS[attr(t,Box)]
  sort rdup dataMNtrip gettuples {a}
  filter[(.Trip_a atperiods (attr(t,Period_t))) passes (attr(t,Pos_p))]
  loopjoin[dataMcar_Moid_btree dataMcar exactmatch [.Moid_a]]
  projectextend[Licence; Id: attr(t,Id_p), Period: attr(t,Period_t)]]
  sortby [Id asc, Period asc, Licence asc]
  krdup[Id, Period, Licence]
consume;

query now();

let Q6dTBA =
  Q6ch1TBA feed {c1}
  Q6ch1TBA feed {c2}
  symmjoin[(.DT_c1 intersects ..DT_c2) and  (.Licence_c1 < ..Licence_c2) and (distance(.Trajline_c1,..Trajline_c2)<=10.0) and (everNearerThan(.ptrip_c1, ..ptrip_c2, 10.0))]
  project [Licence_c1, Licence_c2]
  sortby [Licence_c1 asc, Licence_c2 asc]
  krdup [Licence_c1, Licence_c2]
consume;

delete Q6ch1TBA;

# other alternative query
query now();

let Q10dTBA =
  QueryLicences1 feed project[Licence] {V1}
  loopsel[ fun(t:TUPLE)
    dataMcar_Licence_btree dataMcar exactmatch[attr(t,Licence_V1)]
    project[Moid]
    loopjoin[dataMNtrip_Moid_btree dataMNtrip exactmatch[.Moid] remove[Moid]] {V3}
    extend[t3bbx: mgpbbox(.Trip_V3)]
    extend[ptripA: mgpoint2mpoint(.Trip_V3)]
    loopjoin[ fun(u:TUPLE)
      dataMNtrip_SpatioTemp
      windowintersectsS[rectangle3(
        minD(attr(u,t3bbx),1) - 3.0,
        maxD(attr(u,t3bbx),1) + 3.0,
        minD(attr(u,t3bbx),2) - 3.0,
        maxD(attr(u,t3bbx),2) + 3.0,
        minD(attr(u,t3bbx),3),
        maxD(attr(u,t3bbx),3))
      ] sort rdup
      dataMNtrip gettuples
      filter[.Moid # attr(u, Moid_V3)]
      projectextend[Moid; ptripB: mgpoint2mpoint(.Trip)]
      filter[everNearerThan(attr(u, ptripA), .ptripB, 3.0)]
      projectextend[Moid; Times: deftime((distance(attr(u, ptripA), .ptripB) < 3.0) at TRUE)]
      filter[not(isempty(.Times))]
      loopjoin[dataMcar_Moid_btree dataMcar exactmatch[.Moid] project[Licence]]
    ]
    projectextend[Times, Trip_V3; QueryLicence:
      attr(t, Licence_V1), OtherLicence: .Licence]
    projectextend[QueryLicence, OtherLicence; Pos: .Trip_V3 atperiods .Times]
    filter[not(isempty(.Pos))]
  ]
  sortby[QueryLicence asc, OtherLicence asc]
  groupby [QueryLicence, OtherLicence; AllPos: group feed
    aggregateB[Pos; fun(M1:mgpoint, M2:mgpoint) M1 union M2; [const mgpoint value()]]]
  project[QueryLicence, OtherLicence, AllPos]
  consume;


let EVAL_SEC2COMMANDS_NETTBA = SEC2COMMANDS feed  consume;
save EVAL_SEC2COMMANDS_NETTBA to 'NetworkTBARunTimes.DAT';
delete EVAL_SEC2COMMANDS_NETTBA;
close database;
