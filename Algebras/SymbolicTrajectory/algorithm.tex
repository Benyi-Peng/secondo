\IncMargin{3mm}
\LinesNumbered

\section{Introduction}
In the following, we will present the algorithms leading to the solutions of the operators \tc{matches} and \tc{rewrite}. The lexical analysis and the parsing of the user input are omitted. Algorithms originally designed for \tc{matches} but also employed for \tc{rewrite} are displayed in the \tc{matches} section. Thus, in the \tc{rewrite} chapter, apart from introducing several new algorithms, we explain how the \tc{matches} algorithms are used for \tc{rewrite}.

\section{The Operator \tc{matches}}

\subsection{Initialization and Basic Checks}
The algorithm \ic{matches} checks the pattern time specifications and the syntax of the conditions and invokes the NFA construction and the matching procedure. In case of an error, the input is rejected, and the program terminates.

\begin{algorithm}
  \caption{\label{alg:matches}\ic{matches$(p,$ ml$)$}}
    \KwIn{\ic{p} - a pattern\; 
      \hspace{1.24cm}\ic{ml} - a moving label.}
    \KwOut{\ic{result} - a boolean value that is true iff \ic{p} matches \ic{ml}.}
    \If{verifyPattern$() =$ false $\mathbf{or}$ verifyConditions$() =$ false}{
      \Return false\;
    }
    \ic{NFA nfa $=$ new NFA$($patterns.size$() +1)$}\;
    \ic{buildNFA$($nfa$, p)$}\;
    \Return \ic{match$($nfa$,$ ml$)$}\;
\end{algorithm}

The algorithm \ic{verifyPattern} returns true if and only if the patterns' time specifications are syntactically correct (i.e., either a semantic time, or the name of a periods database object, or a time expression which can be read by \secondo) and all variables are unique.

\begin{algorithm}
  \caption{\label{alg:verifyPattern}\ic{verifyPattern$(p)$}}
    \KwIn{\ic{p} - a pattern.}
    \KwOut{\ic{result} - the result of the validation.}
    let \ic{vars} be an empty set of strings\;
    \ForEach{unit pattern up of p}{
      \ForEach{iv $\in$ up.ivs}{
        \If{iv is not numeric}{
          \lIf{checkSemanticDate$($iv$) =$ false}{\Return \ic{false}\;}
        }
      }
      \If{up.var $\neq\emptyset$}{
	\lIf(\tcp*[f]{\scriptsize{variable not unique}}){up.var $\in$ vars}{\Return \ic{false}}
	\lElse(\tcp*[f]{\scriptsize{add variable to set}}){\ic{vars.insert$($up.var$)$}}
      }
    }
    \Return \ic{true}\;
\end{algorithm}

The algorithm \ic{verifyConditions} returns true if and only if every specified condition is an evaluable boolean expression with suitable keys (e.g., $X$.card $=4$ is correct while $X$.card $=$ ``at\_home'' cannot be evaluated).

\begin{algorithm}
  \caption{\label{alg:verifyConditions}\ic{verifyConditions$(p)$}}
    \KwIn{\ic{p} - a pattern.}
    \KwOut{\ic{result} - the result of the validation.}
    \ForEach{condition c of p}{
      \lIf{evaluate$($c.textSubst$,$ false$) =$ false}{\Return false}
    }
    \Return \ic{true}\;
\end{algorithm}

\subsection{Building the NFA}
The algorithm \ic{buildNFA} converts the pattern information into a nondeterministic finite automaton. The only difficult case is the occurrence of asterisks, increasing the number of transitions as well as the complexity of this and other algorithms significantly.

\begin{algorithm}
  \caption{\label{alg:buildNFA}\ic{buildNFA$($nfa$, p)$}}
    \KwIn{\ic{nfa} - an empty NFA\;
      \hspace{1.24cm}\ic{p} - a pattern.}
    \KwOut{none}
    let int \ic{prev}$[\,]=\{-1, -1, -1\}$\;
    \For{$i=0$ \KwTo $f-1$}{
      \ic{delta$[i][i]$.insert$(i+1)$}\;
      \uIf(\tcp*[f]{\scriptsize{reading no star or end of pattern}}){patterns$[i]$.wc $\neq \ast$ $\mathbf{or}$ $i=f-1$}{
        \If(\tcp*[f]{\scriptsize{'$\dots \ast$ \underline{(1 a)} $\dots$'}}){prev$[0]=i-1$ $\mathbf{or}$ $i=f-1$}{
          \For{$j=$prev$[1]+1$ \KwTo $i-1$}{
            \ic{delta$[j][i]$.insert$(i+1)$}\;
            \For(\tcp*[f]{\scriptsize{process transitions after last match}}){$k=j$ \KwTo $i$}{
              \ic{delta$[j][k]$.insert$(j)$}\;
              \lFor{$m=j$ \KwTo $i$}{\ic{delta$[j][k]$.insert$(m)$}\;}
              \lIf{patterns$[i]$.wc $=\ast$ $\mathbf{and}$ $i=f-1$}{\ic{delta$[j][k]$.insert$(f)$}\;}
            }
          }
          \If(\tcp*[f]{\scriptsize{match before current pattern}}){prev$[1]>-1$}{
            \lFor{$j=$prev$[1]+1$ \KwTo $i$}{\ic{delta$[$prev$[1]][$prev$[1]]$.insert$(j)$}\;}
            \lIf{patterns$[i]$.wc $=\ast$ $\mathbf{and}$ $i=f-1$}{\ic{delta$[$prev$[1]][$prev$[1]]$.insert$(f)$}\;}
          }
          \If(\tcp*[f]{\scriptsize{'$\ast \dots \ast$ (1 a) $\ast \dots \ast$ \underline{(2 b) $\dots$'}}}){prev$[2]<$ prev$[1]-1$}{
            \For{$j=$ prev$[2]+1$ \KwTo prev$[1]-1$}{
              \lFor{$k=$ prev$[1]+1$ \KwTo $i$}{\ic{delta$[j][$prev$[1]]$.insert$(f)$}\;}
              \lIf{patterns$[i]$.wc $=\ast$ $\mathbf{and}$ $i=f-1$}{\ic{delta$[j][$prev$[1]]$.insert$(f)$}\;}
            }
          }
        }
        \ic{prev$[2]=$ prev$[1]$}\;
        \ic{prev$[1]=i$}\;
      }
      \lElseIf{patterns$[i]$.wc $=\ast$}{
        prev$[0]=i$\;
      }
      \ElseIf{patterns$[i]$.wc $=+$}{
        \ic{delta$[i][i]$.insert$(i)$}\;
        \ic{prev$[2]=$ prev$[1]$}\;
        \ic{prev$[1]=i$}\;
      }
    }
    \lIf{patterns$[f-1]$.wc $\in\{+,\ast\}$}{\ic{delta$[f-1][f-1]$.insert$(f-1)$}\;}
\end{algorithm}

\subsection{Applying the NFA}
The algorithm \ic{match} is executed by \ic{matches} after delta is completely determined.

\begin{algorithm}[H]
  \caption{\label{alg:match}\ic{match$($nfa$,$ ml$,$ rewrite$)$}}
    \KwIn{\ic{nfa} - a NFA\;
      \hspace{1.24cm}\ic{ml} - an MLabel\;
      \hspace{1.24cm}\ic{rewrite} - a boolean.}
    \KwOut{\ic{result} - a boolean.}
    \ForEach{ULabel ul $\in$ ml}{
      \ic{updateStates$()$}\;
      \lIf(\tcp*[f]{\scriptsize{abort if there is no active state}}){currentStates $=\emptyset$}{\Return \ic{false}}
    }
    \lIf(\tcp*[f]{\scriptsize{abort if final state is inactive after scanning ml}}){$f\not\in$ currentStates}{\Return \ic{false}}
    \If{rewrite $=$ true}{
      \ic{computeCardsets$()$}\;
      \Return \ic{true}\;
    }
    \If{conds $\neq\emptyset$}{
      \ic{computeCardsets$()$}\;
      \ic{buildSequences$()$}\;
      \lIf{conditionsMatch$($ml$) =$ false}{\Return \ic{false}\;}
    }
    \Return \ic{true}\;
\end{algorithm}

The algorithm \ic{updateStates} is invoked by \ic{match} once for every ULabel. It applies the delta function and updates the set of currently active states. If a single matching occurs, \ic{storeMatch} is called and the states of the corresponding transition set become active.

\begin{algorithm}
  \caption{\label{alg:updateStates}\ic{updateStates$($nfa$)$}}
    \KwIn{\ic{nfa} - a NFA.}
    \KwOut{none}
    let \ic{newStates} be an empty set of integers\;
    \ForEach{$i\in$ currentStates}{
      \For{$j=i$ \KwTo $f-1$}{
        \If{transitions$[i][j]\neq\emptyset$}{
          \If{labelsMatch$(j)$ $\mathbf{and}$ timesMatch$(j)$}{
            \If{patterns$[j]$.wc $=\emptyset\ \mathbf{or}$ patterns$[j]$.ivs $\neq\emptyset\ \mathbf{or}$ patterns$[j]$.lbs $\neq\emptyset$}{
              \ic{matchings$[j]$.insert$($ulId$)$}\;
              \ic{newStates.insert$($delta$[i][j])$}\;
            }
          }
        }
      }
    }
    \ic{currentStates $=$ newStates}\;
\end{algorithm}

\subsection{Time and Label Matching Details}
Being invoked by \ic{updateStates}, the algorithms \ic{timesMatch} and \ic{labelsMatch} accomplish a crucial task for both operators, i.e., they decide whether the time and label specifications of a given unit pattern match the respective properties of a unit label. To be more precise, a label matches if and only if at least one of the unit pattern labels is equal to the unit label text, while for a time match, every time element of the unit pattern has to contain the unit label interval. The time matching algorithm initially checks whether each time specification is a semantic or a numeric one. In the first case (e.g., monday, afternoon), further functions verify the correctness of the input, translate it and try to match it with the unit label. For the second case (e.g., 2012-07-23$\sim$2025), the input is extended in order to build an interval, such that the matching property can easily be decided.

\subsection{Computation of Result Candidates}
If the user calls the operator \tc{rewrite} or specifies at least one condition for the operator \tc{matches}, possible cardinality sets have to be computed. More exactly, with the help of the array \ic{matchings}, each NFA state is assigned a set of numbers each of which means a possible cardinality of the respective unit pattern. For example, in case of a pattern without wildcard, the cardinality can only be 1, but if the unit pattern is the asterisk wildcard, the number of cardinality candidates grows, depending on the surrounding unit patterns.

\begin{algorithm}
  \caption{\label{alg:computeCardsets}\ic{computeCardsets$($nfa$)$}}
    \KwIn{\ic{nfa} - a NFA.}
    \KwOut{none}
    let int \ic{prev $=-1$}\;
    \For{$i=0$ \KwTo $f-1$}{
      \uIf{matchings$[i]\neq\emptyset$}{
        \ic{cardsets$[i]$.insert$(1)$}\;
        \uIf(\tcp*[f]{\scriptsize{'(1 a) $\ast$ \underline{(2 b)}' or '$\ast$ \underline{(1 a)}'}}){prev $=i-2$}{
          \uIf{prev $>-1$}{
            \ForEach{$j\in$ matchings$[i-2], k\in$ matchings$[i]$}{
              \lIf{$k>j$}{\ic{cardsets$[i-1]$.insert$(k-j-1)$}\;}
            }
          }
          \Else(\tcp*[f]{\scriptsize{first match}}){
            \lForEach{$k\in$ matchings$[i]$}{\ic{cardsets$[0]$.insert$(k)$}\;}
          }
        }
        \ElseIf(\tcp*[f]{\scriptsize{'(1 a) $\ast$|+$\ \dots\ \ast$|+ \underline{(2 b)}' or '$\ast$|+$\ \dots\ \ast$|+ \underline{(1 a)}'}}){prev $<i-2$}{
          \uIf{prev $>-1$}{
            \For{$j=$ prev $+1$ \KwTo $i-1$}{
              \For{$k=1$ \KwTo $\max($matchings$[i])-\min($matchings$[prev])-1$}{
                \ic{cardsets$[j]$.insert$(k)$}\;
              }
              \lIf{patterns$[j]$.wc $=\ast$}{\ic{cardsets$[j]$.insert$(0)$}\;}
            }
          }
          \Else(\tcp*[f]{\scriptsize{'$\ast\ \dots\ \ast$ \underline{(1 a)}}'}){
            \For{$j=0$ \KwTo $i-1$}{
              \lFor{$k=1$ \KwTo $\max($matchings$[i])$}{\ic{cardsets$[j]$.insert$(k)$}\;}
              \lIf{patterns$[j]$.wc $=\ast$}{\ic{cardsets$[j]$.insert$(0)$}\;}
            }
          }
        }
        \ic{prev $=i$}\;
      }
      \ElseIf(\tcp*[f]{\scriptsize{no match at the end}}){$i=f-1$}{
        \uIf{prev $=i-1$}{
          \lForEach{$j\in$ matchings$[i-1]$}{\ic{cardsets$[i]$.insert$($maxUlId $-j)$}\;}
          \lIf{patterns$[j]$.wc $\neq\ast$}{\ic{cardsets$[j]$.erase$(0)$}\;}
        }
        \Else(\tcp*[f]{\scriptsize{'$\dots$ (1 a) $\ast\ \dots\ $\underline{$\ast$}' or '$\ast\ \dots\ $\underline{$\ast$}'}}){
          \For{$j=$ prev $+1$ \KwTo $i$}{
            \lFor{$k=1$ \KwTo maxUlId $-\min($matchings$[$prev$])$}{\ic{cardsets$[j]$.insert$(k)$}\;}
            \lIf{patterns$[i]$.wc $=\ast$}{\ic{cardsets$[j]$.insert$(0)$}\;}
          }
        }
      }
    }
\end{algorithm}

After the computation of the cardinality sets, we have to create the sequences leading to the query solution(s), i.e., we have to deduce which of the (possibly very numerous) cardinality combinations are valid. This is the most CPU time consuming algorithm of the paper.

\begin{algorithm}
  \caption{\label{alg:buildSequences}\ic{buildSequences$($nfa$)$}}
    \KwIn{\ic{p} - a pattern.}
    \KwOut{\ic{sequences} - a set of vectors of size\_t.}
    let \ic{seq} be a vector of size\_t\;
    let \ic{totalSize} $=1$\;
    \lForEach{$i\in\{0,\dots,f-1\}$}{\ic{totalSize $=$ totalSize $*\vert$cardsets$[i]\vert$}\;}
    \ForEach{$j\in\{0,\dots,$totalSize $-1\}$}{
      let $k=j$\;
      clear \ic{seq}\;
      \ic{seq.push\_back$(0)$}\;
      let \ic{sequenceSum $=0$}\;
      \ForEach{$i\in\{0,\dots,f-1\}$}{
        let $m=k$ mod $|$\ic{cardsets}$[i]|$\;
        \lIf{$i<f-1$}{\ic{seq.push\_back$(\max($seq$)+m)$}\;}
        $k=\lfloor k/\left|\mbox{\ic{cardsets}}[i]\right|\rfloor$\;
        \ic{sequenceSum} $=$ \ic{sequenceSum} $+\ m$\;
        \lIf(\tcp*[f]{\scriptsize{stop if sum exceeds maximum}}){sequenceSum $>$ maxUlId $+1$}{$i=f+1$}
      }
      \If{sequenceSum $=$ maxUlId $+1\ \mathbf{and}\ \max($seq$)<$ maxUlId $+2$}{
        \ic{sequences.insert$($seq$)$}\;
      }
    }
\end{algorithm}

\subsection{Condition Processing}
The subsequent algorithm \ic{conditionsMatch} loops through the specified conditions and tries to find a matching cardinality sequence. If a condition evaluation (i.e., the algorithm \ic{evaluateCond}) yields a positive result, the algorithm proceeds to the next condition (or returns \ic{true} if there are no more conditions). Otherwise, the mismatching sequence is deleted from the collection, and we have to continue with the next sequence and the first condition, since a sequence has to match every condition for this algorithm to return \ic{true}.

\begin{algorithm}
  \caption{\label{alg:conditionsMatch}\ic{conditionsMatch$($nfa$,$ ml$)$}}
    \KwIn{\ic{nfa} - a NFA\;
      \hspace{1.24cm}\ic{ml} - an MLabel.}
    \KwOut{a boolean which is \ic{true} iff matching succeeds.}
    let boolean \ic{continue $=$ true}\;
    \lIf{conds $=\emptyset$}{\Return \ic{true}\;}
    \For{$i=0$ \KwTo $\left|\mbox{\ic{conds}}\right|-1$}{
      let \ic{seq} be the first sequence of \ic{sequences}\;
      \ic{continue $=$ false}\;
      \While{sequences $\neq\emptyset\ \mathbf{and}$ continue $=$ false}{
        \ic{continue $=$ false}\;
        \lIf{conds$[i]$.keys $\neq\emptyset$}{\ic{buildCondMatchings$(i,$ seq$)$}\;}
        \uIf(\tcp*[f]{\scriptsize{mismatch; delete seq \& go back to 1st cond}}){evaluateCond$($ml, i, seq$)=$ false}{
          \ic{sequences.erase$($seq$)$}\;
          let \ic{seq} be the first sequence of \ic{sequences}\;
          $i=0$\;
        }
        \lElse{\ic{continue $=$ true}\;}
      }
      \lIf(\tcp*[f]{\scriptsize{no sequence fits the condition}}){continue $=$ false}{\Return \ic{false}}
    }
    \lIf{sequences $=\emptyset$}{\Return \ic{false}\;}
    \lElse{\Return \ic{true}\;}
\end{algorithm}