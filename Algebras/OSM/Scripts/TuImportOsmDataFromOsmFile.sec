################################################################################
### Importing OSM data from shape files (2 / 7)
################################################################################
### Description:
### - Reads data on streets and points of interest from osm-files.
### Please, see tu_osm_import.sh for further details.
###
### Preconditions:
### - existing open database
###
### Postconditions:
### - streetsTmp-relation
### either self-made shape-files in a custom format:
### streetsTmp: rel{geoData: sline, ID: int, part: int, attrib: string}
### or shape-files in the free standard geofabrik-format:
### streetsTmp: rel{geoData: sline, osm_id: int, name: string, ref: string,
###                 type: string, oneway: int, bridge: int, maxspeed: int,
###                 tunnel: bool, layer: int}
### - pointsTmp-relation
### pointsTmp: rel{osm_id: int, timestamp: int, name: string, geoData: point,
###                type: string}
### - restrictionsTmp-relation
### restrictionsTmp: rel{osm_id: int, from: int, via: int, to: int,
###                      restriction: string, type: string}
###
### Author:
### - Thomas Uchdorf, t.uchdorf@arcor.de
################################################################################

# Importing the raw data from an osm-file
# on POIs and converting the (longitude,latitude)-coordinates into points
let osmNodesRel =
   osmimport(SRC_DIR_PATH + 'City.osm','node')
   extend [geoData: makepoint(.lon,.lat)]
   remove [lon,lat]
   filter[bbox(.geoData) intersects partRect]
   consume;
# on streets
let osmWaysTmp =
   osmimport(SRC_DIR_PATH + 'City.osm','way')
   filter [isdefined(.type)]
   consume;
# on restrictions
let osmRestrictionsRel =
   osmimport(SRC_DIR_PATH + 'City.osm','restriction')
   consume;

# Extending the references to osm nodes
let osmWayNodeRefsTmp =
   osmWaysTmp feed
   sortby [osm_id] 
   projectextendstream [osm_id; abc: tokenize(.nodeRefs,",")]
   addcounter[orderId, 1]
   extend [nodeRef: toObject(.abc,0)]
   remove [abc]
   consume;

# Replacing the references to osm nodes by the actual points (Undefined points
# have to be treated specially. They exist when points exceed the boundaries of
# the bounding box.)
#let osmWayPointsTmp =
#   osmNodesRel feed {p}
#   project [osm_id_p,geoData_p]
#   osmWayNodeRefsTmp feed
#   hashjoin [osm_id_p,nodeRef,99997]
#   extend [pointGeoData: .geoData_p]
#   remove [geoData_p]
#   consume;
let osmWayPointsTmp =
   osmNodesRel feed {p}
   project [osm_id_p,geoData_p]
   osmWayNodeRefsTmp feed
   smouterjoin [osm_id_p,nodeRef]
   filter [isdefined(.nodeRef)]
   sortby [osm_id,orderId] 
   filter [isdefined(.osm_id_p)]
   addcounter[substreetId, 1]
   extend [pointGeoData: .geoData_p]
   remove [geoData_p]
   consume;
# Combining sequences of way points with sequential order ids
# (no gaps) to substreets 
let osmUncheckedWaysTmp =
   osmWayPointsTmp feed
   project [osm_id,substreetId,orderId]
   sortby [osm_id,substreetId,orderId]
   osmWayPointsTmp feed
   project [osm_id,substreetId,orderId]
   sortby [osm_id,substreetId,orderId] {t}
   hashjoin [osm_id,osm_id_t,99997]
   filter [(.orderId_t >= .orderId) and
      (.substreetId_t = (.substreetId + (.orderId_t - .orderId)))]
   sortby [osm_id,substreetId]
   groupby [osm_id,substreetId; 
      toSubstreetId: group feed max [substreetId_t]]
   sortby [osm_id,toSubstreetId]
   groupby [osm_id,toSubstreetId; 
      fromSubstreetId: group feed min [substreetId]]
   project [osm_id,fromSubstreetId,toSubstreetId]
   sortby [osm_id,fromSubstreetId,toSubstreetId]
   addcounter [newSubstreetId,1]
   osmWayPointsTmp feed
   extend [osm_ref: .osm_id]
   remove [osm_id]
   sortby [osm_ref,substreetId,orderId]
   hashjoin [osm_id,osm_ref,99997]
   remove [osm_ref]
# Combining the points to lines
   sortby [osm_id,newSubstreetId,orderId] 
   groupby [osm_id,newSubstreetId; 
      numPoints: group count,  
      geoData: group feed
         projecttransformstream [pointGeoData]
         collect_sline[TRUE]] 
   consume;

let osmWaysRel = 
   osmWaysTmp feed
   osmUncheckedWaysTmp feed
   extend [helpId: .osm_id]
   remove [osm_id]
   hashjoin [osm_id,helpId,99997]
   remove [nodeRefs,helpId]
   consume;

# Checking if streets with broken lines exist (missing or wrong references)
query
   osmWaysRel feed 
   filter [not(isdefined(.geoData))]
   consume;

# Storing the street data
let streetsTmp =
   osmWaysRel feed 
   filter[bbox(.geoData) intersects partRect]
   consume;

# Storing the POI data
let pointsTmp =
   osmNodesRel feed
   extend [timestamp: "DUMMY"]
   consume;

# Storing the restriction data
let restrictionsTmp =
   osmRestrictionsRel feed
#   filter[bbox(.geoData) intersects partRect]
   consume;

