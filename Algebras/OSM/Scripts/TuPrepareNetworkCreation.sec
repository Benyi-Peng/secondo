################################################################################
### Preparing network creation from imported OSM data (7 / 11)
################################################################################
### Description:
### - This script prepares network creation from imported OSM data.
### Please, see tu_osm_import.sh for further details. 
###
### Preconditions:
### - activated necessary algebras
### - existing open database with successfully imported osm data
### - extStreetsRel-relation
### extStreetsRel: rel{geoData: sline, streetId: int, name: string,
###                    ref: string, roadClassRef: int, oneWay: int,
###                    bridge: int, maxSpeed: int, tunnel: bool,
###                    layer: int, groupId: int}
### - nodesRel-relation
### nodesRel: rel{Node: point, NodeId: int}
### - extSectionsRel-relation
### extSectionsRel: rel{SectionId: int, Section: sline, StartNodeId: int,
###                     EndNodeId: int, StreetId: int, GroupId: int,
###                     SectionDist: real}
### - onlyRestrictions
### onlyRestrictions: rel{fromStreeRef: int, toStreetRef: int,
###                       viaNodeRef: int, viaNode: point,
###                       only: bool, restriction: text}
### - noUturnRestrictions
### noUturnRestrictions: rel{fromStreeRef: int, toStreetRef: int,
###                          viaNodeRef: int, viaNode: point,
###                          noUturn: bool}
### - noLeftTurnRestrictions
### noLeftTurnRestrictions: rel{fromStreeRef: int, toStreetRef: int,
###                             viaNodeRef: int, viaNode: point,
###                             noLeftTurn: bool}
### - noRightTurnRestrictions
### noRightTurnRestrictions: rel{fromStreeRef: int, toStreetRef: int,
###                              viaNodeRef: int, viaNode: point,
###                              noRightTurn: bool}
### - noStraightOnRestrictions
### noStraightOnRestrictions: rel{fromStreeRef: int, toStreetRef: int,
###                               viaNodeRef: int, viaNode: point,
###                               noStraightOn: bool}
###
### Postconditions:
### - twoSecJuncBtwTwoSts-relation
### twoSecJuncBtwTwoSts: rel{Road1: int, Pos1: double, Road2: int,
###                          Pos2: double, JunctionType: int}
### - threeSecJuncBtwTwoSts-relation
### threeSecJuncBtwTwoSts: rel{Road1: int, Pos1: double, Road2: int,
###                            Pos2: double, JunctionType: int}
### - fourSecJuncBtwTwoSts-relation
### fourSecJuncBtwTwoSts: rel{Road1: int, Pos1: double, Road2: int,
###                           Pos2: double, JunctionType: int}
###
### Author:
### - Thomas Uchdorf, thomas.uchdorf(at)fernuni-hagen.de
################################################################################

# Gathering data that will be used for network creation
let fullSectionsView =
   ((((extStreetsRel feed {a} 
       extSectionsRel feed {b} 
       hashjoin [streetId_a,StreetId_b,99997] 
       projectextend [;  
          groupId: .groupId_a, 
          streetId: .streetId_a, 
          sectionId: .SectionId_b, 
          startNodeId: .StartNodeId_b, 
          endNodeId: .EndNodeId_b, 
          streetData: .geoData_a, 
          sectionData: .Section_b, 
          sectionDist: .SectionDist_b, 
          name: .name_a, 
          ref: .ref_a, 
          oneWay: .oneWay_a, 
          maxSpeed: .maxSpeed_a, 
          bridge: .bridge_a, 
          roadClassRef: .roadClassRef_a,
          streetStartNode: atposition(.geoData_a,0.0,TRUE),
          streetEndNode: atposition(.geoData_a,size(.geoData_a),TRUE)]) 
      nodesRel feed {c} 
      hashjoin [startNodeId,NodeId_c,99997] 
      remove [NodeId_c]) 
     nodesRel feed {d} 
     hashjoin [endNodeId,NodeId_d,99997] 
     remove [NodeId_d])
    nodesRel feed {e} 
    hashjoin [streetStartNode,Node_e,99997] 
    remove [Node_e])
   nodesRel feed {f} 
   hashjoin [streetEndNode,Node_f,99997] 
   remove [Node_f]
   renameattr [startNode: "Node_c",endNode: "Node_d",
      streetStartNodeId: "NodeId_e",streetEndNodeId: "NodeId_f"] 
   consume;

# Building indexes to speed up queries
derive fullSectionsView_groupId_btree =
   fullSectionsView createbtree[groupId];
derive fullSectionsView_streetId_btree =
   fullSectionsView createbtree[streetId];
derive fullSectionsView_sectionId_btree =
   fullSectionsView createbtree[sectionId];
derive fullSectionsView_startNodeId_btree =
   fullSectionsView createbtree[startNodeId];
derive fullSectionsView_endNodeId_btree =
   fullSectionsView createbtree[endNodeId];
derive fullSectionsView_streetData_rtree =
   fullSectionsView creatertree[streetData];
derive fullSectionsView_sectionData_rtree =
   fullSectionsView creatertree[sectionData];
derive fullSectionsView_startNode_rtree =
   fullSectionsView creatertree[startNode];
derive fullSectionsView_endNode_rtree =
   fullSectionsView creatertree[endNode];

# Determining all possible pairs of crossing streets
let startSections =
   nodesRel feed
   fullSectionsView feed
   sortby [sectionId]
   project [streetId,sectionId,startNodeId,endNodeId,streetData,sectionData,
      oneWay,streetStartNodeId,streetEndNodeId]
   hashjoin [NodeId,startNodeId,99997]
   consume;
let endSections =
   nodesRel feed
   fullSectionsView feed
   sortby [sectionId]
   project [streetId,sectionId,startNodeId,endNodeId,streetData,sectionData,
      oneWay,streetStartNodeId,streetEndNodeId]
   hashjoin [NodeId,endNodeId,99997]
   consume;
let startFromScratchSections =
   startSections feed
   filter [(.streetStartNodeId = .startNodeId) and
      not(.streetStartNodeId = .streetEndNodeId)]
   consume;
let endFromScratchSections =
   endSections feed
   filter [(.streetEndNodeId = .endNodeId) and
      not(.streetStartNodeId = .streetEndNodeId)]
   consume;
let two =
   (startFromScratchSections feed
    endFromScratchSections feed
    concat
    sortby [sectionId]) {a}
   (startFromScratchSections feed
    endFromScratchSections feed
    concat
    sortby [sectionId]) {b}
   hashjoin [NodeId_a,NodeId_b]
   filter [.sectionId_a < .sectionId_b]
   filter [not(.streetId_a = .streetId_b)]
   projectextend [; 
      Node: .Node_a,
      Road1: .streetId_a,
      Pos1: atpoint(.streetData_a,.Node_a,TRUE),
      Road2: .streetId_b,
      Pos2: atpoint(.streetData_b,.Node_a,TRUE),
      JunctionType: getconnectivitycode(
         ifthenelse(.NodeId_a = .endNodeId_a, 1, 2),
         ifthenelse(.NodeId_b = .endNodeId_b, 1, 2),
         0,
         0,
         .oneWay_a = 1,.oneWay_b = 1,FALSE,FALSE)]
   consume;
let three =
   ((startSections feed
    endSections feed
    concat
    sortby [sectionId]) {a}   
   (startSections feed
    endSections feed
    concat
    sortby [sectionId]) {b}
    hashjoin [NodeId_a,NodeId_b]
    filter [.sectionId_a < .sectionId_b])
   (startSections feed
    endSections feed
    concat
    sortby [sectionId]) {c}
    hashjoin [NodeId_a,NodeId_c]
   extend [
      Road1: .streetId_a,
      Road2: .streetId_b,
      Road3: .streetId_c,
      NodeId: .NodeId_a,
      Node: .Node_a]
   filter [
      ((((.NodeId = .startNodeId_b) and
         ((.streetStartNodeId_b = .startNodeId_b) and
          not(.streetStartNodeId_b = .streetEndNodeId_b)))
        or ((.NodeId = .endNodeId_b) and
         ((.streetEndNodeId_b = .endNodeId_b) and
          not(.streetStartNodeId_b = .streetEndNodeId_b))))
       and (.sectionId_a < .sectionId_c) and
       (.Road1 = .Road3) and not(.Road1 = .Road2))
      or
      ((((.NodeId = .startNodeId_a) and
         ((.streetStartNodeId_a = .startNodeId_a) and
         not(.streetStartNodeId_a = .streetEndNodeId_a)))
        or ((.NodeId = .endNodeId_a) and
         ((.streetEndNodeId_a = .endNodeId_a) and
         not(.streetStartNodeId_a = .streetEndNodeId_a))))
       and (.sectionId_c < .sectionId_b) and
       (.Road2 = .Road3) and not(.Road1 = .Road2))]
   projectextend [Node; 
      Road1: .Road1,
      Pos1: atpoint(.streetData_a,.Node,TRUE),
      Road2: .Road2,
      Pos2: atpoint(.streetData_b,.Node,TRUE),
      JunctionType: getconnectivitycode(
         ifthenelse(.NodeId_a = .endNodeId_a, 1, 2),
         ifthenelse(.NodeId_b = .endNodeId_b, 1, 2),
         ifthenelse(.Road1 = .Road3,
            ifthenelse(.NodeId_c = .endNodeId_c, 1, 2),0),
         ifthenelse(.Road2 = .Road3,
            ifthenelse(.NodeId_c = .endNodeId_c, 1, 2),0),
         .oneWay_a = 1,.oneWay_b = 1,
         ifthenelse(.Road1 = .Road3, .oneWay_c = 1, FALSE),
         ifthenelse(.Road2 = .Road3, .oneWay_c = 1, FALSE))]
   consume;
let four =
   (((startSections feed
     endSections feed
     concat
     sortby [sectionId]) {a}   
    (startSections feed
     endSections feed
     concat
     sortby [sectionId]) {b}
     hashjoin [NodeId_a,NodeId_b]
     filter [.sectionId_a < .sectionId_b])
    (startSections feed
     endSections feed
     concat
     sortby [sectionId]) {c}
     hashjoin [NodeId_a,NodeId_c]
     filter [.sectionId_a < .sectionId_c])
   (startSections feed
   endSections feed
   concat
   sortby [sectionId]) {d}
   hashjoin [NodeId_a,NodeId_d]
   filter [.sectionId_b < .sectionId_d]
   extend [
      Road1: .streetId_a,
      Road2: .streetId_b,
      Road3: .streetId_c,
      Road4: .streetId_d,
      NodeId: .NodeId_a,
      Node: .Node_a]
   filter [(.Road1 = .Road3) and (.Road2 = .Road4) and not(.Road1 = .Road2)]
   projectextend [Node; 
      Road1: .Road1,
      Pos1: atpoint(.streetData_a,.Node,TRUE),
      Road2: .Road2,
      Pos2: atpoint(.streetData_b,.Node,TRUE),
      JunctionType: getconnectivitycode(
         ifthenelse(.NodeId_a = .endNodeId_a, 1, 2),
         ifthenelse(.NodeId_b = .endNodeId_b, 1, 2),
         ifthenelse(.NodeId_c = .endNodeId_c, 1, 2),
         ifthenelse(.NodeId_d = .endNodeId_d, 1, 2),
         .oneWay_a = 1,.oneWay_b = 1,.oneWay_c = 1,.oneWay_d = 1)]
   consume;
let targetRel =
   (two feed
    project [Road1,Road2,Node]
    three feed 
    project [Road1,Road2,Node]
    concat)
   four feed
   project [Road1,Road2,Node]
   concat
   consume;

# Using left outer join to add the different restrictions to crossings
# that share the same junction and the same incoming street
let road1ToRoad2 = 
   ((((targetRel feed
       onlyRestrictions feed
       symmouterjoin [(.Node = ..viaNode) and
          (.Road1 = ..fromStreetRef)]
       filter [isdefined(.Node)])
      noUturnRestrictions feed {u}
      symmouterjoin [(.Node = ..viaNode_u) and
         (.Road1 = ..fromStreetRef_u)]
      filter [isdefined(.Node)])
     noLeftTurnRestrictions feed {l}
     symmouterjoin [(.Node = ..viaNode_l) and
        (.Road1 = ..fromStreetRef_l)]
     filter [isdefined(.Node)])
    noStraightOnRestrictions feed {s}
    symmouterjoin [(.Node = ..viaNode_s) and
       (.Road1 = ..fromStreetRef_s)]
    filter [isdefined(.Node)])
   noRightTurnRestrictions feed {r}
   symmouterjoin [(.Node = ..viaNode_r) and (.Road1 = ..fromStreetRef_r)]
   filter [isdefined(.Node)]
   extend [
      Road1ToRoad2:
# matching "only_..."
      (isdefined(.viaNode) and
      .only and
      (.Road1 = .fromStreetRef) and
      (.Road2 = .toStreetRef)) or
# no contradictory "only_..."
      (not(isdefined(.viaNode)) and
# as well as no restrictive restrictions
# no "no_u_turn"
       not(isdefined(.viaNode_u) and
       (.Road2 = .toStreetRef_u) and
       .noUturn_u) and
# no "no_left_turn"
       not(isdefined(.viaNode_l) and
       (.Road2 = .toStreetRef_l) and
       .noLeftTurn_l) and
# no "no_straight_on"
       not(isdefined(.viaNode_s) and
       (.Road2 = .toStreetRef_s) and
       .noStraightOn_s) and
# no "no_right_turn"
       not(isdefined(.viaNode_r) and
       (.Road2 = .toStreetRef_r) and
       .noRightTurn_r)),
      Road1ToRoad1:
# no "no_u_turn" on same street
         not(isdefined(.viaNode_u) and
         (.Road1 = .toStreetRef_u) and
         .noUturn_u)]
   remove [fromStreetRef,fromStreetRef_u,fromStreetRef_l,fromStreetRef_s,
           fromStreetRef_r,toStreetRef,toStreetRef_u,toStreetRef_l,
           toStreetRef_s,toStreetRef_r,viaNodeRef,viaNodeRef_u,
           viaNodeRef_l,viaNodeRef_s,viaNodeRef_r,viaNode,viaNode_u,
           viaNode_l,viaNode_s,viaNode_r,restriction,only,noUturn_u,
           noLeftTurn_l,noStraightOn_s,noRightTurn_r]
   consume;

let road2ToRoad1 = 
   ((((targetRel feed
       onlyRestrictions feed
       symmouterjoin [(.Node = ..viaNode) and
          (.Road2 = ..fromStreetRef)]
       filter [isdefined(.Node)])
      noUturnRestrictions feed {u}
      symmouterjoin [(.Node = ..viaNode_u) and
         (.Road2 = ..fromStreetRef_u)]
      filter [isdefined(.Node)])
     noLeftTurnRestrictions feed {l}
     symmouterjoin [(.Node = ..viaNode_l) and
        (.Road2 = ..fromStreetRef_l)]
     filter [isdefined(.Node)])
    noStraightOnRestrictions feed {s}
    symmouterjoin [(.Node = ..viaNode_s) and
       (.Road2 = ..fromStreetRef_s)]
    filter [isdefined(.Node)])
   noRightTurnRestrictions feed {r}
   symmouterjoin [(.Node = ..viaNode_r) and (.Road2 = ..fromStreetRef_r)]
   filter [isdefined(.Node)]
   extend [
      Road2ToRoad1:
# matching "only_..."
      (isdefined(.viaNode) and
      .only and
      (.Road2 = .fromStreetRef) and
      (.Road1 = .toStreetRef)) or
# no contradictory "only_..."
      (not(isdefined(.viaNode)) and
# as well as no restrictive restrictions
# no "no_u_turn"
       not(isdefined(.viaNode_u) and
       (.Road1 = .toStreetRef_u) and
       .noUturn_u) and
# no "no_left_turn"
       not(isdefined(.viaNode_l) and
       (.Road1 = .toStreetRef_l) and
       .noLeftTurn_l) and
# no "no_straight_on"
       not(isdefined(.viaNode_s) and
       (.Road1 = .toStreetRef_s) and
       .noStraightOn_s) and
# no "no_right_turn"
       not(isdefined(.viaNode_r) and
       (.Road1 = .toStreetRef_r) and
       .noRightTurn_r)),
      Road2ToRoad2:
# no "no_u_turn" on same street
         not(isdefined(.viaNode_u) and
         (.Road2 = .toStreetRef_u) and
         .noUturn_u)]
   remove [fromStreetRef,fromStreetRef_u,fromStreetRef_l,fromStreetRef_s,
           fromStreetRef_r,toStreetRef,toStreetRef_u,toStreetRef_l,
           toStreetRef_s,toStreetRef_r,viaNodeRef,viaNodeRef_u,
           viaNodeRef_l,viaNodeRef_s,viaNodeRef_r,viaNode,viaNode_u,
           viaNode_l,viaNode_s,viaNode_r,restriction,only,noUturn_u,
           noLeftTurn_l,noStraightOn_s,noRightTurn_r]
   consume;

#TODO Add road1ToRoad1 and road2ToRoad2

# Updating the connectivity code according to the restrictions
# (only_right_turn, only_left_turn, only_straight_on,
# no_left_turn, no_right_turn, no_straight_on,
# no_u_turn)
# since streets have to be separated at restriction nodes according to osm
# policy, it is sufficient to take a look at junctions between two sections
# belonging to two streets
let twoSecJuncBtwTwoSts =
   two feed consume;
let threeSecJuncBtwTwoSts =
   three feed consume;
let fourSecJuncBtwTwoSts =
   four feed consume;
