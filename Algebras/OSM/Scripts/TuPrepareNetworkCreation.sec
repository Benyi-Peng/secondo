################################################################################
### Creating networks from imported OSM data (7 / 11)
################################################################################
### Description:
### - This script creates networks from imported OSM data.
### Please, see tu_shp_import.sh for further details. 
###
### Preconditions:
### - activated necessary algebras
### - existing open database with successfully imported osm data
### - extStreetsRel-relation
### extStreetsRel: rel{geoData: sline, streetId: int, name: string, ref: string,
###                    roadClass: string, oneWay: int, bridge: int,
###                    maxSpeed: int, tunnel: bool, layer: int, groupId: int}
### - nodesRel-relation
### nodesRel: rel{Node: point, NodeId: int}
### - extSectionsRel-relation
### extSectionsRel: rel{SectionId: int, Section: sline, StartNodeId: int,
###                     EndNodeId: int, StreetId: int, GroupId: int,
###                     SectionDist: real}
###
### Postconditions:
### - cityRoads-relation
### cityRoads: rel{Name: string, Road: int, Length: double, Geometry: line,
###                Dual: bool, StartsSmaller: bool, RoadLevel: int}
### - cityJunctions-relation
### cityJunctions: rel{Road1: int, Pos1: double, Road2: int, Pos2: double,
###                    JunctionType: int}
### - city-network
###
### Author:
### - Thomas Uchdorf, t.uchdorf@arcor.de
################################################################################

# Making a relation with road data to enable network creation
# see also PaperMon-paper page 11
let cityRoads =
   extStreetsRel feed
   projectextend [; Name : .name, Road: .streetId,
     Length: size(.geoData),
#     Length: size(.geoData,create_geoid("WGS1984")),
     Geometry: .geoData, Dual: .oneWay=0,
     StartsSmaller: get_startsmaller(.geoData),
     RoadLevel : ifthenelse (.roadClass
       contains "motorway",0,ifthenelse(.roadClass
       contains "primary",1,ifthenelse(.roadClass
       contains "secondary",2,ifthenelse(.roadClass
       contains "tertiary",3,ifthenelse(.roadClass
       contains "residential",4,ifthenelse(.roadClass
       contains "unclassified",5,ifthenelse(.roadClass
       contains "road",6,ifthenelse(.roadClass
       contains "footway",7,-1))))))))]
   consume;

# sligthly more elegant way of creating the cityRoads-relation
#let roadClassesRel =
#   [const rel(tuple([RoadClassId: int, RoadClass: string])) value (
#   (0 "motorway")
#   (1 "primary")
#   (2 "secondary")
#   (3 "tertiary")
#   (4 "residential")
#   (5 "unclassified")
#   (6 "road")
#   (7 "footway")
#   )];
#
#let cityRoads =
#   extStreetsRel feed {a}
#   roadClassesRel feed {b}
#   symmouterjoin [.roadClass_a contains ..RoadClass_b]
#   projectextend [; 
#   Name : .name_a,
#   Road: .streetId_a,
#   Length: size(.geoData_a,create_geoid("WGS1984")),
#   Geometry: .geoData_a, Dual: .oneWay_a=0,
#   StartsSmaller: get_startsmaller(.geoData_a),
#   RoadLevel : ifthenelse(not(isdefined(.RoadClassId_b)),-1,.RoadClassId_b)]
#   consume;

let fullSectionsView =
   ((((extStreetsRel feed {a} 
       extSectionsRel feed {b} 
       hashjoin [streetId_a,StreetId_b,99997] 
       projectextend [;  
          groupId: .groupId_a, 
          streetId: .streetId_a, 
          sectionId: .SectionId_b, 
          startNodeId: .StartNodeId_b, 
          endNodeId: .EndNodeId_b, 
          streetData: .geoData_a, 
          sectionData: .Section_b, 
          sectionDist: .SectionDist_b, 
          name: .name_a, 
          ref: .ref_a, 
          oneWay: .oneWay_a, 
          maxSpeed: .maxSpeed_a, 
          bridge: .bridge_a, 
          roadClass: .roadClass_a,
          streetStartNode: atposition(.geoData_a,0.0,TRUE),
          streetEndNode: atposition(.geoData_a,size(.geoData_a),TRUE)]) 
      nodesRel feed {c} 
      hashjoin [startNodeId,NodeId_c,99997] 
      remove [NodeId_c]) 
     nodesRel feed {d} 
     hashjoin [endNodeId,NodeId_d,99997] 
     remove [NodeId_d])
    nodesRel feed {e} 
    hashjoin [streetStartNode,Node_e,99997] 
    remove [Node_e])
   nodesRel feed {f} 
   hashjoin [streetEndNode,Node_f,99997] 
   remove [Node_f]
   renameattr [startNode: "Node_c",endNode: "Node_d",
      streetStartNodeId: "NodeId_e",streetEndNodeId: "NodeId_f"] 
   consume;

derive fullSectionsView_groupId_btree =
   fullSectionsView createbtree[groupId];
derive fullSectionsView_streetId_btree =
   fullSectionsView createbtree[streetId];
derive fullSectionsView_sectionId_btree =
   fullSectionsView createbtree[sectionId];
derive fullSectionsView_startNodeId_btree =
   fullSectionsView createbtree[startNodeId];
derive fullSectionsView_endNodeId_btree =
   fullSectionsView createbtree[endNodeId];
derive fullSectionsView_streetData_rtree =
   fullSectionsView creatertree[streetData];
derive fullSectionsView_sectionData_rtree =
   fullSectionsView creatertree[sectionData];
derive fullSectionsView_startNode_rtree =
   fullSectionsView creatertree[startNode];
derive fullSectionsView_endNode_rtree =
   fullSectionsView creatertree[endNode];

# Updating the connectivity code according to the restrictions
# (only_right_turn, only_left_turn, only_straight_on,
# no_left_turn, no_right_turn, no_straight_on,
# no_u_turn)
# since streets have to be separated at restriction nodes according to osm
# policy, it is sufficient to take a look at junctions between two sections
# belonging to two streets
# Storing the work relation under a different name
#let targetRel =
#   oneSecInOneSecOut12JuncTmp;
# Determining all possible pairs of crossing streets
#let two =
#   (nodesRel feed
#    fullSectionsView feed
#    sortby [sectionId]
#    project [streetId,sectionId,startNodeId,endNodeId,streetData,sectionData,oneWay,streetStartNodeId,streetEndNodeId] {a}
#    symmjoin [((.NodeId = ..startNodeId_a) and (..streetStartNodeId_a = ..startNodeId_a)) or
#       ((.NodeId = ..endNodeId_a) and (..streetEndNodeId_a = ..endNodeId_a))])
#   fullSectionsView feed
#   sortby [sectionId]
#   project [streetId,sectionId,startNodeId,endNodeId,streetData,sectionData,oneWay,streetStartNodeId,streetEndNodeId] {b}
#   symmjoin [((.NodeId = ..startNodeId_b) and (..streetStartNodeId_b = ..startNodeId_b)) or
#      ((.NodeId = ..endNodeId_b) and (..streetEndNodeId_b = ..endNodeId_b))]
#   filter [.sectionId_a < .sectionId_b]
#   projectextend [; 
#      Road1: .streetId_a,
#      Road2: .streetId_b,
#      Node: .Node]
#   filter [not(.Road1 = .Road2)]
#   consume;
let startSections =
   nodesRel feed
   fullSectionsView feed
   sortby [sectionId]
   project [streetId,sectionId,startNodeId,endNodeId,streetData,sectionData,oneWay,streetStartNodeId,streetEndNodeId]
   hashjoin [NodeId,startNodeId,99997]
   consume;
let endSections =
   nodesRel feed
   fullSectionsView feed
   sortby [sectionId]
   project [streetId,sectionId,startNodeId,endNodeId,streetData,sectionData,oneWay,streetStartNodeId,streetEndNodeId]
   hashjoin [NodeId,endNodeId,99997]
   consume;
let startFromScratchSections =
   startSections feed
   filter [.streetStartNodeId = .startNodeId]
   consume;
let endFromScratchSections =
   endSections feed
   filter [.streetEndNodeId = .endNodeId]
   consume;
let two =
   (startFromScratchSections feed
    endFromScratchSections feed
    concat
    sortby [sectionId]) {a}
   (startFromScratchSections feed
    endFromScratchSections feed
    concat
    sortby [sectionId]) {b}
   hashjoin [NodeId_a,NodeId_b]
   filter [.sectionId_a < .sectionId_b]
   projectextend [; 
      Road1: .streetId_a,
      Road2: .streetId_b,
      Node: .Node_a]
   filter [not(.Road1 = .Road2)]
   consume;
#let three =
#   ((nodesRel feed
#     fullSectionsView feed
#     sortby [sectionId]
#     project [streetId,sectionId,startNodeId,endNodeId,streetData,sectionData,oneWay,streetStartNodeId,streetEndNodeId] {a}
#     symmjoin [((.NodeId = ..startNodeId_a)) or
#        ((.NodeId = ..endNodeId_a))])
#    fullSectionsView feed
#    sortby [sectionId]
#    project [streetId,sectionId,startNodeId,endNodeId,streetData,sectionData,oneWay,streetStartNodeId,streetEndNodeId] {b}
#    symmjoin [((.NodeId = ..startNodeId_b)) or
#       ((.NodeId = ..endNodeId_b))]
#    filter [.sectionId_a < .sectionId_b])
#   fullSectionsView feed
#   sortby [sectionId]
#   project [streetId,sectionId,startNodeId,endNodeId,streetData,sectionData,oneWay,streetStartNodeId,streetEndNodeId] {c}
#   symmjoin [((.NodeId = ..startNodeId_c)) or
#      ((.NodeId = ..endNodeId_c))]
#   extend [
#      Road1: .streetId_a,
#      Road2: .streetId_b,
#      Road3: .streetId_c]
#   filter [((((.NodeId = .startNodeId_b) and (.streetStartNodeId_b = .startNodeId_b)) or ((.NodeId = .endNodeId_b) and (.streetEndNodeId_b = .endNodeId_b))) and (.sectionId_a < .sectionId_c) and (.Road1 = .Road3) and not(.Road1 = .Road2)) or
#      ((((.NodeId = .startNodeId_a) and (.streetStartNodeId_a = .startNodeId_a)) or ((.NodeId = .endNodeId_a) and (.streetEndNodeId_a = .endNodeId_a))) and (.sectionId_c < .sectionId_b) and (.Road2 = .Road3) and not(.Road1 = .Road2))]
#   project [Road1,Road2,Node]
#   consume;
let three =
   ((startSections feed
    endSections feed
    concat
    sortby [sectionId]) {a}   
   (startSections feed
    endSections feed
    concat
    sortby [sectionId]) {b}
    hashjoin [NodeId_a,NodeId_b]
    filter [.sectionId_a < .sectionId_b])
   (startSections feed
    endSections feed
    concat
    sortby [sectionId]) {c}
    hashjoin [NodeId_a,NodeId_c]
   extend [
      Road1: .streetId_a,
      Road2: .streetId_b,
      Road3: .streetId_c,
      NodeId: .NodeId_a,
      Node: .Node_a]
   filter [
      ((((.NodeId = .startNodeId_b) and (.streetStartNodeId_b = .startNodeId_b))
        or ((.NodeId = .endNodeId_b) and (.streetEndNodeId_b = .endNodeId_b)))
       and (.sectionId_a < .sectionId_c) and (.Road1 = .Road3) and not(.Road1 = .Road2))
      or
      ((((.NodeId = .startNodeId_a) and (.streetStartNodeId_a = .startNodeId_a))
        or ((.NodeId = .endNodeId_a) and (.streetEndNodeId_a = .endNodeId_a)))
       and (.sectionId_c < .sectionId_b) and (.Road2 = .Road3) and not(.Road1 = .Road2))]
   project [Road1,Road2,Node]
   consume;
let four =
   (((nodesRel feed
      fullSectionsView feed
      sortby [sectionId]
      project [streetId,sectionId,startNodeId,endNodeId,streetData,sectionData,oneWay] {a}
      symmjoin [((.NodeId = ..startNodeId_a)) or ((.NodeId = ..endNodeId_a))])
     fullSectionsView feed
     sortby [sectionId]
     project [streetId,sectionId,startNodeId,endNodeId,streetData,sectionData,oneWay] {b}
     symmjoin [((.NodeId = ..startNodeId_b)) or ((.NodeId = ..endNodeId_b))]
     filter [.sectionId_a < .sectionId_b])
    fullSectionsView feed
    sortby [sectionId]
    project [streetId,sectionId,startNodeId,endNodeId,streetData,sectionData,oneWay] {c}
    symmjoin [((.NodeId = ..startNodeId_c)) or ((.NodeId = ..endNodeId_c))]
    filter [.sectionId_a < .sectionId_c])
   fullSectionsView feed
   sortby [sectionId]
   project [streetId,sectionId,startNodeId,endNodeId,streetData,sectionData,oneWay] {d}
   symmjoin [((.NodeId = ..startNodeId_d)) or ((.NodeId = ..endNodeId_d))]
   filter [.sectionId_b < .sectionId_d]
   extend [
      Road1: .streetId_a,
      Road2: .streetId_b,
      Road3: .streetId_c,
      Road4: .streetId_d]
   filter [(.Road1 = .Road3) and (.Road2 = .Road4) and not(.Road1 = .Road2)]
   project [Road1,Road2,Node]
   consume;
let targetRel =
   (two feed
    three feed concat)
   four feed concat
   consume;

# Using left outer join to add the different restrictions to crossings
# that share the same junction and the same incoming street
let road1ToRoad2 = 
   ((((targetRel feed
       onlyRestrictions feed
       symmouterjoin [(.Node = ..viaNode) and
          (.Road1 = ..fromStreetRef)]
       filter [isdefined(.Node)])
      noUturnRestrictions feed {u}
      symmouterjoin [(.Node = ..viaNode_u) and
         (.Road1 = ..fromStreetRef_u)]
      filter [isdefined(.Node)])
     noLeftTurnRestrictions feed {l}
     symmouterjoin [(.Node = ..viaNode_l) and
        (.Road1 = ..fromStreetRef_l)]
     filter [isdefined(.Node)])
    noStraightOnRestrictions feed {s}
    symmouterjoin [(.Node = ..viaNode_s) and
       (.Road1 = ..fromStreetRef_s)]
    filter [isdefined(.Node)])
   noRightTurnRestrictions feed {r}
   symmouterjoin [(.Node = ..viaNode_r) and (.Road1 = ..fromStreetRef_r)]
   filter [isdefined(.Node)]
   extend [
      Road1ToRoad2:
# matching "only_..."
      (isdefined(.viaNode) and
      .only and
      (.Road1 = .fromStreetRef) and
      (.Road2 = .toStreetRef)) or
# no contradictory "only_..."
      (not(isdefined(.viaNode)) and
# as well as no restrictive restrictions
# no "no_u_turn"
       not(isdefined(.viaNode_u) and
       (.Road2 = .toStreetRef_u) and
       .noUturn_u) and
# no "no_left_turn"
       not(isdefined(.viaNode_l) and
       (.Road2 = .toStreetRef_l) and
       .noLeftTurn_l) and
# no "no_straight_on"
       not(isdefined(.viaNode_s) and
       (.Road2 = .toStreetRef_s) and
       .noStraightOn_s) and
# no "no_right_turn"
       not(isdefined(.viaNode_r) and
       (.Road2 = .toStreetRef_r) and
       .noRightTurn_r)),
      Road1ToRoad1:
# no "no_u_turn" on same street
         not(isdefined(.viaNode_u) and
         (.Road1 = .toStreetRef_u) and
         .noUturn_u)]
   remove [fromStreetRef,fromStreetRef_u,fromStreetRef_l,fromStreetRef_s,
           fromStreetRef_r,toStreetRef,toStreetRef_u,toStreetRef_l,
           toStreetRef_s,toStreetRef_r,viaNodeRef,viaNodeRef_u,
           viaNodeRef_l,viaNodeRef_s,viaNodeRef_r,viaNode,viaNode_u,
           viaNode_l,viaNode_s,viaNode_r,restriction,only,noUturn_u,
           noLeftTurn_l,noStraightOn_s,noRightTurn_r]
   consume;

let road2ToRoad1 = 
   ((((targetRel feed
       onlyRestrictions feed
       symmouterjoin [(.Node = ..viaNode) and
          (.Road2 = ..fromStreetRef)]
       filter [isdefined(.Node)])
      noUturnRestrictions feed {u}
      symmouterjoin [(.Node = ..viaNode_u) and
         (.Road2 = ..fromStreetRef_u)]
      filter [isdefined(.Node)])
     noLeftTurnRestrictions feed {l}
     symmouterjoin [(.Node = ..viaNode_l) and
        (.Road2 = ..fromStreetRef_l)]
     filter [isdefined(.Node)])
    noStraightOnRestrictions feed {s}
    symmouterjoin [(.Node = ..viaNode_s) and
       (.Road2 = ..fromStreetRef_s)]
    filter [isdefined(.Node)])
   noRightTurnRestrictions feed {r}
   symmouterjoin [(.Node = ..viaNode_r) and (.Road2 = ..fromStreetRef_r)]
   filter [isdefined(.Node)]
   extend [
      Road2ToRoad1:
# matching "only_..."
      (isdefined(.viaNode) and
      .only and
      (.Road2 = .fromStreetRef) and
      (.Road1 = .toStreetRef)) or
# no contradictory "only_..."
      (not(isdefined(.viaNode)) and
# as well as no restrictive restrictions
# no "no_u_turn"
       not(isdefined(.viaNode_u) and
       (.Road1 = .toStreetRef_u) and
       .noUturn_u) and
# no "no_left_turn"
       not(isdefined(.viaNode_l) and
       (.Road1 = .toStreetRef_l) and
       .noLeftTurn_l) and
# no "no_straight_on"
       not(isdefined(.viaNode_s) and
       (.Road1 = .toStreetRef_s) and
       .noStraightOn_s) and
# no "no_right_turn"
       not(isdefined(.viaNode_r) and
       (.Road1 = .toStreetRef_r) and
       .noRightTurn_r)),
      Road2ToRoad2:
# no "no_u_turn" on same street
         not(isdefined(.viaNode_u) and
         (.Road2 = .toStreetRef_u) and
         .noUturn_u)]
   remove [fromStreetRef,fromStreetRef_u,fromStreetRef_l,fromStreetRef_s,
           fromStreetRef_r,toStreetRef,toStreetRef_u,toStreetRef_l,
           toStreetRef_s,toStreetRef_r,viaNodeRef,viaNodeRef_u,
           viaNodeRef_l,viaNodeRef_s,viaNodeRef_r,viaNode,viaNode_u,
           viaNode_l,viaNode_s,viaNode_r,restriction,only,noUturn_u,
           noLeftTurn_l,noStraightOn_s,noRightTurn_r]
   consume;

#TODO Add road1ToRoad1 and road2ToRoad2
