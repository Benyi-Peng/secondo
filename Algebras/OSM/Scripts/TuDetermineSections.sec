################################################################################
### Determing sections from imported OSM data (5 / 11)
################################################################################
### Description:
### - This script determines sections within streets.
### Please, see tu_shp_import.sh for further details.
###
### Preconditions:
### - activated necessary algebras
### for spatialjoin-operator HadoopParallelAlgebra
### - existing open database with successfully imported osm data
### - extStreetsRel-relation
### extStreetsRel: rel{geoData: sline, streetId: int, name: string,
###                    ref: string, roadClassRef: int, oneWay: int,
###                    bridge: int, maxSpeed: int, tunnel: bool,
###                    layer: int, groupId: int}
###
### Postconditions:
### - already existing relations
### - extSectionsRel-relation
### extSectionsRel: rel{SectionId: int, Section: sline, StartNodeId: int,
###                     EndNodeId: int, StreetId: int, GroupId: int,
###                     SectionDist: real}
### - nodesRel-relation
### nodesRel: rel{Node: point, NodeId: int}
###
### Author:
### - Thomas Uchdorf, t.uchdorf@arcor.de
################################################################################

# Computing all junctions and terminating points by finding the existing
# crossings between streets and adding terminating points
let juncTermPts =
   (extStreetsRel feed
    project [streetId,geoData,layer] {s1}
    extStreetsRel feed
    project [streetId,geoData,layer] {s2}
    spatialjoin [geoData_s1, geoData_s2]
    filter[(.streetId_s1 < .streetId_s2) and (.layer_s1 = .layer_s2)]
    projectextend[; Crossroads: crossings(.geoData_s1, .geoData_s2)]
    filter[not(isempty(.Crossroads))]
    aggregateB[Crossroads; 
       fun(P1: points, P2: points) P1 union P2; 
          [const points value ()]])
    union
   (extStreetsRel feed
    projectextend[; B : boundary(toline(.geoData))]
    aggregateB[B; 
       fun(P3 : points, P4 : points) P3 union P4; 
          [const points value ()]]
   );

# Alternative much faster solution (unfortunately not working due to rounding
# errors)
#TODO Continue iff there is any time left
#let sectionPts =
#   (extStreetsRel feed
#    project [streetId,geoData,layer] {s1}
#    extStreetsRel feed
#    project [streetId,geoData,layer] {s2}
#    spatialjoin [geoData_s1, geoData_s2]
#    filter[(.streetId_s1 < .streetId_s2) and (.layer_s1 = .layer_s2)]
#    filter[.geoData_s1 intersects .geoData_s2]
#    projectextend[; 
#       Road1: .streetId_s1,
#       Road2: .streetId_s2,
#       Crossroads: crossings(.geoData_s1, .geoData_s2)]
#    filter[(isdefined(.Crossroads)) and (not(isempty(.Crossroads)))]
#    projectextendstream [Road1,Road2; Pt: components(.Crossroads)])
#   (extStreetsRel feed
#    projectextend [; 
#       Road1: .streetId,
#       Road2: .streetId,
#       B: boundary(toline(.geoData))]
#    projectextendstream [Road1,Road2; Pt: components(.B)]
#   )
#   concat
#   consume;
#query
#   (extStreetsRel feed
#    project [streetId,geoData] {s1}
#    sectionPts feed
#    hashjoin [streetId_s1,Road1,99997])
#   extStreetsRel feed
#   project [streetId,geoData] {s2}
#   hashjoin[Road2,streetId_s2,99997]
#   filter [(.Pt inside toline(.geoData_s1)) and
#           (.Pt inside toline(.geoData_s2))]
#   extend [
#      dist1:
#         ifthenelse(.Road1=.Road2,
#            0.,atpoint(.geoData_s1,.Pt,TRUE)),
#      dist2:
#         ifthenelse(.Road1=.Road2,
#            size(.geoData_s1),atpoint(.geoData_s2,.Pt,TRUE))]
#   sortby [Road1,dist1,dist2]
#   addcounter[sectionID,1]
#   count

# Splitting up all streets into sections
let stsPlusSecsTmp =
   extStreetsRel feed
   projectextend [; 
      GroupId: .groupId, 
      StreetId: .streetId,
      Street: .geoData,
      UndirStreet: toline(.geoData)]
   extend [Pts: intersection(juncTermPts,.UndirStreet)]
   projectextendstream [GroupId,StreetId,Street; 
      Section: (.UndirStreet polylines [FALSE,.Pts])]
   consume;

# Creating a relation for the sections by removing duplicates
let sectionsTmp =
   stsPlusSecsTmp feed
   project [Section]
   sortby [Section]
   rdup
   addcounter[SectionId, 1] 
   extend [Pts: boundary(.Section)] 
   projectextend [SectionId, Section;  
      Help: fromline(.Section),
      Node1: get(.Pts,0), 
      Node2: get(.Pts,1)]
   consume;

# Removing the help points
delete juncTermPts;

# Collecting all nodes (junctions and end points) in one point array and
# adding IDs to the nodes to form a relation
let nodesRel =
   components(
      sectionsTmp feed
      projectextend[; EndPoints: boundary(.Section)]
      aggregateB[EndPoints; 
         fun(P1: points, P2: points) P1 union P2 ; 
            [const points value ()]])
   namedtransformstream [Node]
   addcounter [NodeId,1]
   consume;

# Adding indexes for faster access
derive nodesRel_NodeId_btree =
   nodesRel createbtree[NodeId];
derive nodesRel_Node_rtree =
   nodesRel creatertree[Node];

# Combining source and destination points with sections between them
# (adding references to nodes)
# sectionsRel: rel{SectionId: int, Section: line, Node1: point,
#                  Node2: point, Node1Id: int, Node2Id: int}
let sectionsRel =
   (sectionsTmp feed
    nodesRel feed {a}
    hashjoin[Node1, Node_a, 99997])
   nodesRel feed {b}
   hashjoin[Node2, Node_b, 99997]
   projectextend [SectionId, Section, Help, Node1, Node2; 
      Node1Id: .NodeId_a, Node2Id: .NodeId_b]
   consume;

# Removing the help relation
delete sectionsTmp;

# Adding indexes for faster access
derive sectionsRel_SectionId_btree =
   sectionsRel createbtree[SectionId];
derive sectionsRel_Node1Id_btree =
   sectionsRel createbtree[Node1Id];
derive sectionsRel_Node2Id_btree =
   sectionsRel createbtree[Node2Id];
derive sectionsRel_Section_rtree =
   sectionsRel creatertree[Section];

# Creating a relation that enables linking sections to additional street
# data like speed limits or names and combining the order by group ID, 
# street ID and distance on street with the section ID
let extSectionsRel =
   (stsPlusSecsTmp feed
    projectextend [GroupId,StreetId,Street; Part: .Section]
    sectionsRel feed
    hashjoin [Part,Section,99997]
    remove [Part,Section]
    extend [
       Node1Dist: atpoint(.Street,.Node1,TRUE),
       Node2Dist: atpoint(.Street,.Node2,TRUE)]
    extend [startNode:
               ifthenelse(.Node1Dist < .Node2Dist, .Node1, .Node2),
            endNode:
               ifthenelse(.Node1Dist < .Node2Dist, .Node2, .Node1),
            StartNodeId:
               ifthenelse(.Node1Dist < .Node2Dist, .Node1Id, .Node2Id),
            EndNodeId:
               ifthenelse(.Node1Dist < .Node2Dist, .Node2Id, .Node1Id)]
    extend [
       LowerStreetDist: ifthenelse(.Node1Dist < .Node2Dist,
          .Node1Dist, .Node2Dist),
       HigherStreetDist: ifthenelse(.Node1Dist < .Node2Dist,
          .Node2Dist, .Node1Dist),
       SectionDist: size(.Help)]
    extend [Section:
       ifthenelse(
          .SectionDist = .HigherStreetDist,
          set_startsmaller(.Help,
             get_startsmaller(.Street)),
          set_startsmaller(.Help,
             get_startsmaller(create_sline(.startNode,.endNode))))]
    project[
       GroupId, StreetId, SectionId, Section, StartNodeId, EndNodeId,
       LowerStreetDist,HigherStreetDist,SectionDist])
   remove [SectionId]
   sortby [GroupId,StreetId,HigherStreetDist,LowerStreetDist]
   addcounter[SectionId, 1]
#   remove [StreetDist]
   consume;

# Postprocessing streets that start and end in the same point
# (their sections are computed in a wrong way, since their start and end
# point as well as their positions on the street can not be distinguished
# separately)
#...
update extSectionsRel :=
   (((((extStreetsRel feed
        extend [
           streetStartNode: atposition(.geoData,0.0,TRUE),
           streetEndNode: atposition(.geoData,size(.geoData),TRUE)]
        filter [.streetStartNode = .streetEndNode]
        extSectionsRel feed
        hashjoin [streetId,StreetId,99997])
        extSectionsRel feed {a}
        hashjoin [StreetId,StreetId_a,99997]
        filter [(.HigherStreetDist = .HigherStreetDist_a) and
           (.SectionId < .SectionId_a)])
        nodesRel feed {e} 
        hashjoin [streetStartNode,Node_e,99997] 
        remove [Node_e])
        nodesRel feed {f} 
        hashjoin [streetEndNode,Node_f,99997] 
        remove [Node_f]
        extend [StreetStartNodeId: .NodeId_e,StreetEndNodeId: .NodeId_f]
        projectextend [GroupId,StreetId,SectionId; 
           NewSection: set_startsmaller(.Section,not(get_startsmaller(.Section))),
           NewStartNodeId: .StreetStartNodeId,
           NewEndNodeId: .StartNodeId,
           NewHigherStreetDist: .LowerStreetDist,
           NewLowerStreetDist: .HigherStreetDist,
           NewSectionDist: .SectionDist] {n})
    extSectionsRel feed
    smouterjoin [SectionId_n,SectionId]
    projectextend [GroupId,StreetId; 
       Section:
          ifthenelse(isdefined(.SectionId_n),.NewSection_n,.Section),
       StartNodeId:
          ifthenelse(isdefined(.SectionId_n),.NewStartNodeId_n,.StartNodeId),
       EndNodeId:
          ifthenelse(isdefined(.SectionId_n),.NewEndNodeId_n,.EndNodeId),
       LowerStreetDist:
          ifthenelse(isdefined(.SectionId_n),
             .NewLowerStreetDist_n,.LowerStreetDist),
       HigherStreetDist:
          ifthenelse(isdefined(.SectionId_n),
             .NewHigherStreetDist_n,.HigherStreetDist),
       SectionDist:
          ifthenelse(isdefined(.SectionId_n),
             .NewSectionDist_n,.SectionDist)]
    sortby [GroupId,StreetId,HigherStreetDist,LowerStreetDist]
    addcounter[SectionId, 1]
    consume);

# Removing the help relations
delete sectionsRel;
delete stsPlusSecsTmp;

# Adding indexes for faster access
derive extSectionsRel_SectionId_btree =
   extSectionsRel createbtree[SectionId];
derive extSectionsRel_StartNodeId_btree =
   extSectionsRel createbtree[StartNodeId];
derive extSectionsRel_EndNodeId_btree =
   extSectionsRel createbtree[EndNodeId];
derive extSectionsRel_StreetId_btree =
   extSectionsRel createbtree[StreetId];
derive extSectionsRel_GroupId_btree =
   extSectionsRel createbtree[GroupId];
derive extSectionsRel_Section_rtree =
   extSectionsRel creatertree[Section];

#let streetToNumSections =
#   extSectionsRel feed
#   sortby [StreetId]
#   groupby [StreetId; NumSections: group count]
#   consume;

# Extending the restrictions-relation by references to the junction points
let extRestrictionsRel = 
   restrictionsRel feed
   nodesRel feed
   hashjoin [viaPoint,Node,99997]
   extend [fromStreetRef: .fromStreet, toStreetRef: .toStreet,
   viaNodeRef: .NodeId, viaNode: .viaPoint]
   remove [fromStreet, toStreet, viaPoint, NodeId, Node]
   consume;

# Removing the help relation
delete restrictionsRel;

# Splitting up the restrictions relation and distributing the restrictions to
# different relations
let onlyRestrictions =
   extRestrictionsRel feed
   extend [only: tostring(.restriction) starts "only"]
   filter [.only]
   remove [osmId,restrictionId]
   consume;
# restrictive restrictions have to be viewed separately since they otherwise
# multiply tuples in conjunction with crossings
let noUturnRestrictions =
   extRestrictionsRel feed
   filter [.restriction = "no_u_turn"]
   extend [noUturn: TRUE]
   remove [osmId,restriction,restrictionId]
   consume;
let noLeftTurnRestrictions =
   extRestrictionsRel feed
   filter [.restriction = "no_left_turn"]
   extend [noLeftTurn: TRUE]
   remove [osmId,restriction,restrictionId]
   consume;
let noStraightOnRestrictions =
   extRestrictionsRel feed
   filter [.restriction = "no_straight_on"]
   extend [noStraightOn: TRUE]
   remove [osmId,restriction,restrictionId]
   consume;
let noRightTurnRestrictions =
   extRestrictionsRel feed
   filter [.restriction = "no_right_turn"]
   extend [noRightTurn: TRUE]
   remove [osmId,restriction,restrictionId]
   consume;

