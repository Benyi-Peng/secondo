################################################################################
### Determing sections from imported OSM data (5 / 11)
################################################################################
### Description:
### - This script determines sections within streets.
### Please, see tu_shp_import.sh for further details.
###
### Preconditions:
### - activated necessary algebras
### for spatialjoin-operator HadoopParallelAlgebra
### - existing open database with successfully imported osm data
### - extStreetsRel-relation
### extStreetsRel: rel{geoData: sline, streetId: int, name: string, ref: string,
###                    roadClassRef: int, oneWay: int, bridge: int,
###                    maxSpeed: int, tunnel: bool, layer: int, groupId: int}
###
### Postconditions:
### - already existing relations
### - extSectionsRel-relation
### extSectionsRel: rel{SectionId: int, Section: sline, StartNodeId: int,
###                     EndNodeId: int, StreetId: int, GroupId: int,
###                     SectionDist: real}
### - nodesRel-relation
### nodesRel: rel{Node: point, NodeId: int}
###
### Author:
### - Thomas Uchdorf, t.uchdorf@arcor.de
################################################################################

# Creating one polyline from all the streets
let allStreetsTmp =
   extStreetsRel feed
   projecttransformstream [geoData]
   collect_line [TRUE];

# Sorting them according to the number of their segments
let allStreetsLine =
   components(allStreetsTmp) transformstream
   extend[numSeg: no_segments(.elem)]
   sortby[numSeg desc] extract[elem];

# Removing the help line
delete allStreetsTmp;

# Computing all junctions and terminating points by finding the existing
# crossings between streets and adding terminating points
let juncTermPts =
   (extStreetsRel feed {s1}
    extStreetsRel feed {s2}
    spatialjoin [geoData_s1, geoData_s2]
    filter[(.streetId_s1 < .streetId_s2) and (.layer_s1 = .layer_s2)]
    extend[Crossroads: crossings(.geoData_s1, .geoData_s2)]
    project[Crossroads]
    filter[not(isempty(.Crossroads))]
    aggregateB[Crossroads; 
       fun(P1: points, P2: points) P1 union P2; 
          [const points value ()]])
    union
   (extStreetsRel feed
    projectextend[; B : boundary(toline(.geoData))]
    aggregateB[B; 
       fun(P3 : points, P4 : points) P3 union P4; 
          [const points value ()]]
   );

# Splitting up all streets into sections and creating a relation
let sectionsTmp =
   allStreetsLine polylines[FALSE, juncTermPts]
   namedtransformstream[Section]
   addcounter[SectionId, 1]
   extend [Help: fromline(.Section)]
   extend [Pts: boundary(.Section)]
   projectextend [SectionId, Section, Help; 
      Node1: get(.Pts,0),
      Node2: get(.Pts,1)]
   consume;

# Removing the help line
delete allStreetsLine;

# Removing the help points
delete juncTermPts;

# Collecting all nodes (junctions and end points) in one point array
let nodesTmp =
   sectionsTmp feed
   projectextend[; EndPoints: boundary(.Section)]
   aggregateB[EndPoints; 
      fun(P1: points, P2: points) P1 union P2 ; 
         [const points value ()]];

# Adding IDs to the nodes to form a relation
let nodesRel =
   components(nodesTmp) namedtransformstream[Node]
   addcounter[NodeId,1]
   consume;

# Removing the help points
delete nodesTmp;

# Adding an index for faster access
derive nodesRel_NodeId_btree =
   nodesRel createbtree[NodeId];

# Combining source and destination points with sections between them
# (adding references to nodes)
# sectionsRel: rel{SectionId: int, Section: line, Node1: point,
#                  Node2: point, Node1Id: int, Node2Id: int}
let sectionsRel =
   (sectionsTmp feed {a}
    nodesRel feed {b}
    hashjoin[Node1_a, Node_b, 99997])
   nodesRel feed {c}
   hashjoin[Node2_a, Node_c, 99997]
   projectextend [; 
      SectionId: .SectionId_a, Section: .Section_a, Help: .Help_a,
      Node1: .Node1_a, Node2: .Node2_a, Node1Id: .NodeId_b, Node2Id: .NodeId_c]
   consume;

# Removing the help relation
delete sectionsTmp;

# Adding indexes for faster access
derive sectionsRel_SectionId_btree =
   sectionsRel createbtree[SectionId];
derive sectionsRel_Node1Id_btree =
   sectionsRel createbtree[Node1Id];
derive sectionsRel_Node2Id_btree =
   sectionsRel createbtree[Node2Id];
derive sectionsRel_Section_rtree =
   sectionsRel creatertree[Section];

# Creating a relation that enables linking sections to additional street
# data like speed limits or names
let extSectionsTmp =
   extStreetsRel feed
   projectextend [geoData; StreetId: .streetId, Street: toline(.geoData),
      GroupId: .groupId]
   sectionsRel feed
   spatialjoin [Street,Section]
   filter[ not(isempty(intersection(.Street,.Section))) ]
   remove [Section]
   extend [
      Node1Dist: atpoint(.geoData,.Node1,TRUE),
      Node2Dist: atpoint(.geoData,.Node2,TRUE)]
   extend [startNode: ifthenelse(.Node1Dist < .Node2Dist, .Node1, .Node2),
           endNode: ifthenelse(.Node1Dist < .Node2Dist, .Node2, .Node1),
           StartNodeId: ifthenelse(.Node1Dist < .Node2Dist, .Node1Id, .Node2Id),
           EndNodeId: ifthenelse(.Node1Dist < .Node2Dist, .Node2Id, .Node1Id)]
   extend [Section:
      set_startsmaller(.Help,
         get_startsmaller(create_sline(.startNode,.endNode)))]
#   extend [Section: create_sline(.startNode,.endNode)]
   extend [SectionDist: size(.Section)]
   extend [StreetDist: ifthenelse(.Node1Dist < .Node2Dist, .Node2Dist, .Node1Dist)]
   project[SectionId, Section, StartNodeId, EndNodeId, StreetId, GroupId,
      SectionDist, StreetDist]
   consume;
# Combining the order by group ID, street ID and distance on street with the
# section ID
let extSectionsRel =
   extSectionsTmp feed
   remove [SectionId]
   sortby [GroupId,StreetId,StreetDist]
   addcounter[SectionId, 1]
   remove [StreetDist]
   consume;

# Removing the help relation
delete extSectionsTmp;
delete sectionsRel;

# Adding indexes for faster access
derive extSectionsRel_SectionId_btree =
   extSectionsRel createbtree[SectionId];
derive extSectionsRel_StartNodeId_btree =
   extSectionsRel createbtree[StartNodeId];
derive extSectionsRel_EndNodeId_btree =
   extSectionsRel createbtree[EndNodeId];
derive extSectionsRel_StreetId_btree =
   extSectionsRel createbtree[StreetId];
derive extSectionsRel_GroupId_btree =
   extSectionsRel createbtree[GroupId];
derive extSectionsRel_Section_rtree =
   extSectionsRel creatertree[Section];

let streetToNumSections =
   extSectionsRel feed
   sortby_old [StreetId]
   groupby [StreetId; NumSections: group count]
   consume;

let extRestrictionsRel = 
   restrictionsRel feed
   nodesRel feed
   hashjoin [viaPoint,Node,99997]
   extend [fromStreetRef: .fromStreet, toStreetRef: .toStreet,
   viaNodeRef: .NodeId, viaNode: .viaPoint]
   remove [fromStreet, toStreet, viaPoint, NodeId, Node]
   consume;
# Splitting up the restrictions relation and distributing the restrictions to
# different relations
let onlyRestrictions =
   extRestrictionsRel feed
   extend [only: tostring(.restriction) starts "only"]
   filter [.only]
   remove [osmId,relationType,restrictionId]
   consume;
# restrictive restrictions have to be viewed separately since they otherwise
# multiply tuples in conjunction with crossings
let noUturnRestrictions =
   extRestrictionsRel feed
   filter [.restriction = "no_u_turn"]
   extend [noUturn: TRUE]
   remove [osmId,restriction,relationType,restrictionId]
   consume;
let noLeftTurnRestrictions =
   extRestrictionsRel feed
   filter [.restriction = "no_left_turn"]
   extend [noLeftTurn: TRUE]
   remove [osmId,restriction,relationType,restrictionId]
   consume;
let noStraightOnRestrictions =
   extRestrictionsRel feed
   filter [.restriction = "no_straight_on"]
   extend [noStraightOn: TRUE]
   remove [osmId,restriction,relationType,restrictionId]
   consume;
let noRightTurnRestrictions =
   extRestrictionsRel feed
   filter [.restriction = "no_right_turn"]
   extend [noRightTurn: TRUE]
   remove [osmId,restriction,relationType,restrictionId]
   consume;

