################################################################################
### Creating networks from imported OSM data (8 / 11)
################################################################################
### Description:
### - This script creates a relation containing junctions between two sections
### belonging to two streets.
### (the number 1 in the relation name stands for incoming, the number 2 means
### outgoing)
### Please, see tu_shp_import.sh for further details. 
###
### Preconditions:
### - activated necessary algebras
### - existing open database with successfully imported osm data
### - fullSectionsView-relation
###
### Postconditions:
### - twoSecJuncBtwTwoSts-relation
### twoSecJuncBtwTwoSts: rel{Road1: int, Pos1: double, Road2: int, Pos2: double,
###                          JunctionType: int}
###
### Author:
### - Thomas Uchdorf, t.uchdorf@arcor.de
################################################################################

#      |
#      |
#      |
#      v
#----->xxxxxx
#      x
#      x
#      x
#      x
let twoSecInZeroSecOut11JuncTmp =
   ((nodesRel feed
       fullSectionsView feed
       sortby [sectionId]
       filter [.streetEndNodeId = .endNodeId]
       project [streetId,sectionId,endNodeId,streetData,sectionData,oneWay] {a}     
       hashjoin [NodeId, endNodeId_a,99997])
      fullSectionsView feed
      sortby [sectionId]
      filter [.streetEndNodeId = .endNodeId]
      project [streetId,sectionId,endNodeId,streetData,sectionData,oneWay] {b} 
      hashjoin [NodeId,endNodeId_b,99997]
      filter [.sectionId_a < .sectionId_b])
   projectextend [; 
      Road1: .streetId_a,
      Pos1: atpoint(.streetData_a,.Node,TRUE),
      Road2: .streetId_b,
      Pos2: atpoint(.streetData_b,.Node,TRUE), 
      JunctionType: getconnectivitycode(1,2,0,0,.oneWay_a = 1,.oneWay_b = 1,FALSE,FALSE),
      Sec1: .sectionId_a,
      Sec2: .sectionId_b,
      Node: .Node,
      SecData1: .sectionData_a,
      SecData2: .sectionData_b]
   filter [not(.Road1 = .Road2)]
   consume;

#      ^
#      |
#      |
#      |
#----->xxxxxx
#      x
#      x
#      x
#      x
let oneSecInOneSecOut12JuncTmp =
   ((nodesRel feed
       fullSectionsView feed
       sortby [sectionId]
       filter [.streetEndNodeId = .endNodeId]
       project [streetId,sectionId,endNodeId,streetData,sectionData,oneWay] {a}     
       hashjoin [NodeId, endNodeId_a,99997])
      fullSectionsView feed
      sortby [sectionId]
      filter [.streetStartNodeId = .startNodeId]
      project [streetId,sectionId,startNodeId,streetData,sectionData,oneWay] {b} 
      hashjoin [NodeId,startNodeId_b,99997]
      filter [.sectionId_a < .sectionId_b])
   projectextend [; 
      Road1: .streetId_a,
      Pos1: atpoint(.streetData_a,.Node,TRUE), 
      Road2: .streetId_b,
      Pos2: atpoint(.streetData_b,.Node,TRUE),
      JunctionType: getconnectivitycode(1,1,0,0,.oneWay_a = 1,.oneWay_b = 1,FALSE,FALSE),
      Sec1: .sectionId_a,
      Sec2: .sectionId_b,
      Node: .Node,
      SecData1: .sectionData_a,
      SecData2: .sectionData_b]
   filter [not(.Road1 = .Road2)]
   consume;

#      |
#      |
#      |
#      v
#<-----xxxxxx
#      x
#      x
#      x
#      x
let oneSecInOneSecOut21JuncTmp =
   ((nodesRel feed
       fullSectionsView feed
       sortby [sectionId]
       filter [.streetStartNodeId = .startNodeId]
       project [streetId,sectionId,startNodeId,streetData,sectionData,oneWay] {a}     
       hashjoin [NodeId, startNodeId_a,99997])
      fullSectionsView feed
      sortby [sectionId]
      filter [.streetEndNodeId = .endNodeId]
      project [streetId,sectionId,endNodeId,streetData,sectionData,oneWay] {b} 
      hashjoin [NodeId,endNodeId_b,99997]
      filter [.sectionId_a < .sectionId_b])
   projectextend [; 
      Road1: .streetId_a,
      Pos1: atpoint(.streetData_a,.Node,TRUE), 
      Road2: .streetId_b,
      Pos2: atpoint(.streetData_b,.Node,TRUE),
      JunctionType: getconnectivitycode(2,2,0,0,.oneWay_a = 1,.oneWay_b = 1,FALSE,FALSE),
      Sec1: .sectionId_a,
      Sec2: .sectionId_b,
      Node: .Node,
      SecData1: .sectionData_a,
      SecData2: .sectionData_b]
   filter [not(.Road1 = .Road2)]
   consume;

#      ^
#      |
#      |
#      |
#<-----xxxxxx
#      x
#      x
#      x
#      x
let zeroSecInTwoSecOut22JuncTmp =
   ((nodesRel feed
       fullSectionsView feed
       sortby [sectionId]
       filter [.streetStartNodeId = .startNodeId]
       project [streetId,sectionId,startNodeId,streetData,sectionData,oneWay] {a}     
       hashjoin [NodeId, startNodeId_a,99997])
      fullSectionsView feed
      sortby [sectionId]
      filter [.streetStartNodeId = .startNodeId]
      project [streetId,sectionId,startNodeId,streetData,sectionData,oneWay] {b} 
      hashjoin [NodeId,startNodeId_b,99997]
      filter [.sectionId_a < .sectionId_b])
   projectextend [; 
      Road1: .streetId_a,
      Pos1: atpoint(.streetData_a,.Node,TRUE),
      Road2: .streetId_b,
      Pos2: atpoint(.streetData_b,.Node,TRUE),
      JunctionType: getconnectivitycode(2,1,0,0,.oneWay_a = 1,.oneWay_b = 1,FALSE,FALSE),
      Sec1: .sectionId_a,
      Sec2: .sectionId_b,
      Node: .Node,
      SecData1: .sectionData_a,
      SecData2: .sectionData_b]
   filter [not(.Road1 = .Road2)]
   consume;

# Creating the union
let twoSecJuncBtwTwoSts =
   ((twoSecInZeroSecOut11JuncTmp feed
     oneSecInOneSecOut12JuncTmp feed
     concat)
    oneSecInOneSecOut21JuncTmp feed
    concat)
   zeroSecInTwoSecOut22JuncTmp feed 
   concat
   consume;

