################################################################################
### Creating networks from imported OSM data (10 / 11)
################################################################################
### Description:
### - This script creates networks from imported OSM data.
### Please, see tu_shp_import.sh for further details. 
###
### Preconditions:
### - activated necessary algebras
### - existing open database with successfully imported osm data
### - extStreetsRel-relation
### extStreetsRel: rel{geoData: sline, streetId: int, name: string, ref: string,
###                    roadClass: string, oneWay: int, bridge: int,
###                    maxSpeed: int, tunnel: bool, layer: int, groupId: int}
### - nodesRel-relation
### nodesRel: rel{Node: point, NodeId: int}
### - extSectionsRel-relation
### extSectionsRel: rel{SectionId: int, Section: sline, StartNodeId: int,
###                     EndNodeId: int, StreetId: int, GroupId: int,
###                     SectionDist: real}
###
### Postconditions:
### - cityRoads-relation
### cityRoads: rel{Name: string, Road: int, Length: double, Geometry: line,
###                Dual: bool, StartsSmaller: bool, RoadLevel: int}
### - cityJunctions-relation
### cityJunctions: rel{Road1: int, Pos1: double, Road2: int, Pos2: double,
###                    JunctionType: int}
### - city-network
###
### Author:
### - Thomas Uchdorf, t.uchdorf@arcor.de
################################################################################

# Calculating junctions between four sections belonging to two streets
#      |
#      |
#      |
#      v
#----->x<-----
#      ^
#      |
#      |
#      |
let fourSecInZeroSecOut1111JuncTmp =
   ((((nodesRel feed
       fullSectionsView feed
       sortby [sectionId]
       project [streetId,sectionId,endNodeId,streetData,sectionData,oneWay] {a}     
       hashjoin [NodeId, endNodeId_a,99997])
      fullSectionsView feed
      sortby [sectionId]
      project [streetId,sectionId,endNodeId,streetData,sectionData,oneWay] {b} 
      hashjoin [NodeId,endNodeId_b,99997]
      filter [.sectionId_a < .sectionId_b])
     fullSectionsView feed
     sortby [sectionId]
     project [streetId,sectionId,endNodeId,streetData,sectionData,oneWay] {c}
     hashjoin [NodeId,endNodeId_c,99997]
     filter [.sectionId_a < .sectionId_c])
    fullSectionsView feed
    sortby [sectionId]
    project [streetId,sectionId,endNodeId,streetData,sectionData,oneWay] {d} 
    hashjoin [NodeId,endNodeId_d,99997]
    filter [.sectionId_b < .sectionId_d])
   projectextend [; 
      Road1: .streetId_a,
      Pos1: atpoint(.streetData_a,.Node,TRUE),
#         * size(.streetData_a,create_geoid("WGS1984")) / size(.streetData_a),
      Road2: .streetId_b,
      Pos2: atpoint(.streetData_b,.Node,TRUE),
#         * size(.streetData_b,create_geoid("WGS1984")) / size(.streetData_b),
      Road3: .streetId_c,
      Road4: .streetId_d,
      JunctionType: getconnectivitycode(1,2,2,1,.oneWay_a = 1,.oneWay_b = 1,.oneWay_c = 1,.oneWay_d = 1),
      Sec1: .sectionId_a,
      Sec2: .sectionId_b,
      Sec3: .sectionId_c,
      Sec4: .sectionId_d,
      Node: .Node,
      SecData1: .sectionData_a,
      SecData2: .sectionData_b,
      SecData3: .sectionData_c,
      SecData4: .sectionData_d]
   filter [(.Road1 = .Road3) and (.Road2 = .Road4) and not(.Road1 = .Road2)]
   consume;

#      |
#      |
#      |
#      v
#<-----x<-----
#      ^
#      |
#      |
#      |
let threeSecInOneSecOut2111JuncTmp =
   ((((nodesRel feed
       fullSectionsView feed
       sortby [sectionId]
       project [streetId,sectionId,startNodeId,streetData,sectionData,oneWay] {a}     
       hashjoin [NodeId, startNodeId_a,99997])
      fullSectionsView feed
      sortby [sectionId]
      project [streetId,sectionId,endNodeId,streetData,sectionData,oneWay] {b} 
      hashjoin [NodeId,endNodeId_b,99997]
      filter [.sectionId_a < .sectionId_b])
     fullSectionsView feed
     sortby [sectionId]
     project [streetId,sectionId,endNodeId,streetData,sectionData,oneWay] {c}
     hashjoin [NodeId,endNodeId_c,99997]
     filter [.sectionId_a < .sectionId_c])
    fullSectionsView feed
    sortby [sectionId]
    project [streetId,sectionId,endNodeId,streetData,sectionData,oneWay] {d} 
    hashjoin [NodeId,endNodeId_d,99997]
    filter [.sectionId_b < .sectionId_d])
   projectextend [; 
      Road1: .streetId_a,
      Pos1: atpoint(.streetData_a,.Node,TRUE),
#         * size(.streetData_a,create_geoid("WGS1984")) / size(.streetData_a),
      Road2: .streetId_b,
      Pos2: atpoint(.streetData_b,.Node,TRUE),
#         * size(.streetData_b,create_geoid("WGS1984")) / size(.streetData_b),
      Road3: .streetId_c,
      Road4: .streetId_d,
      JunctionType: getconnectivitycode(2,2,2,1,
         .oneWay_a = 1,.oneWay_b = 1,.oneWay_c = 1,.oneWay_d = 1),
      Sec1: .sectionId_a,
      Sec2: .sectionId_b,
      Sec3: .sectionId_c,
      Sec4: .sectionId_d,
      Node: .Node,
      SecData1: .sectionData_a,
      SecData2: .sectionData_b,
      SecData3: .sectionData_c,
      SecData4: .sectionData_d]
   filter [(.Road1 = .Road3) and (.Road2 = .Road4) and not(.Road1 = .Road2)]
   consume;

#      ^
#      |
#      |
#      |
#----->x<-----
#      ^
#      |
#      |
#      |
let threeSecInOneSecOut1211JuncTmp =
   ((((nodesRel feed
       fullSectionsView feed
       sortby [sectionId]
       project [streetId,sectionId,endNodeId,streetData,sectionData,oneWay] {a}     
       hashjoin [NodeId, endNodeId_a,99997])
      fullSectionsView feed
      sortby [sectionId]
      project [streetId,sectionId,startNodeId,streetData,sectionData,oneWay] {b} 
      hashjoin [NodeId,startNodeId_b,99997]
      filter [.sectionId_a < .sectionId_b])
     fullSectionsView feed
     sortby [sectionId]
     project [streetId,sectionId,endNodeId,streetData,sectionData,oneWay] {c}
     hashjoin [NodeId,endNodeId_c,99997]
     filter [.sectionId_a < .sectionId_c])
    fullSectionsView feed
    sortby [sectionId]
    project [streetId,sectionId,endNodeId,streetData,sectionData,oneWay] {d} 
    hashjoin [NodeId,endNodeId_d,99997]
    filter [.sectionId_b < .sectionId_d])
   projectextend [; 
      Road1: .streetId_a,
      Pos1: atpoint(.streetData_a,.Node,TRUE),
#         * size(.streetData_a,create_geoid("WGS1984")) / size(.streetData_a),
      Road2: .streetId_b,
      Pos2: atpoint(.streetData_b,.Node,TRUE),
#         * size(.streetData_b,create_geoid("WGS1984")) / size(.streetData_b),
      Road3: .streetId_c,
      Road4: .streetId_d,
      JunctionType: getconnectivitycode(1,1,2,1,
         .oneWay_a = 1,.oneWay_b = 1,.oneWay_c = 1,.oneWay_d = 1),
      Sec1: .sectionId_a,
      Sec2: .sectionId_b,
      Sec3: .sectionId_c,
      Sec4: .sectionId_d,
      Node: .Node,
      SecData1: .sectionData_a,
      SecData2: .sectionData_b,
      SecData3: .sectionData_c,
      SecData4: .sectionData_d]
   filter [(.Road1 = .Road3) and (.Road2 = .Road4) and not(.Road1 = .Road2)]
   consume;

#      |
#      |
#      |
#      v
#----->x----->
#      ^
#      |
#      |
#      |
let threeSecInOneSecOut1121JuncTmp =
   ((((nodesRel feed
       fullSectionsView feed
       sortby [sectionId]
       project [streetId,sectionId,endNodeId,streetData,sectionData,oneWay] {a}     
       hashjoin [NodeId, endNodeId_a,99997])
      fullSectionsView feed
      sortby [sectionId]
      project [streetId,sectionId,endNodeId,streetData,sectionData,oneWay] {b} 
      hashjoin [NodeId,endNodeId_b,99997]
      filter [.sectionId_a < .sectionId_b])
     fullSectionsView feed
     sortby [sectionId]
     project [streetId,sectionId,startNodeId,streetData,sectionData,oneWay] {c}
     hashjoin [NodeId,startNodeId_c,99997]
     filter [.sectionId_a < .sectionId_c])
    fullSectionsView feed
    sortby [sectionId]
    project [streetId,sectionId,endNodeId,streetData,sectionData,oneWay] {d} 
    hashjoin [NodeId,endNodeId_d,99997]
    filter [.sectionId_b < .sectionId_d])
   projectextend [; 
      Road1: .streetId_a,
      Pos1: atpoint(.streetData_a,.Node,TRUE),
#         * size(.streetData_a,create_geoid("WGS1984")) / size(.streetData_a),
      Road2: .streetId_b,
      Pos2: atpoint(.streetData_b,.Node,TRUE),
#         * size(.streetData_b,create_geoid("WGS1984")) / size(.streetData_b),
      Road3: .streetId_c,
      Road4: .streetId_d,
      JunctionType: getconnectivitycode(1,2,1,1,
         .oneWay_a = 1,.oneWay_b = 1,.oneWay_c = 1,.oneWay_d = 1),
      Sec1: .sectionId_a,
      Sec2: .sectionId_b,
      Sec3: .sectionId_c,
      Sec4: .sectionId_d,
      Node: .Node,
      SecData1: .sectionData_a,
      SecData2: .sectionData_b,
      SecData3: .sectionData_c,
      SecData4: .sectionData_d]
   filter [(.Road1 = .Road3) and (.Road2 = .Road4) and not(.Road1 = .Road2)]
   consume;

#      |
#      |
#      |
#      v
#----->x<-----
#      |
#      |
#      |
#      v
let threeSecInOneSecOut1112JuncTmp =
   ((((nodesRel feed
       fullSectionsView feed
       sortby [sectionId]
       project [streetId,sectionId,endNodeId,streetData,sectionData,oneWay] {a}     
       hashjoin [NodeId, endNodeId_a,99997])
      fullSectionsView feed
      sortby [sectionId]
      project [streetId,sectionId,endNodeId,streetData,sectionData,oneWay] {b} 
      hashjoin [NodeId,endNodeId_b,99997]
      filter [.sectionId_a < .sectionId_b])
     fullSectionsView feed
     sortby [sectionId]
     project [streetId,sectionId,endNodeId,streetData,sectionData,oneWay] {c}
     hashjoin [NodeId,endNodeId_c,99997]
     filter [.sectionId_a < .sectionId_c])
    fullSectionsView feed
    sortby [sectionId]
    project [streetId,sectionId,startNodeId,streetData,sectionData,oneWay] {d} 
    hashjoin [NodeId,startNodeId_d,99997]
    filter [.sectionId_b < .sectionId_d])
   projectextend [; 
      Road1: .streetId_a,
      Pos1: atpoint(.streetData_a,.Node,TRUE),
#         * size(.streetData_a,create_geoid("WGS1984")) / size(.streetData_a),
      Road2: .streetId_b,
      Pos2: atpoint(.streetData_b,.Node,TRUE),
#         * size(.streetData_b,create_geoid("WGS1984")) / size(.streetData_b),
      Road3: .streetId_c,
      Road4: .streetId_d,
      JunctionType: getconnectivitycode(1,2,2,2,
         .oneWay_a = 1,.oneWay_b = 1,.oneWay_c = 1,.oneWay_d = 1),
      Sec1: .sectionId_a,
      Sec2: .sectionId_b,
      Sec3: .sectionId_c,
      Sec4: .sectionId_d,
      Node: .Node,
      SecData1: .sectionData_a,
      SecData2: .sectionData_b,
      SecData3: .sectionData_c,
      SecData4: .sectionData_d]
   filter [(.Road1 = .Road3) and (.Road2 = .Road4) and not(.Road1 = .Road2)]
   consume;

#      ^
#      |
#      |
#      |
#<-----x<-----
#      ^
#      |
#      |
#      |
let twoSecInTwoSecOut2211JuncTmp =
   ((((nodesRel feed
       fullSectionsView feed
       sortby [sectionId]
       project [streetId,sectionId,startNodeId,streetData,sectionData,oneWay] {a}     
       hashjoin [NodeId, startNodeId_a,99997])
      fullSectionsView feed
      sortby [sectionId]
      project [streetId,sectionId,startNodeId,streetData,sectionData,oneWay] {b} 
      hashjoin [NodeId,startNodeId_b,99997]
      filter [.sectionId_a < .sectionId_b])
     fullSectionsView feed
     sortby [sectionId]
     project [streetId,sectionId,endNodeId,streetData,sectionData,oneWay] {c}
     hashjoin [NodeId,endNodeId_c,99997]
     filter [.sectionId_a < .sectionId_c])
    fullSectionsView feed
    sortby [sectionId]
    project [streetId,sectionId,endNodeId,streetData,sectionData,oneWay] {d} 
    hashjoin [NodeId,endNodeId_d,99997]
    filter [.sectionId_b < .sectionId_d])
   projectextend [; 
      Road1: .streetId_a,
      Pos1: atpoint(.streetData_a,.Node,TRUE),
#         * size(.streetData_a,create_geoid("WGS1984")) / size(.streetData_a),
      Road2: .streetId_b,
      Pos2: atpoint(.streetData_b,.Node,TRUE), 
#         * size(.streetData_b,create_geoid("WGS1984")) / size(.streetData_b),
      Road3: .streetId_c,
      Road4: .streetId_d,
      JunctionType: getconnectivitycode(2,1,2,1,
         .oneWay_a = 1,.oneWay_b = 1,.oneWay_c = 1,.oneWay_d = 1),
      Sec1: .sectionId_a,
      Sec2: .sectionId_b,
      Sec3: .sectionId_c,
      Sec4: .sectionId_d,
      Node: .Node,
      SecData1: .sectionData_a,
      SecData2: .sectionData_b,
      SecData3: .sectionData_c,
      SecData4: .sectionData_d]
   filter [(.Road1 = .Road3) and (.Road2 = .Road4) and not(.Road1 = .Road2)]
   consume;

#      |
#      |
#      |
#      v
#<-----x----->
#      ^
#      |
#      |
#      |
let twoSecInTwoSecOut2121JuncTmp =
   ((((nodesRel feed
       fullSectionsView feed
       sortby [sectionId]
       project [streetId,sectionId,startNodeId,streetData,sectionData,oneWay] {a}     
       hashjoin [NodeId, startNodeId_a,99997])
      fullSectionsView feed
      sortby [sectionId]
      project [streetId,sectionId,endNodeId,streetData,sectionData,oneWay] {b} 
      hashjoin [NodeId,endNodeId_b,99997]
      filter [.sectionId_a < .sectionId_b])
     fullSectionsView feed
     sortby [sectionId]
     project [streetId,sectionId,startNodeId,streetData,sectionData,oneWay] {c}
     hashjoin [NodeId,startNodeId_c,99997]
     filter [.sectionId_a < .sectionId_c])
    fullSectionsView feed
    sortby [sectionId]
    project [streetId,sectionId,endNodeId,streetData,sectionData,oneWay] {d} 
    hashjoin [NodeId,endNodeId_d,99997]
    filter [.sectionId_b < .sectionId_d])
   projectextend [; 
      Road1: .streetId_a,
      Pos1: atpoint(.streetData_a,.Node,TRUE),
#         * size(.streetData_a,create_geoid("WGS1984")) / size(.streetData_a),
      Road2: .streetId_b,
      Pos2: atpoint(.streetData_b,.Node,TRUE), 
#         * size(.streetData_b,create_geoid("WGS1984")) / size(.streetData_b),
      Road3: .streetId_c,
      Road4: .streetId_d,
      JunctionType: getconnectivitycode(2,2,1,1,
         .oneWay_a = 1,.oneWay_b = 1,.oneWay_c = 1,.oneWay_d = 1),
      Sec1: .sectionId_a,
      Sec2: .sectionId_b,
      Sec3: .sectionId_c,
      Sec4: .sectionId_d,
      Node: .Node,
      SecData1: .sectionData_a,
      SecData2: .sectionData_b,
      SecData3: .sectionData_c,
      SecData4: .sectionData_d]
   filter [(.Road1 = .Road3) and (.Road2 = .Road4) and not(.Road1 = .Road2)]
   consume;

#      |
#      |
#      |
#      v
#<-----x<-----
#      |
#      |
#      |
#      v
let twoSecInTwoSecOut2112JuncTmp =
   ((((nodesRel feed
       fullSectionsView feed
       sortby [sectionId]
       project [streetId,sectionId,startNodeId,streetData,sectionData,oneWay] {a}     
       hashjoin [NodeId, startNodeId_a,99997])
      fullSectionsView feed
      sortby [sectionId]
      project [streetId,sectionId,endNodeId,streetData,sectionData,oneWay] {b} 
      hashjoin [NodeId,endNodeId_b,99997]
      filter [.sectionId_a < .sectionId_b])
     fullSectionsView feed
     sortby [sectionId]
     project [streetId,sectionId,endNodeId,streetData,sectionData,oneWay] {c}
     hashjoin [NodeId,endNodeId_c,99997]
     filter [.sectionId_a < .sectionId_c])
    fullSectionsView feed
    sortby [sectionId]
    project [streetId,sectionId,startNodeId,streetData,sectionData,oneWay] {d} 
    hashjoin [NodeId,startNodeId_d,99997]
    filter [.sectionId_b < .sectionId_d])
   projectextend [; 
      Road1: .streetId_a,
      Pos1: atpoint(.streetData_a,.Node,TRUE),
#         * size(.streetData_a,create_geoid("WGS1984")) / size(.streetData_a),
      Road2: .streetId_b,
      Pos2: atpoint(.streetData_b,.Node,TRUE), 
#         * size(.streetData_b,create_geoid("WGS1984")) / size(.streetData_b),
      Road3: .streetId_c,
      Road4: .streetId_d,
      JunctionType: getconnectivitycode(2,2,2,2,
         .oneWay_a = 1,.oneWay_b = 1,.oneWay_c = 1,.oneWay_d = 1),
      Sec1: .sectionId_a,
      Sec2: .sectionId_b,
      Sec3: .sectionId_c,
      Sec4: .sectionId_d,
      Node: .Node,
      SecData1: .sectionData_a,
      SecData2: .sectionData_b,
      SecData3: .sectionData_c,
      SecData4: .sectionData_d]
   filter [(.Road1 = .Road3) and (.Road2 = .Road4) and not(.Road1 = .Road2)]
   consume;

#      ^
#      |
#      |
#      |
#----->x----->
#      ^
#      |
#      |
#      |
let twoSecInTwoSecOut1221JuncTmp =
   ((((nodesRel feed
       fullSectionsView feed
       sortby [sectionId]
       project [streetId,sectionId,endNodeId,streetData,sectionData,oneWay] {a}     
       hashjoin [NodeId, endNodeId_a,99997])
      fullSectionsView feed
      sortby [sectionId]
      project [streetId,sectionId,startNodeId,streetData,sectionData,oneWay] {b} 
      hashjoin [NodeId,startNodeId_b,99997]
      filter [.sectionId_a < .sectionId_b])
     fullSectionsView feed
     sortby [sectionId]
     project [streetId,sectionId,startNodeId,streetData,sectionData,oneWay] {c}
     hashjoin [NodeId,startNodeId_c,99997]
     filter [.sectionId_a < .sectionId_c])
    fullSectionsView feed
    sortby [sectionId]
    project [streetId,sectionId,endNodeId,streetData,sectionData,oneWay] {d} 
    hashjoin [NodeId,endNodeId_d,99997]
    filter [.sectionId_b < .sectionId_d])
   projectextend [; 
      Road1: .streetId_a,
      Pos1: atpoint(.streetData_a,.Node,TRUE),
#         * size(.streetData_a,create_geoid("WGS1984")) / size(.streetData_a),
      Road2: .streetId_b,
      Pos2: atpoint(.streetData_b,.Node,TRUE), 
#         * size(.streetData_b,create_geoid("WGS1984")) / size(.streetData_b),
      Road3: .streetId_c,
      Road4: .streetId_d,
      JunctionType: getconnectivitycode(1,1,1,1,
         .oneWay_a = 1,.oneWay_b = 1,.oneWay_c = 1,.oneWay_d = 1),
      Sec1: .sectionId_a,
      Sec2: .sectionId_b,
      Sec3: .sectionId_c,
      Sec4: .sectionId_d,
      Node: .Node,
      SecData1: .sectionData_a,
      SecData2: .sectionData_b,
      SecData3: .sectionData_c,
      SecData4: .sectionData_d]
   filter [(.Road1 = .Road3) and (.Road2 = .Road4) and not(.Road1 = .Road2)]
   consume;

#      ^
#      |
#      |
#      |
#----->x<-----
#      |
#      |
#      |
#      v
let twoSecInTwoSecOut1212JuncTmp =
   ((((nodesRel feed
       fullSectionsView feed
       sortby [sectionId]
       project [streetId,sectionId,endNodeId,streetData,sectionData,oneWay] {a}     
       hashjoin [NodeId, endNodeId_a,99997])
      fullSectionsView feed
      sortby [sectionId]
      project [streetId,sectionId,startNodeId,streetData,sectionData,oneWay] {b} 
      hashjoin [NodeId,startNodeId_b,99997]
      filter [.sectionId_a < .sectionId_b])
     fullSectionsView feed
     sortby [sectionId]
     project [streetId,sectionId,endNodeId,streetData,sectionData,oneWay] {c}
     hashjoin [NodeId,endNodeId_c,99997]
     filter [.sectionId_a < .sectionId_c])
    fullSectionsView feed
    sortby [sectionId]
    project [streetId,sectionId,startNodeId,streetData,sectionData,oneWay] {d} 
    hashjoin [NodeId,startNodeId_d,99997]
    filter [.sectionId_b < .sectionId_d])
   projectextend [; 
      Road1: .streetId_a,
      Pos1: atpoint(.streetData_a,.Node,TRUE),
#         * size(.streetData_a,create_geoid("WGS1984")) / size(.streetData_a),
      Road2: .streetId_b,
      Pos2: atpoint(.streetData_b,.Node,TRUE), 
#         * size(.streetData_b,create_geoid("WGS1984")) / size(.streetData_b),
      Road3: .streetId_c,
      Road4: .streetId_d,
      JunctionType: getconnectivitycode(1,1,2,2,
         .oneWay_a = 1,.oneWay_b = 1,.oneWay_c = 1,.oneWay_d = 1),
      Sec1: .sectionId_a,
      Sec2: .sectionId_b,
      Sec3: .sectionId_c,
      Sec4: .sectionId_d,
      Node: .Node,
      SecData1: .sectionData_a,
      SecData2: .sectionData_b,
      SecData3: .sectionData_c,
      SecData4: .sectionData_d]
   filter [(.Road1 = .Road3) and (.Road2 = .Road4) and not(.Road1 = .Road2)]
   consume;

#      |
#      |
#      |
#      v
#----->x----->
#      |
#      |
#      |
#      v
let twoSecInTwoSecOut1122JuncTmp =
   ((((nodesRel feed
       fullSectionsView feed
       sortby [sectionId]
       project [streetId,sectionId,endNodeId,streetData,sectionData,oneWay] {a}     
       hashjoin [NodeId, endNodeId_a,99997])
      fullSectionsView feed
      sortby [sectionId]
      project [streetId,sectionId,endNodeId,streetData,sectionData,oneWay] {b} 
      hashjoin [NodeId,endNodeId_b,99997]
      filter [.sectionId_a < .sectionId_b])
     fullSectionsView feed
     sortby [sectionId]
     project [streetId,sectionId,startNodeId,streetData,sectionData,oneWay] {c}
     hashjoin [NodeId,startNodeId_c,99997]
     filter [.sectionId_a < .sectionId_c])
    fullSectionsView feed
    sortby [sectionId]
    project [streetId,sectionId,startNodeId,streetData,sectionData,oneWay] {d} 
    hashjoin [NodeId,startNodeId_d,99997]
    filter [.sectionId_b < .sectionId_d])
   projectextend [; 
      Road1: .streetId_a,
      Pos1: atpoint(.streetData_a,.Node,TRUE),
#         * size(.streetData_a,create_geoid("WGS1984")) / size(.streetData_a),
      Road2: .streetId_b,
      Pos2: atpoint(.streetData_b,.Node,TRUE), 
#         * size(.streetData_b,create_geoid("WGS1984")) / size(.streetData_b),
      Road3: .streetId_c,
      Road4: .streetId_d,
      JunctionType: getconnectivitycode(1,2,1,2,
         .oneWay_a = 1,.oneWay_b = 1,.oneWay_c = 1,.oneWay_d = 1),
      Sec1: .sectionId_a,
      Sec2: .sectionId_b,
      Sec3: .sectionId_c,
      Sec4: .sectionId_d,
      Node: .Node,
      SecData1: .sectionData_a,
      SecData2: .sectionData_b,
      SecData3: .sectionData_c,
      SecData4: .sectionData_d]
   filter [(.Road1 = .Road3) and (.Road2 = .Road4) and not(.Road1 = .Road2)]
   consume;

#      ^
#      |
#      |
#      |
#<-----x----->
#      ^
#      |
#      |
#      |
let oneSecInThreeSecOut2221JuncTmp =
   ((((nodesRel feed
       fullSectionsView feed
       sortby [sectionId]
       project [streetId,sectionId,startNodeId,streetData,sectionData,oneWay] {a}     
       hashjoin [NodeId, startNodeId_a,99997])
      fullSectionsView feed
      sortby [sectionId]
      project [streetId,sectionId,startNodeId,streetData,sectionData,oneWay] {b} 
      hashjoin [NodeId,startNodeId_b,99997]
      filter [.sectionId_a < .sectionId_b])
     fullSectionsView feed
     sortby [sectionId]
     project [streetId,sectionId,startNodeId,streetData,sectionData,oneWay] {c}
     hashjoin [NodeId,startNodeId_c,99997]
     filter [.sectionId_a < .sectionId_c])
    fullSectionsView feed
    sortby [sectionId]
    project [streetId,sectionId,endNodeId,streetData,sectionData,oneWay] {d} 
    hashjoin [NodeId,endNodeId_d,99997]
    filter [.sectionId_b < .sectionId_d])
   projectextend [; 
      Road1: .streetId_a,
      Pos1: atpoint(.streetData_a,.Node,TRUE),
#         * size(.streetData_a,create_geoid("WGS1984")) / size(.streetData_a),
      Road2: .streetId_b,
      Pos2: atpoint(.streetData_b,.Node,TRUE), 
#         * size(.streetData_b,create_geoid("WGS1984")) / size(.streetData_b),
      Road3: .streetId_c,
      Road4: .streetId_d,
      JunctionType: getconnectivitycode(2,1,1,1,.oneWay_a = 1,.oneWay_b = 1,.oneWay_c = 1,.oneWay_d = 1),
      Sec1: .sectionId_a,
      Sec2: .sectionId_b,
      Sec3: .sectionId_c,
      Sec4: .sectionId_d,
      Node: .Node,
      SecData1: .sectionData_a,
      SecData2: .sectionData_b,
      SecData3: .sectionData_c,
      SecData4: .sectionData_d]
   filter [(.Road1 = .Road3) and (.Road2 = .Road4) and not(.Road1 = .Road2)]
   consume;

#      ^
#      |
#      |
#      |
#<-----x<-----
#      |
#      |
#      |
#      v
let oneSecInThreeSecOut2212JuncTmp =
   ((((nodesRel feed
       fullSectionsView feed
       sortby [sectionId]
       project [streetId,sectionId,startNodeId,streetData,sectionData,oneWay] {a}     
       hashjoin [NodeId, startNodeId_a,99997])
      fullSectionsView feed
      sortby [sectionId]
      project [streetId,sectionId,startNodeId,streetData,sectionData,oneWay] {b} 
      hashjoin [NodeId,startNodeId_b,99997]
      filter [.sectionId_a < .sectionId_b])
     fullSectionsView feed
     sortby [sectionId]
     project [streetId,sectionId,endNodeId,streetData,sectionData,oneWay] {c}
     hashjoin [NodeId,endNodeId_c,99997]
     filter [.sectionId_a < .sectionId_c])
    fullSectionsView feed
    sortby [sectionId]
    project [streetId,sectionId,startNodeId,streetData,sectionData,oneWay] {d} 
    hashjoin [NodeId,startNodeId_d,99997]
    filter [.sectionId_b < .sectionId_d])
   projectextend [; 
      Road1: .streetId_a,
      Pos1: atpoint(.streetData_a,.Node,TRUE),
#         * size(.streetData_a,create_geoid("WGS1984")) / size(.streetData_a),
      Road2: .streetId_b,
      Pos2: atpoint(.streetData_b,.Node,TRUE), 
#         * size(.streetData_b,create_geoid("WGS1984")) / size(.streetData_b),
      Road3: .streetId_c,
      Road4: .streetId_d,
      JunctionType: getconnectivitycode(2,1,2,2,.oneWay_a = 1,.oneWay_b = 1,.oneWay_c = 1,.oneWay_d = 1),
      Sec1: .sectionId_a,
      Sec2: .sectionId_b,
      Sec3: .sectionId_c,
      Sec4: .sectionId_d,
      Node: .Node,
      SecData1: .sectionData_a,
      SecData2: .sectionData_b,
      SecData3: .sectionData_c,
      SecData4: .sectionData_d]
   filter [(.Road1 = .Road3) and (.Road2 = .Road4) and not(.Road1 = .Road2)]
   consume;

#      |
#      |
#      |
#      v
#<-----x----->
#      |
#      |
#      |
#      v
let oneSecInThreeSecOut2122JuncTmp =
   ((((nodesRel feed
       fullSectionsView feed
       sortby [sectionId]
       project [streetId,sectionId,startNodeId,streetData,sectionData,oneWay] {a}     
       hashjoin [NodeId, startNodeId_a,99997])
      fullSectionsView feed
      sortby [sectionId]
      project [streetId,sectionId,endNodeId,streetData,sectionData,oneWay] {b} 
      hashjoin [NodeId,endNodeId_b,99997]
      filter [.sectionId_a < .sectionId_b])
     fullSectionsView feed
     sortby [sectionId]
     project [streetId,sectionId,startNodeId,streetData,sectionData,oneWay] {c}
     hashjoin [NodeId,startNodeId_c,99997]
     filter [.sectionId_a < .sectionId_c])
    fullSectionsView feed
    sortby [sectionId]
    project [streetId,sectionId,startNodeId,streetData,sectionData,oneWay] {d} 
    hashjoin [NodeId,startNodeId_d,99997]
    filter [.sectionId_b < .sectionId_d])
   projectextend [; 
      Road1: .streetId_a,
      Pos1: atpoint(.streetData_a,.Node,TRUE),
#         * size(.streetData_a,create_geoid("WGS1984")) / size(.streetData_a),
      Road2: .streetId_b,
      Pos2: atpoint(.streetData_b,.Node,TRUE), 
#         * size(.streetData_b,create_geoid("WGS1984")) / size(.streetData_b),
      Road3: .streetId_c,
      Road4: .streetId_d,
      JunctionType: getconnectivitycode(2,2,1,2,.oneWay_a = 1,.oneWay_b = 1,.oneWay_c = 1,.oneWay_d = 1),
      Sec1: .sectionId_a,
      Sec2: .sectionId_b,
      Sec3: .sectionId_c,
      Sec4: .sectionId_d,
      Node: .Node,
      SecData1: .sectionData_a,
      SecData2: .sectionData_b,
      SecData3: .sectionData_c,
      SecData4: .sectionData_d]
   filter [(.Road1 = .Road3) and (.Road2 = .Road4) and not(.Road1 = .Road2)]
   consume;

#      ^
#      |
#      |
#      |
#----->x----->
#      |
#      |
#      |
#      v
let oneSecInThreeSecOut1222JuncTmp =
   ((((nodesRel feed
       fullSectionsView feed
       sortby [sectionId]
       project [streetId,sectionId,endNodeId,streetData,sectionData,oneWay] {a}     
       hashjoin [NodeId, endNodeId_a,99997])
      fullSectionsView feed
      sortby [sectionId]
      project [streetId,sectionId,startNodeId,streetData,sectionData,oneWay] {b} 
      hashjoin [NodeId,startNodeId_b,99997]
      filter [.sectionId_a < .sectionId_b])
     fullSectionsView feed
     sortby [sectionId]
     project [streetId,sectionId,startNodeId,streetData,sectionData,oneWay] {c}
     hashjoin [NodeId,startNodeId_c,99997]
     filter [.sectionId_a < .sectionId_c])
    fullSectionsView feed
    sortby [sectionId]
    project [streetId,sectionId,startNodeId,streetData,sectionData,oneWay] {d} 
    hashjoin [NodeId,startNodeId_d,99997]
    filter [.sectionId_b < .sectionId_d])
   projectextend [; 
      Road1: .streetId_a,
      Pos1: atpoint(.streetData_a,.Node,TRUE),
#         * size(.streetData_a,create_geoid("WGS1984")) / size(.streetData_a),
      Road2: .streetId_b,
      Pos2: atpoint(.streetData_b,.Node,TRUE), 
#         * size(.streetData_b,create_geoid("WGS1984")) / size(.streetData_b),
      Road3: .streetId_c,
      Road4: .streetId_d,
      JunctionType: getconnectivitycode(1,1,1,2,.oneWay_a = 1,.oneWay_b = 1,.oneWay_c = 1,.oneWay_d = 1),
      Sec1: .sectionId_a,
      Sec2: .sectionId_b,
      Sec3: .sectionId_c,
      Sec4: .sectionId_d,
      Node: .Node,
      SecData1: .sectionData_a,
      SecData2: .sectionData_b,
      SecData3: .sectionData_c,
      SecData4: .sectionData_d]
   filter [(.Road1 = .Road3) and (.Road2 = .Road4) and not(.Road1 = .Road2)]
   consume;

#      ^
#      |
#      |
#      |
#<-----x----->
#      |
#      |
#      |
#      v
let zeroSecInFourSecOut2222JuncTmp =
   ((((nodesRel feed
       fullSectionsView feed
       sortby [sectionId]
       project [streetId,sectionId,startNodeId,streetData,sectionData,oneWay] {a}     
       hashjoin [NodeId, startNodeId_a,99997])
      fullSectionsView feed
      sortby [sectionId]
      project [streetId,sectionId,startNodeId,streetData,sectionData,oneWay] {b} 
      hashjoin [NodeId,startNodeId_b,99997]
      filter [.sectionId_a < .sectionId_b])
     fullSectionsView feed
     sortby [sectionId]
     project [streetId,sectionId,startNodeId,streetData,sectionData,oneWay] {c}
     hashjoin [NodeId,startNodeId_c,99997]
     filter [.sectionId_a < .sectionId_c])
    fullSectionsView feed
    sortby [sectionId]
    project [streetId,sectionId,startNodeId,streetData,sectionData,oneWay] {d} 
    hashjoin [NodeId,startNodeId_d,99997]
    filter [.sectionId_b < .sectionId_d])
   projectextend [; 
      Road1: .streetId_a,
      Pos1: atpoint(.streetData_a,.Node,TRUE),
#         * size(.streetData_a,create_geoid("WGS1984")) / size(.streetData_a),
      Road2: .streetId_b,
      Pos2: atpoint(.streetData_b,.Node,TRUE), 
#         * size(.streetData_b,create_geoid("WGS1984")) / size(.streetData_b),
      Road3: .streetId_c,
      Road4: .streetId_d,
      JunctionType: getconnectivitycode(2,1,1,2,.oneWay_a = 1,.oneWay_b = 1,.oneWay_c = 1,.oneWay_d = 1),
      Sec1: .sectionId_a,
      Sec2: .sectionId_b,
      Sec3: .sectionId_c,
      Sec4: .sectionId_d,
      Node: .Node,
      SecData1: .sectionData_a,
      SecData2: .sectionData_b,
      SecData3: .sectionData_c,
      SecData4: .sectionData_d]
   filter [(.Road1 = .Road3) and (.Road2 = .Road4) and not(.Road1 = .Road2)]
   consume;

# Creating the union
let fourSecJuncBtwTwoSts =
   ((((((((((((((fourSecInZeroSecOut1111JuncTmp feed
                 threeSecInOneSecOut2111JuncTmp feed
                 concat)
                threeSecInOneSecOut1211JuncTmp feed
                concat)
               threeSecInOneSecOut1121JuncTmp feed
               concat)
              threeSecInOneSecOut1112JuncTmp feed
              concat)
             twoSecInTwoSecOut2211JuncTmp feed
             concat)
            twoSecInTwoSecOut2121JuncTmp feed
            concat)
           twoSecInTwoSecOut2112JuncTmp feed
           concat)
          twoSecInTwoSecOut1221JuncTmp feed
          concat)
         twoSecInTwoSecOut1212JuncTmp feed
         concat)
        twoSecInTwoSecOut1122JuncTmp feed
        concat)
       oneSecInThreeSecOut2221JuncTmp feed
       concat)
      oneSecInThreeSecOut2212JuncTmp feed
      concat)
     oneSecInThreeSecOut2122JuncTmp feed
     concat)
    oneSecInThreeSecOut1222JuncTmp feed
    concat)
   zeroSecInFourSecOut2222JuncTmp feed
   concat
   consume; 

