################################################################################
### Creating networks from imported OSM data (9 / 11)
################################################################################
### Description:
### - This script creates a relation containing junctions between three sections
### belonging to two streets.
### (the number 1 in the relation name stands for incoming, the number 2 means
### outgoing)
### Please, see tu_shp_import.sh for further details. 
###
### Preconditions:
### - activated necessary algebras
### - existing open database with successfully imported osm data
### - fullSectionsView-relation
###
### Postconditions:
### - cityJunctions-relation
### threeSecJuncBtwTwoSts: rel{Road1: int, Pos1: double, Road2: int, Pos2: double,
###                            JunctionType: int}
###
### Author:
### - Thomas Uchdorf, t.uchdorf@arcor.de
################################################################################

#      |
#      |
#      |
#      v
#----->x<-----
#      x
#      x
#      x
#      x
let threeSecInZeroOut111AJuncTmp =
   (((nodesRel feed
      fullSectionsView feed
      sortby [sectionId]
      project [streetId,sectionId,endNodeId,streetData,sectionData,oneWay] {a}     
      hashjoin [NodeId, endNodeId_a,99997])
     fullSectionsView feed
     sortby [sectionId]
     filter [.streetEndNodeId = .endNodeId]
     project [streetId,sectionId,endNodeId,streetData,sectionData,oneWay] {b} 
     hashjoin [NodeId,endNodeId_b,99997]
     filter [.sectionId_a < .sectionId_b])
    fullSectionsView feed
    sortby [sectionId]
    project [streetId,sectionId,endNodeId,streetData,sectionData,oneWay] {c}
    hashjoin [NodeId,endNodeId_c,99997]
    filter [.sectionId_a < .sectionId_c])
   projectextend [; 
      Road1: .streetId_a,
      Pos1: atpoint(.streetData_a,.Node,TRUE),
#         * size(.streetData_a,create_geoid("WGS1984")) / size(.streetData_a),
      Road2: .streetId_b,
      Pos2: atpoint(.streetData_b,.Node,TRUE),
#         * size(.streetData_b,create_geoid("WGS1984")) / size(.streetData_b),
      Road3: .streetId_c,
      JunctionType: getconnectivitycode(1,2,2,0,.oneWay_a = 1,.oneWay_b = 1,.oneWay_c = 1,FALSE),
      Sec1: .sectionId_a,
      Sec2: .sectionId_b,
      Sec3: .sectionId_c,
      Node: .Node,
      SecData1: .sectionData_a,
      SecData2: .sectionData_b,
      SecData3: .sectionData_c]
   filter [(.Road1 = .Road3) and not(.Road1 = .Road2)]
   consume;

#      |
#      |
#      |
#      v
#----->xxxxxxx
#      ^
#      |
#      |
#      |
let threeSecInZeroOut111BJuncTmp =
   (((nodesRel feed
      fullSectionsView feed
      sortby [sectionId]
      filter [.streetEndNodeId = .endNodeId]
      project [streetId,sectionId,endNodeId,streetData,sectionData,oneWay] {a}     
      hashjoin [NodeId, endNodeId_a,99997])
     fullSectionsView feed
     sortby [sectionId]
     project [streetId,sectionId,endNodeId,streetData,sectionData,oneWay] {b} 
     hashjoin [NodeId,endNodeId_b,99997]
     filter [.sectionId_a < .sectionId_b])
    fullSectionsView feed
    sortby [sectionId]
    project [streetId,sectionId,endNodeId,streetData,sectionData,oneWay] {c}
    hashjoin [NodeId,endNodeId_c,99997]
    filter [.sectionId_c < .sectionId_b])
   projectextend [; 
      Road1: .streetId_a,
      Pos1: atpoint(.streetData_a,.Node,TRUE),
#         * size(.streetData_a,create_geoid("WGS1984")) / size(.streetData_a),
      Road2: .streetId_b,
      Pos2: atpoint(.streetData_b,.Node,TRUE),
#         * size(.streetData_b,create_geoid("WGS1984")) / size(.streetData_b),
      Road3: .streetId_c,
      JunctionType: getconnectivitycode(1,2,0,1,.oneWay_a = 1,.oneWay_b = 1,FALSE,.oneWay_c = 1),
      Sec1: .sectionId_a,
      Sec2: .sectionId_b,
      Sec3: .sectionId_c,
      Node: .Node,
      SecData1: .sectionData_a,
      SecData2: .sectionData_b,
      SecData3: .sectionData_c]
   filter [(.Road2 = .Road3) and not(.Road1 = .Road2)]
   consume;

#      |
#      |
#      |
#      v
#----->x----->
#      x
#      x
#      x
#      x
let twoSecInOneOut112AJuncTmp =
   (((nodesRel feed
      fullSectionsView feed
      sortby [sectionId]
      project [streetId,sectionId,endNodeId,streetData,sectionData,oneWay] {a}     
      hashjoin [NodeId, endNodeId_a,99997])
     fullSectionsView feed
     sortby [sectionId]
     filter [.streetEndNodeId = .endNodeId]
     project [streetId,sectionId,endNodeId,streetData,sectionData,oneWay] {b} 
     hashjoin [NodeId,endNodeId_b,99997]
     filter [.sectionId_a < .sectionId_b])
    fullSectionsView feed
    sortby [sectionId]
    project [streetId,sectionId,startNodeId,streetData,sectionData,oneWay] {c}
    hashjoin [NodeId,startNodeId_c,99997]
    filter [.sectionId_a < .sectionId_c])
   projectextend [; 
      Road1: .streetId_a,
      Pos1: atpoint(.streetData_a,.Node,TRUE),
#         * size(.streetData_a,create_geoid("WGS1984")) / size(.streetData_a),
      Road2: .streetId_b,
      Pos2: atpoint(.streetData_b,.Node,TRUE),
#         * size(.streetData_b,create_geoid("WGS1984")) / size(.streetData_b),
      Road3: .streetId_c,
      JunctionType: getconnectivitycode(1,2,1,0,.oneWay_a = 1,.oneWay_b = 1,.oneWay_c = 1,FALSE),
      Sec1: .sectionId_a,
      Sec2: .sectionId_b,
      Sec3: .sectionId_c,
      Node: .Node,
      SecData1: .sectionData_a,
      SecData2: .sectionData_b,
      SecData3: .sectionData_c]
   filter [(.Road1 = .Road3) and not(.Road1 = .Road2)]
   consume;

#      |
#      |
#      |
#      v
#----->xxxxxxx
#      |
#      |
#      |
#      v
let twoSecInOneOut112BJuncTmp =
   (((nodesRel feed
      fullSectionsView feed
      sortby [sectionId]
      filter [.streetEndNodeId = .endNodeId]
      project [streetId,sectionId,endNodeId,streetData,sectionData,oneWay] {a}     
      hashjoin [NodeId, endNodeId_a,99997])
     fullSectionsView feed
     sortby [sectionId]
     project [streetId,sectionId,endNodeId,streetData,sectionData,oneWay] {b} 
     hashjoin [NodeId,endNodeId_b,99997]
     filter [.sectionId_a < .sectionId_b])
    fullSectionsView feed
    sortby [sectionId]
    project [streetId,sectionId,startNodeId,streetData,sectionData,oneWay] {c}
    hashjoin [NodeId,startNodeId_c,99997]
    filter [.sectionId_c < .sectionId_b])
   projectextend [; 
      Road1: .streetId_a,
      Pos1: atpoint(.streetData_a,.Node,TRUE),
#         * size(.streetData_a,create_geoid("WGS1984")) / size(.streetData_a),
      Road2: .streetId_b,
      Pos2: atpoint(.streetData_b,.Node,TRUE),
#         * size(.streetData_b,create_geoid("WGS1984")) / size(.streetData_b),
      Road3: .streetId_c,
      JunctionType: getconnectivitycode(1,2,0,2,.oneWay_a = 1,.oneWay_b = 1,FALSE,.oneWay_c = 1),
      Sec1: .sectionId_a,
      Sec2: .sectionId_b,
      Sec3: .sectionId_c,
      Node: .Node,
      SecData1: .sectionData_a,
      SecData2: .sectionData_b,
      SecData3: .sectionData_c]
   filter [(.Road2 = .Road3) and not(.Road1 = .Road2)]
   consume;

#      ^
#      |
#      |
#      |
#----->x<------
#      x
#      x
#      x
#      x
let twoSecInOneOut121AJuncTmp =
   (((nodesRel feed
      fullSectionsView feed
      sortby [sectionId]
      project [streetId,sectionId,endNodeId,streetData,sectionData,oneWay] {a}     
      hashjoin [NodeId, endNodeId_a,99997])
     fullSectionsView feed
     sortby [sectionId]
     filter [.streetStartNodeId = .startNodeId]
     project [streetId,sectionId,startNodeId,streetData,sectionData,oneWay] {b} 
     hashjoin [NodeId,startNodeId_b,99997]
     filter [.sectionId_a < .sectionId_b])
    fullSectionsView feed
    sortby [sectionId]
    project [streetId,sectionId,endNodeId,streetData,sectionData,oneWay] {c}
    hashjoin [NodeId,endNodeId_c,99997]
    filter [.sectionId_a < .sectionId_c])
   projectextend [; 
      Road1: .streetId_a,
      Pos1: atpoint(.streetData_a,.Node,TRUE),
#         * size(.streetData_a,create_geoid("WGS1984")) / size(.streetData_a),
      Road2: .streetId_b,
      Pos2: atpoint(.streetData_b,.Node,TRUE),
#         * size(.streetData_b,create_geoid("WGS1984")) / size(.streetData_b),
      Road3: .streetId_c,
      JunctionType: getconnectivitycode(1,1,2,0,.oneWay_a = 1,.oneWay_b = 1,.oneWay_c = 1,FALSE),
      Sec1: .sectionId_a,
      Sec2: .sectionId_b,
      Sec3: .sectionId_c,
      Node: .Node,
      SecData1: .sectionData_a,
      SecData2: .sectionData_b,
      SecData3: .sectionData_c]
   filter [(.Road1 = .Road3) and not(.Road1 = .Road2)]
   consume;

#      ^
#      |
#      |
#      |
#----->xxxxxxx
#      ^
#      |
#      |
#      |
let twoSecInOneOut121BJuncTmp =
   (((nodesRel feed
      fullSectionsView feed
      sortby [sectionId]
      filter [.streetEndNodeId = .endNodeId]
      project [streetId,sectionId,endNodeId,streetData,sectionData,oneWay] {a}     
      hashjoin [NodeId, endNodeId_a,99997])
     fullSectionsView feed
     sortby [sectionId]
     project [streetId,sectionId,startNodeId,streetData,sectionData,oneWay] {b} 
     hashjoin [NodeId,startNodeId_b,99997]
     filter [.sectionId_a < .sectionId_b])
    fullSectionsView feed
    sortby [sectionId]
    project [streetId,sectionId,endNodeId,streetData,sectionData,oneWay] {c}
    hashjoin [NodeId,endNodeId_c,99997]
    filter [.sectionId_c < .sectionId_b])
   projectextend [; 
      Road1: .streetId_a,
      Pos1: atpoint(.streetData_a,.Node,TRUE),
#         * size(.streetData_a,create_geoid("WGS1984")) / size(.streetData_a),
      Road2: .streetId_b,
      Pos2: atpoint(.streetData_b,.Node,TRUE),
#         * size(.streetData_b,create_geoid("WGS1984")) / size(.streetData_b),
      Road3: .streetId_c,
      JunctionType: getconnectivitycode(1,1,0,1,.oneWay_a = 1,.oneWay_b = 1,FALSE,.oneWay_c = 1),
      Sec1: .sectionId_a,
      Sec2: .sectionId_b,
      Sec3: .sectionId_c,
      Node: .Node,
      SecData1: .sectionData_a,
      SecData2: .sectionData_b,
      SecData3: .sectionData_c]
   filter [(.Road2 = .Road3) and not(.Road1 = .Road2)]
   consume;

#      |
#      |
#      |
#      v
#<-----x<------
#      x
#      x
#      x
#      x
let twoSecInOneOut211AJuncTmp =
   (((nodesRel feed
      fullSectionsView feed
      sortby [sectionId]
      project [streetId,sectionId,startNodeId,streetData,sectionData,oneWay] {a}     
      hashjoin [NodeId, startNodeId_a,99997])
     fullSectionsView feed
     sortby [sectionId]
     filter [.streetEndNodeId = .endNodeId]
     project [streetId,sectionId,endNodeId,streetData,sectionData,oneWay] {b} 
     hashjoin [NodeId,endNodeId_b,99997]
     filter [.sectionId_a < .sectionId_b])
    fullSectionsView feed
    sortby [sectionId]
    project [streetId,sectionId,endNodeId,streetData,sectionData,oneWay] {c}
    hashjoin [NodeId,endNodeId_c,99997]
    filter [.sectionId_a < .sectionId_c])
   projectextend [; 
      Road1: .streetId_a,
      Pos1: atpoint(.streetData_a,.Node,TRUE),
#         * size(.streetData_a,create_geoid("WGS1984")) / size(.streetData_a),
      Road2: .streetId_b,
      Pos2: atpoint(.streetData_b,.Node,TRUE),
#         * size(.streetData_b,create_geoid("WGS1984")) / size(.streetData_b),
      Road3: .streetId_c,
      JunctionType: getconnectivitycode(2,2,2,0,.oneWay_a = 1,.oneWay_b = 1,.oneWay_c = 1,FALSE),
      Sec1: .sectionId_a,
      Sec2: .sectionId_b,
      Sec3: .sectionId_c,
      Node: .Node,
      SecData1: .sectionData_a,
      SecData2: .sectionData_b,
      SecData3: .sectionData_c]
   filter [(.Road1 = .Road3) and not(.Road1 = .Road2)]
   consume;

#      |
#      |
#      |
#      v
#<-----xxxxxxx
#      ^
#      |
#      |
#      |
let twoSecInOneOut211BJuncTmp =
   (((nodesRel feed
      fullSectionsView feed
      sortby [sectionId]
      filter [.streetStartNodeId = .startNodeId]
      project [streetId,sectionId,startNodeId,streetData,sectionData,oneWay] {a}     
      hashjoin [NodeId, startNodeId_a,99997])
     fullSectionsView feed
     sortby [sectionId]
     project [streetId,sectionId,endNodeId,streetData,sectionData,oneWay] {b} 
     hashjoin [NodeId,endNodeId_b,99997]
     filter [.sectionId_a < .sectionId_b])
    fullSectionsView feed
    sortby [sectionId]
    project [streetId,sectionId,endNodeId,streetData,sectionData,oneWay] {c}
    hashjoin [NodeId,endNodeId_c,99997]
    filter [.sectionId_c < .sectionId_b])
   projectextend [; 
      Road1: .streetId_a,
      Pos1: atpoint(.streetData_a,.Node,TRUE),
#         * size(.streetData_a,create_geoid("WGS1984")) / size(.streetData_a),
      Road2: .streetId_b,
      Pos2: atpoint(.streetData_b,.Node,TRUE),
#         * size(.streetData_b,create_geoid("WGS1984")) / size(.streetData_b),
      Road3: .streetId_c,
      JunctionType: getconnectivitycode(2,2,0,1,.oneWay_a = 1,.oneWay_b = 1,FALSE,.oneWay_c = 1),
      Sec1: .sectionId_a,
      Sec2: .sectionId_b,
      Sec3: .sectionId_c,
      Node: .Node,
      SecData1: .sectionData_a,
      SecData2: .sectionData_b,
      SecData3: .sectionData_c]
   filter [(.Road2 = .Road3) and not(.Road1 = .Road2)]
   consume;

#      ^
#      |
#      |
#      |
#----->x----->
#      x
#      x
#      x
#      x
let oneSecInTwoOut122AJuncTmp =
   (((nodesRel feed
      fullSectionsView feed
      sortby [sectionId]
      project [streetId,sectionId,endNodeId,streetData,sectionData,oneWay] {a}     
      hashjoin [NodeId, endNodeId_a,99997])
     fullSectionsView feed
     sortby [sectionId]
     filter [.streetStartNodeId = .startNodeId]
     project [streetId,sectionId,startNodeId,streetData,sectionData,oneWay] {b} 
     hashjoin [NodeId,startNodeId_b,99997]
     filter [.sectionId_a < .sectionId_b])
    fullSectionsView feed
    sortby [sectionId]
    project [streetId,sectionId,startNodeId,streetData,sectionData,oneWay] {c}
    hashjoin [NodeId,startNodeId_c,99997]
    filter [.sectionId_a < .sectionId_c])
   projectextend [; 
      Road1: .streetId_a,
      Pos1: atpoint(.streetData_a,.Node,TRUE),
#         * size(.streetData_a,create_geoid("WGS1984")) / size(.streetData_a),
      Road2: .streetId_b,
      Pos2: atpoint(.streetData_b,.Node,TRUE),
#         * size(.streetData_b,create_geoid("WGS1984")) / size(.streetData_b),
      Road3: .streetId_c,
      JunctionType: getconnectivitycode(1,1,1,0,.oneWay_a = 1,.oneWay_b = 1,.oneWay_c = 1,FALSE),
      Sec1: .sectionId_a,
      Sec2: .sectionId_b,
      Sec3: .sectionId_c,
      Node: .Node,
      SecData1: .sectionData_a,
      SecData2: .sectionData_b,
      SecData3: .sectionData_c]
   filter [(.Road1 = .Road3) and not(.Road1 = .Road2)]
   consume;

#      ^
#      |
#      |
#      |
#----->xxxxxxx
#      |
#      |
#      |
#      v
let oneSecInTwoOut122BJuncTmp =
   (((nodesRel feed
      fullSectionsView feed
      sortby [sectionId]
      filter [.streetEndNodeId = .endNodeId]
      project [streetId,sectionId,endNodeId,streetData,sectionData,oneWay] {a}     
      hashjoin [NodeId, endNodeId_a,99997])
     fullSectionsView feed
     sortby [sectionId]
     project [streetId,sectionId,startNodeId,streetData,sectionData,oneWay] {b} 
     hashjoin [NodeId,startNodeId_b,99997]
     filter [.sectionId_a < .sectionId_b])
    fullSectionsView feed
    sortby [sectionId]
    project [streetId,sectionId,startNodeId,streetData,sectionData,oneWay] {c}
    hashjoin [NodeId,startNodeId_c,99997]
    filter [.sectionId_c < .sectionId_b])
   projectextend [; 
      Road1: .streetId_a,
      Pos1: atpoint(.streetData_a,.Node,TRUE),
#         * size(.streetData_a,create_geoid("WGS1984")) / size(.streetData_a),
      Road2: .streetId_b,
      Pos2: atpoint(.streetData_b,.Node,TRUE),
#         * size(.streetData_b,create_geoid("WGS1984")) / size(.streetData_b),
      Road3: .streetId_c,
      JunctionType: getconnectivitycode(1,1,0,2,.oneWay_a = 1,.oneWay_b = 1,FALSE,.oneWay_c = 1),
      Sec1: .sectionId_a,
      Sec2: .sectionId_b,
      Sec3: .sectionId_c,
      Node: .Node,
      SecData1: .sectionData_a,
      SecData2: .sectionData_b,
      SecData3: .sectionData_c]
   filter [(.Road2 = .Road3) and not(.Road1 = .Road2)]
   consume;

#      |
#      |
#      |
#      v
#<-----x----->
#      x
#      x
#      x
#      x
let oneSecInTwoOut212AJuncTmp =
   (((nodesRel feed
      fullSectionsView feed
      sortby [sectionId]
      project [streetId,sectionId,startNodeId,streetData,sectionData,oneWay] {a}     
      hashjoin [NodeId, startNodeId_a,99997])
     fullSectionsView feed
     sortby [sectionId]
     filter [.streetEndNodeId = .endNodeId]
     project [streetId,sectionId,endNodeId,streetData,sectionData,oneWay] {b} 
     hashjoin [NodeId,endNodeId_b,99997]
     filter [.sectionId_a < .sectionId_b])
    fullSectionsView feed
    sortby [sectionId]
    project [streetId,sectionId,startNodeId,streetData,sectionData,oneWay] {c}
    hashjoin [NodeId,startNodeId_c,99997]
    filter [.sectionId_a < .sectionId_c])
   projectextend [; 
      Road1: .streetId_a,
      Pos1: atpoint(.streetData_a,.Node,TRUE),
#         * size(.streetData_a,create_geoid("WGS1984")) / size(.streetData_a),
      Road2: .streetId_b,
      Pos2: atpoint(.streetData_b,.Node,TRUE),
#         * size(.streetData_b,create_geoid("WGS1984")) / size(.streetData_b),
      Road3: .streetId_c,
      JunctionType: getconnectivitycode(2,2,1,0,.oneWay_a = 1,.oneWay_b = 1,.oneWay_c = 1,FALSE),
      Sec1: .sectionId_a,
      Sec2: .sectionId_b,
      Sec3: .sectionId_c,
      Node: .Node,
      SecData1: .sectionData_a,
      SecData2: .sectionData_b,
      SecData3: .sectionData_c]
   filter [(.Road1 = .Road3) and not(.Road1 = .Road2)]
   consume;

#      |
#      |
#      |
#      v
#<-----xxxxxxx
#      |
#      |
#      |
#      v
let oneSecInTwoOut212BJuncTmp =
   (((nodesRel feed
      fullSectionsView feed
      sortby [sectionId]
      filter [.streetStartNodeId = .startNodeId]
      project [streetId,sectionId,startNodeId,streetData,sectionData,oneWay] {a}     
      hashjoin [NodeId, startNodeId_a,99997])
     fullSectionsView feed
     sortby [sectionId]
     project [streetId,sectionId,endNodeId,streetData,sectionData,oneWay] {b} 
     hashjoin [NodeId,endNodeId_b,99997]
     filter [.sectionId_a < .sectionId_b])
    fullSectionsView feed
    sortby [sectionId]
    project [streetId,sectionId,startNodeId,streetData,sectionData,oneWay] {c}
    hashjoin [NodeId,startNodeId_c,99997]
    filter [.sectionId_c < .sectionId_b])
   projectextend [; 
      Road1: .streetId_a,
      Pos1: atpoint(.streetData_a,.Node,TRUE),
#         * size(.streetData_a,create_geoid("WGS1984")) / size(.streetData_a),
      Road2: .streetId_b,
      Pos2: atpoint(.streetData_b,.Node,TRUE),
#         * size(.streetData_b,create_geoid("WGS1984")) / size(.streetData_b),
      Road3: .streetId_c,
      JunctionType: getconnectivitycode(2,2,0,2,.oneWay_a = 1,.oneWay_b = 1,FALSE,.oneWay_c = 1),
      Sec1: .sectionId_a,
      Sec2: .sectionId_b,
      Sec3: .sectionId_c,
      Node: .Node,
      SecData1: .sectionData_a,
      SecData2: .sectionData_b,
      SecData3: .sectionData_c]
   filter [(.Road2 = .Road3) and not(.Road1 = .Road2)]
   consume;

#      ^
#      |
#      |
#      |
#<-----x<-----
#      x
#      x
#      x
#      x
let oneSecInTwoOut221AJuncTmp =
   (((nodesRel feed
      fullSectionsView feed
      sortby [sectionId]
      project [streetId,sectionId,startNodeId,streetData,sectionData,oneWay] {a}     
      hashjoin [NodeId, startNodeId_a,99997])
     fullSectionsView feed
     sortby [sectionId]
     filter [.streetStartNodeId = .startNodeId]
     project [streetId,sectionId,startNodeId,streetData,sectionData,oneWay] {b} 
     hashjoin [NodeId,startNodeId_b,99997]
     filter [.sectionId_a < .sectionId_b])
    fullSectionsView feed
    sortby [sectionId]
    project [streetId,sectionId,endNodeId,streetData,sectionData,oneWay] {c}
    hashjoin [NodeId,endNodeId_c,99997]
    filter [.sectionId_a < .sectionId_c])
   projectextend [; 
      Road1: .streetId_a,
      Pos1: atpoint(.streetData_a,.Node,TRUE),
#         * size(.streetData_a,create_geoid("WGS1984")) / size(.streetData_a),
      Road2: .streetId_b,
      Pos2: atpoint(.streetData_b,.Node,TRUE),
#         * size(.streetData_b,create_geoid("WGS1984")) / size(.streetData_b),
      Road3: .streetId_c,
      JunctionType: getconnectivitycode(2,1,2,0,.oneWay_a = 1,.oneWay_b = 1,.oneWay_c = 1,FALSE),
      Sec1: .sectionId_a,
      Sec2: .sectionId_b,
      Sec3: .sectionId_c,
      Node: .Node,
      SecData1: .sectionData_a,
      SecData2: .sectionData_b,
      SecData3: .sectionData_c]
   filter [(.Road1 = .Road3) and not(.Road1 = .Road2)]
   consume;

#      ^
#      |
#      |
#      |
#<-----xxxxxxx
#      ^
#      |
#      |
#      |
let oneSecInTwoOut221BJuncTmp =
   (((nodesRel feed
      fullSectionsView feed
      sortby [sectionId]
      filter [.streetStartNodeId = .startNodeId]
      project [streetId,sectionId,startNodeId,streetData,sectionData,oneWay] {a}     
      hashjoin [NodeId, startNodeId_a,99997])
     fullSectionsView feed
     sortby [sectionId]
     project [streetId,sectionId,startNodeId,streetData,sectionData,oneWay] {b} 
     hashjoin [NodeId,startNodeId_b,99997]
     filter [.sectionId_a < .sectionId_b])
    fullSectionsView feed
    sortby [sectionId]
    project [streetId,sectionId,endNodeId,streetData,sectionData,oneWay] {c}
    hashjoin [NodeId,endNodeId_c,99997]
    filter [.sectionId_c < .sectionId_b])
   projectextend [; 
      Road1: .streetId_a,
      Pos1: atpoint(.streetData_a,.Node,TRUE),
#         * size(.streetData_a,create_geoid("WGS1984")) / size(.streetData_a),
      Road2: .streetId_b,
      Pos2: atpoint(.streetData_b,.Node,TRUE),
#         * size(.streetData_b,create_geoid("WGS1984")) / size(.streetData_b),
      Road3: .streetId_c,
      JunctionType: getconnectivitycode(2,1,0,1,.oneWay_a = 1,.oneWay_b = 1,FALSE,.oneWay_c = 1),
      Sec1: .sectionId_a,
      Sec2: .sectionId_b,
      Sec3: .sectionId_c,
      Node: .Node,
      SecData1: .sectionData_a,
      SecData2: .sectionData_b,
      SecData3: .sectionData_c]
   filter [(.Road2 = .Road3) and not(.Road1 = .Road2)]
   consume;

#      ^
#      |
#      |
#      |
#<-----x----->
#      x
#      x
#      x
#      x
let zeroSecInThreeOut222AJuncTmp =
   (((nodesRel feed
      fullSectionsView feed
      sortby [sectionId]
      project [streetId,sectionId,startNodeId,streetData,sectionData,oneWay] {a}     
      hashjoin [NodeId, startNodeId_a,99997])
     fullSectionsView feed
     sortby [sectionId]
     filter [.streetStartNodeId = .startNodeId]
     project [streetId,sectionId,startNodeId,streetData,sectionData,oneWay] {b} 
     hashjoin [NodeId,startNodeId_b,99997]
     filter [.sectionId_a < .sectionId_b])
    fullSectionsView feed
    sortby [sectionId]
    project [streetId,sectionId,startNodeId,streetData,sectionData,oneWay] {c}
    hashjoin [NodeId,startNodeId_c,99997]
    filter [.sectionId_a < .sectionId_c])
   projectextend [; 
      Road1: .streetId_a,
      Pos1: atpoint(.streetData_a,.Node,TRUE), 
#         * size(.streetData_a,create_geoid("WGS1984")) / size(.streetData_a),
      Road2: .streetId_b,
      Pos2: atpoint(.streetData_b,.Node,TRUE), 
#         * size(.streetData_b,create_geoid("WGS1984")) / size(.streetData_b),
      Road3: .streetId_c,
      JunctionType: getconnectivitycode(2,1,1,0,.oneWay_a = 1,.oneWay_b = 1,.oneWay_c = 1,FALSE),
      Sec1: .sectionId_a,
      Sec2: .sectionId_b,
      Sec3: .sectionId_c,
      Node: .Node,
      SecData1: .sectionData_a,
      SecData2: .sectionData_b,
      SecData3: .sectionData_c]
   filter [(.Road1 = .Road3) and not(.Road1 = .Road2)]
   consume;

#      ^
#      |
#      |
#      |
#<-----xxxxxxx
#      |
#      |
#      |
#      v
let zeroSecInThreeOut222BJuncTmp =
   (((nodesRel feed
      fullSectionsView feed
      sortby [sectionId]
      filter [.streetStartNodeId = .startNodeId]
      project [streetId,sectionId,startNodeId,streetData,sectionData,oneWay] {a}     
      hashjoin [NodeId, startNodeId_a,99997])
     fullSectionsView feed
     sortby [sectionId]
     project [streetId,sectionId,startNodeId,streetData,sectionData,oneWay] {b} 
     hashjoin [NodeId,startNodeId_b,99997]
     filter [.sectionId_a < .sectionId_b])
    fullSectionsView feed
    sortby [sectionId]
    project [streetId,sectionId,startNodeId,streetData,sectionData,oneWay] {c}
    hashjoin [NodeId,startNodeId_c,99997]
    filter [.sectionId_c < .sectionId_b])
   projectextend [; 
      Road1: .streetId_a,
      Pos1: atpoint(.streetData_a,.Node,TRUE), 
#         * size(.streetData_a,create_geoid("WGS1984")) / size(.streetData_a),
      Road2: .streetId_b,
      Pos2: atpoint(.streetData_b,.Node,TRUE), 
#         * size(.streetData_b,create_geoid("WGS1984")) / size(.streetData_b),
      Road3: .streetId_c,
      JunctionType: getconnectivitycode(2,1,0,2,.oneWay_a = 1,.oneWay_b = 1,FALSE,.oneWay_c = 1),
      Sec1: .sectionId_a,
      Sec2: .sectionId_b,
      Sec3: .sectionId_c,
      Node: .Node,
      SecData1: .sectionData_a,
      SecData2: .sectionData_b,
      SecData3: .sectionData_c]
   filter [(.Road2 = .Road3) and not(.Road1 = .Road2)]
   consume;

# Creating the union
let threeSecJuncBtwTwoSts =
   ((((((((((((((threeSecInZeroOut111AJuncTmp feed 
                 twoSecInOneOut112AJuncTmp feed
                 concat)
                twoSecInOneOut121AJuncTmp feed
                concat)
               twoSecInOneOut211AJuncTmp feed
               concat)
              oneSecInTwoOut122AJuncTmp feed
              concat)
             oneSecInTwoOut212AJuncTmp feed
             concat)
            oneSecInTwoOut221AJuncTmp feed
            concat)
           zeroSecInThreeOut222AJuncTmp feed
           concat)
           threeSecInZeroOut111BJuncTmp feed
           concat)
         twoSecInOneOut112BJuncTmp feed
         concat)
        twoSecInOneOut121BJuncTmp feed
        concat)
       twoSecInOneOut211BJuncTmp feed
       concat)
      oneSecInTwoOut122BJuncTmp feed
      concat)
     oneSecInTwoOut212BJuncTmp feed
     concat)
    oneSecInTwoOut221BJuncTmp feed
    concat)
   zeroSecInThreeOut222BJuncTmp feed
   concat
   consume;

