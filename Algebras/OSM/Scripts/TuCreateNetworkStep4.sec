################################################################################
### Creating networks from imported OSM data (11 / 11)
################################################################################
### Description:
### - This script creates networks from imported OSM data.
### Please, see tu_shp_import.sh for further details. 
###
### Preconditions:
### - activated necessary algebras
### - existing open database with successfully imported osm data
### - extStreetsRel-relation
### extStreetsRel: rel{geoData: sline, streetId: int, name: string, ref: string,
###                    roadClass: string, oneWay: int, bridge: int,
###                    maxSpeed: int, tunnel: bool, layer: int, groupId: int}
### - nodesRel-relation
### nodesRel: rel{Node: point, NodeId: int}
### - extSectionsRel-relation
### extSectionsRel: rel{SectionId: int, Section: sline, StartNodeId: int,
###                     EndNodeId: int, StreetId: int, GroupId: int,
###                     SectionDist: real}
###
### Postconditions:
### - cityRoads-relation
### cityRoads: rel{Name: string, Road: int, Length: double, Geometry: line,
###                Dual: bool, StartsSmaller: bool, RoadLevel: int}
### - cityJunctions-relation
### cityJunctions: rel{Road1: int, Pos1: double, Road2: int, Pos2: double,
###                    JunctionType: int}
### - cityNetwork-network
###
### Author:
### - Thomas Uchdorf, t.uchdorf@arcor.de
################################################################################

# Removing duplicates
#query (twoSecJuncBtwTwoSts feed
#   threeSecJuncBtwTwoSts feed {a}
#   hashjoin [Node,Node_a,99997]
#   filter [(.Road1 = .Road1_a) and (.Road2 = .Road2_a)]
#   project [Road1,Pos1,Road2,Pos2,JunctionType,
#      Sec1,Sec2,Node,SecData1,SecData2])
#   twoSecJuncBtwTwoSts deletedirect 
#   consume;
#...

# Calculating and inserting road measures into a new relation containing
# junction data
# see also PaperMon-paper page 11
let cityJunctionsTmp =
   ((twoSecJuncBtwTwoSts feed
     extend [numSecs: 2]
     project [Road1,Pos1,Road2,Pos2,JunctionType,numSecs]
     threeSecJuncBtwTwoSts feed
     extend [numSecs: 3]
     project [Road1,Pos1,Road2,Pos2,JunctionType,numSecs]
     concat)
    fourSecJuncBtwTwoSts feed
    extend [numSecs: 4]
    project [Road1,Pos1,Road2,Pos2,JunctionType,numSecs]
    concat)
   consume;
# should not make a difference since the combined junctions are composed in a 
# disjunct way 
let cityJunctions =
   cityJunctionsTmp feed
   sortby[Road1,Pos1,Road2,Pos2]
   groupby [Road1,Pos1,Road2,Pos2; 
      NewJunctionType: group feed 
         aggregateB [JunctionType; 
                     fun(a:int,b:int) binor(a,b); 
                     0]]
   consume;
#let cityJunctions =
#   (fullSectionsView feed
#    project [streetId,sectionId,startNodeId,streetData] {a}
#    nodesRel feed
#    hashjoin [startNodeId_a,NodeId,99997])
#   fullSectionsView feed
#   project [streetId,sectionId,startNodeId,streetData] {b} 
#   hashjoin [startNodeId_a,startNodeId_b,99997]
#   filter [.sectionId_a < .sectionId_b]
#   projectextend [; 
#      Road1: .streetId_a,
#      Pos1: size(.streetData_a,create_geoid("WGS1984")) * 
#         atpoint(.streetData_a,.Node,TRUE) / 
#         size(.streetData_a),
#      Road2: .streetId_b,
#      Pos2: size(.streetData_b,create_geoid("WGS1984")) * 
#         atpoint(.streetData_b,.Node,TRUE) / 
#         size(.streetData_b),
#      JunctionType: 16]
#   consume;


# Creating the network
let cityNetwork = thenetwork(
   1,
   1.0,
   (cityRoads feed
   project [Road, Length, Geometry, Dual, StartsSmaller]
   consume),
   cityJunctions);

close database;
