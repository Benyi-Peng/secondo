\chapter{Anleitung zur Implementierung eigener Matchings oder Ratings}\label{eigeneMatch}

\section{Die Implementierung eines Matches}

Ein eigenes Match muss von der abstrakten Klasse Match abgeleitet werden. Diese Klasse wird in \vref{MatchKlasse} näher beschrieben. Beim Erstellen des eigenen Matches müssen folgende Methoden implementiert werden:
\begin{itemize}
\item matchFaces
\item matchCHTNs
\item getBestMatch
\end{itemize}
Im Folgenden wird der Quellcode der Klasse \textit{CentroidMatch} betrachtet, um die Herangehensweise bei der Implementierung eigener Matches praktisch näher zu erläutern.

Zunächst wird der Konstruktor betrachtet:
\begin{lstlisting}[language=c++]
CentroidMatch :: CentroidMatch(RegionForInterpolation *source, RegionForInterpolation *target, double thresholdRel, bool useFinalize=true):
	Match(source, target, "CentroidMatch "+Utils :: toString( (int) (thresholdRel * 100)) + " %" , "this implements the position of centroids Match, known from the paper of Erlend Tossebro (5.2 1)")
{
    threshold = greatestDist * thresholdRel;                                
    addMatch(source, target);
    addMatch(target, source);
    matchFaces(source->getFaces(), target->getFaces());
    this->generateRatings();
    if(useFinalize)	    
    	finalize();
}
\end{lstlisting}
In dem Konstruktor wird zunächst der Superkonstruktor der Klasse Match aufgerufen. Dieser setzt \textit{source} und \textit{target}, benennt das neue Objekt und bereitet die Bewertung vor, indem der gemeinsame Durchmesser von \textit{source} und \textit{target} berechnet wird. Dann wird ein Match f"ur die Regionen \textit{source} und \textit{target} hinzugef"ugt und die Funktion \textit{matchFaces} mit allen Faces von source und target aufgerufen. Am Ende des Konstruktors muss die Funktion \textit{generateRatings()} aufgerufen werden. Diese berechnet die Bewertungen des Matches. Falls das Match nicht aus einem OptimalMatch aufgerufen wird, muss schlussendlich die Funktion \textit{finalize()} aufgerufen werden.

Die eben aufgerufene Funktion \textit{matchFaces()} kümmert sich darum, alle Matches von einzelnen Faces zueinander zu finden. Diese Funktion wird nun näher betrachtet. Auf die Betrachtung der Funktion \textit{matchCHTNs()} wird verzichtet, diese funktioniert analog.
\begin{lstlisting}[language=c++]
void CentroidMatch :: matchFaces(vector<Face*> *faces1, vector<Face*> *faces2)
{
	vector<Face*> unmatched;
	for(unsigned int i = 0; i < faces1->size(); i++)
	{
		for(unsigned int j = 0; j<faces2->size(); j++)
		{            
			double distance = getDistance(faces1->at(i)->getCycle(), faces2->at(j)->getCycle());
			if(distance < threshold)
			{
				addMatch(faces1->at(i), faces2->at(j));
				addMatch(faces2->at(j), faces1->at(i));
				addMatch(faces1->at(i)->getCycle(), faces2->at(j)->getCycle());
				addMatch(faces2->at(j)->getCycle(), faces1->at(i)->getCycle());
			}
		}
		unmatched.push_back(faces1->at(i));
	}
	for(unsigned int i = 0; i<faces2->size(); i++)
	{
		unmatched.push_back(faces2->at(i));
	}    
	while(!unmatched.empty())
	{
		Face *next = unmatched.back();
		unmatched.pop_back();
		vector<RegionTreeNode*> matches = getMatches(next);
		if(!matches.empty())
		{
			if(matches.size() > 1)
			{
				int dimMatch = 0;
				for(unsigned int i = 0; i < matches.size(); i++)
				{
					for(unsigned int j = 0; j<unmatched.size(); j++)
					{
						if(unmatched[j]->equals(matches[i]))
						{
							unmatched.erase(unmatched.begin() + j);
							break;
						}
					}                                       
					dimMatch += ( (Face*) matches[i])->getCycle()->getChildren()->size();
				}      
				matchCHTNs(next->getHolesAndConcavities(), getTargetChildren(next));	                
			}
			else
			{
				if(getMatches(matches[0]).size() > 1)
				{
					for(unsigned int i = 0; i < getMatches(matches[0]).size(); i++)
					{
						for(unsigned int j = 0; j < unmatched.size(); j++)
						{
							if(unmatched[j]->equals(getMatches(matches[0])[i]))
							{
								unmatched.erase(unmatched.begin() + j);
								break;
							}
						}                        
					}      
					matchCHTNs(( (Face*) matches[0])->getHolesAndConcavities(), getTargetChildren(matches[0]));
				}
				else
				{
					for(unsigned int j = 0; j<unmatched.size(); j++)
					{
						if(unmatched[j]->equals(matches[0]))
						{
							unmatched.erase(unmatched.begin() + j);
							break;
						}
					}   	
					matchCHTNs(next->getHolesAndConcavities(), getTargetChildren(next));                    
				}
			}
		}
	}
}
\end{lstlisting}


In den Zeilen~4~-~18 werden alle Kombinationen von Source- und Target-Faces durchgegangen. Falls ein Match gefunden wird, so werden die entsprechenden \textit{Faces} und die \textit{Cycles} der \textit{Faces} gematcht (in beiden Richtungen). In Zeile 17 werden außerdem alle Source-Faces dem Feld \textit{unnmatched} hinzugef"ugt.

In den Zeilen 19-22 ereilt dieses Schicksal auch alle Target-Faces, so dass in der Table jetzt alle \textit{Faces} der beteiligten \textit{Faces} zu finden sind.

Die Zeilen 19-78 werden solange durchlaufen bis \textit{unmatched} leer ist, also alle \textit{Faces} bearbeitet sind.

In den Zeilen 25-27 werden die Zuordungen vorgenommen:
\begin{itemize}
\item \textit{next} wird zum n"achsten, unbearbeiteten Face
\item \textit{next} wird aus \textit{unmatched} gel"oscht (\textit{next} wird ja gerade bearbeitet)
\item \textit{matches} werden die Targets von \textit{next}
\end{itemize} 

Falls \textit{matches} nicht \textit{null} ist, werden alle zu \textit{next} gematchten \textit{Faces} gesucht, aus \textit{unmatched} gel"oscht und es wird die Funktion \textit{matchCHTNs} mit den entsprechenden Kindelementen aufgerufen. Die mehrfache Verzweigung dieses Codeteiles resultiert daraus, dass \textit{next} auf mehreren Seiten eine 1:n Beziehung liegen k"onnte. 

Es muss noch die Methode \textit{getBestMatch()} in zwei Überladungen implementiert werden, so dass es eine solche Methode gibt, die mehrere \textit{Faces} als Eingabe bekommt und ein \textit{Face} zurückgibt und eine die dasselbe für \textit{ConvexHullTreeNodes} tut. Im Folgenden wird nur die Funktion für \textit{Faces} betrachtet, die andere funktioniert analog.
\begin{lstlisting}[language=c++]
Face *CentroidMatch :: getBestMatch(Face *source, vector<Face*> *targets)
{
	double best = numeric_limits<double> :: max();
	Face* bestMatch = NULL;    
	for(unsigned int i = 0; i < targets->size(); i++)
	{    	    	
		double dist = getDistance(source->getCycle(), targets->at(i)->getCycle());        
        	if(dist < best)
		{
            		bestMatch = targets->at(i);
            		best = dist;
		}
    	}    
    	return(bestMatch);
}
\end{lstlisting}
In dieser Funktion werden alle \textit{Faces} aus \textit{targets} mit dem \textit{source} verglichen. Dabei wird das \textit{Target}, dessen Schwerpunkt den geringsten Abstand zu dem Schwerpunkt von \textit{source} ermitttelt und zurückgegeben.

\section{Die Integration eigener Matches in das Optimal Match}

Hat man ein eigenes Match implementiert, so muss man dieses auch in das \textit{OptimalMatch} eingehen lassen, da die SECONDO--Algebra nur dieses Match ausführt. Das \textit{OptimalMatch} beinhaltet im Wesentlichen nur den Konstruktor:
\begin{lstlisting}[language=c++]
OptimalMatch::OptimalMatch(RegionForInterpolation *source, RegionForInterpolation *target,vector<double> weights):
Match(source->clone(),target->clone(),"","")
{	        
	double AreaWeight = weights[0];
	double OverlapWeight = weights[0];
	double HausdorffWeight = weights[0];
	double LinearWeight = weights[0];
	Match *best;
	vector<Match*> candidates;
	candidates.push_back(new OverlapingMatch(source->clone(),target->clone(),0.3,false));
	candidates.push_back(new SteinerPointMatch(source->clone(),target->clone(),0.3,false));
	candidates.push_back(new CentroidMatch(source->clone(),target->clone(),0.3,false));
	best=candidates[0];
	for(unsigned int i=1;i<candidates.size();i++)
	{
		if(candidates[i]->getRating(AreaWeight,OverlapWeight,HausdorffWeight,LinearWeight)==best->getRating(AreaWeight,OverlapWeight,HausdorffWeight,LinearWeight))
		{            	
			best->addName(candidates[i]->getName());
		}
		if(candidates[i]->getRating(AreaWeight,OverlapWeight,HausdorffWeight,LinearWeight)>best->getRating(AreaWeight,OverlapWeight,HausdorffWeight,LinearWeight))
best=candidates[i];
	}
	best->finalize();
	this->name=best->getName();
	this->source=best->getSource();
	this->target=best->getTarget();
	this->description=best->getDescription();
	this->Arearating=best->getAreaRating();
	this->Hausdorffrating=best->getHausdorffRating();
	this->linearRating=best->getLinarRating();
	this->Ovelaprating=best->getOverlapRating();
	this->maps=best->getMaps();
}		
\end{lstlisting}
Zu Anfang des Konstruktors wird ein Feld angelegt, in dem alle Kantdaten für ein gutes \textit{Match} stehen. Neue \textit{Matches} müssen hier eingetragen werden. Dieses Feld wird dann nach dem am bestem bewerteten \textit{Match} durchsucht. Dieses \textit{Match} wird finalisiert und seine Attribute in das \textit{OptimalMatch} kopiert.

\section{Die Implementierung eigener Ratings}

Die Ratings dienen dazu, aus den verschiedenen Kanidaten für eine OptimalMatch den Besten herauszufinden. Implementiert man ein neues Rating, so kann man passendere Matches finden. 

In der Datei ,,Match.h'' finden sich die Attribute:
\begin{lstlisting}[language=c++]
protected:
	double Hausdorffrating;
	double Ovelaprating;
	double Arearating;
	double linearRating;
 \end{lstlisting}
Um ein eigenes Rating zu implementieren, muss man die Liste von Attributen erweitern. Zu den eigenen  Attributen muss man dann die Methode anlegen, die diese auslesen wie etwa:
\begin{lstlisting}[language=c++]
double Match :: getAreaRating()
{
    return(Arearating);
}
\end{lstlisting}

In der Datei ,,Match.cpp'' findet sich die Methode \textit{getRating}, die die gewichtete Summe aller Ratings zurückliefert. Auch diese Methode muss um das neue Rating erweitert werden.

In den Zeilen 4~--~7, des Konstruktors des OptimalMatches,  werden die einzelnen Gewichte aus dem übergebenen Feld gelesen, in  der Zeile~16 wird die gewichtete Summe gebildet und  in  28~--~31 werden die Ratings des besten Kanidaten in das OptimalMatch kopiert. Auch  diese Stellen müssen um das eigene Rating erweitert werden.

In der Datei ,,RegionInterpolator.cpp'' befindet sich die Präprozessoranweisung, die die Anzahl der zu übergebenden Gewichte angibt.
\begin{lstlisting}[language=c++]
#define COUNTWEIGHT 4
[...]
static int interpolateValueMap_1(Word* args,
                        Word& result,
                        int message,
                        Word& local,
                        Supplier s) 
{                         
    result = qp->ResultStorage(s);
    Region* reg1 = (Region*) args[0].addr;
    Region* reg2 = (Region*) args[1].addr;
    Periods *range = ((Periods*)args[2].addr);
    const Interval<Instant> *inter;    
    range->Get( 0, inter );
    assert(inter->IsValid());
    RegionForInterpolation *reginter1=new RegionForInterpolation(reg1);
    RegionForInterpolation *reginter2=new RegionForInterpolation(reg2);
    vector<double> weigths = vector<double>(COUNTWEIGHT);
    weigths[0] = 0.7; 				// AreaWeight
    weigths[1] = 0.7;				// OverlapWeight
    weigths[2] = 0.5;				// HausdorffWeight
    weigths[3] = 1.0;				// LinearWeight
    Match *sm=new OptimalMatch(reginter1,reginter2,weigths);
    mLineRep *lines=new mLineRep(sm);    
    URegion *res= new URegion(lines->getTriangles(),*inter);
    result.addr=res->Clone();       
    return 0;
}
\end{lstlisting}
In der Value--Mapping--Funkion, die den Aufruf ohne übergebene Gewichte abwickelt, werden die Gewichte auf Standard--Werte gesetzt. (Zeilen~19~--~22) Auch diese Stelle muss angepasst werden, genauso wie die Spezifikation des Operators. 

Um die bislang enthaltenen Ratings zu berechnen, wird die Methode \textit{generateRatings()} benutzt. Dieser wird nun näher beschrieben, da dies auch bei der Implementierung neuer Ratings helfen kann.
\begin{lstlisting}[language=c++]
void Match :: generateRatings()
{
	Hausdorffrating = 0.0;
	Ovelaprating = 0.0;
	Arearating = 0.0;
	linearRating = 0;
	NrOfRatings = 0;
	for(int i = 0; i < source->getNrOfFaces(); i++)
	{    		
		vector<RegionTreeNode*> tmp = getMatches(source->getFace(i));
		if(tmp.size() == 0)
		{        
			Hausdorffrating += Utils::getDiameter(Utils :: convertCHLine2LineWA(source->getFace(i)->getCycle()->getLines()));
			Ovelaprating += 0.0;
			Arearating += 0.0;
			linearRating += 0.5;
			NrOfRatings++;
		}
		else
		{                        
			rateFace(source->getFace(i), tmp);            
		}         
	}
	[...]
	Arearating = Arearating / NrOfRatings;
	Ovelaprating = Ovelaprating / NrOfRatings;
	Hausdorffrating = 1 - Hausdorffrating / NrOfRatings / greatestDist;
	linearRating = linearRating / NrOfRatings;            
}	
\end{lstlisting}
Nachdem die verscheidenen Variablen initialisiert wurden, Zeile 3~--~ 7, werden alle \textit{Faces} der Source--Region durchlaufen. Wird ein betrachtetes \textit{Face} gegen $null$ gematcht, so werden die Variablen auf den entsprechenden Wert gesetzt. Ansonsten wird die Funktion \textit{rateFace()} aufgerufen, in der die weitere Berechnung für einzelne \textit{Faces} stattfindet. 

In Zeile 24 passiert dasselbe für die Target--Region (hier nicht dargestellt). Zuletzt werden die einzelnen Ratings endgültig berechnet. Meist geschieht das, indem die Summe der Einzelratings duch deren Anzahl dividiert wird. 

In den Methoden \textit{rateFace()} und \textit{rateCHTN()} werden die Einzelratings berechnet. Die Berechnung passiert analog zu der Berechnung in \textit{generateRatings()}.

