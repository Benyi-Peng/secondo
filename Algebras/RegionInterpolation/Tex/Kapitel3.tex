\chapter[Eigenes]{Eigenes
\normalsize{Die Java-Applikation, Die Secondo Algebra, Experimante mit Regionen}\anmerkung{30-40 Seiten Astrid: Vorschlag f√ºr besseren Namen}
}
\minitoc
\newpage
\section{Benutzte Hilfsklassen}
\subsection{RegionTreeNode}

Dieses Interface dient dazu, Region, Faces und ConvexHullTreeNodes gleichbehandeln zu k"onnen. Implementiert sind nur hashCode und equals, zum Auffinden von SingleMatches in HashSets.

\subsection{\index{SingleMatch}SingleMatch}
Diese Klasse repr"asentiert eine einzelnes Teilmatch.  Es enth"alt eine Source-Kom"-ponente und ein Feld von Target-Komponenten. Alle Komponenten sind RegionTreeNodes.
Die wichtigsten Methoden sind:

\begin{itemize}
\item Der Konstruktor

Der Konstruktor legt ein SingleMatch zwischen den Komponenten Source und Target an. Es kann nur ein einziges Target "ubergeben werden, weitere m"ussen mit addTarget hinzugef"ugt werden.



\item addTarget

Diese Methode f"ugt eine weitere Target-Komponente hinzu.

\item getNrTargets

Diese Methode liefert die Anzahl der Targets.

\item getTargetAt

Diese Methode liefert das Target mit dem "ubergebenen Index zur"uck.

\item removeTargets

Diese Methode l"oscht alle Targets dieses SingleMatches.

\item hashCode

Liefert den Hashwert des Matches.

\item equals

"Uberpr"uft zwei Komponenten auf Gleichheit.

\end{itemize}

Die beiden letzten Methoden dienen dazu, SingleMatches in einem HashSet ablegen zu k"onnen, wobei nur die source-Komponente f"ur das Auffinden des Matches herangezogen wird.

\section{Die abstrakte Klasse Match}
Diese Klasse stellt die wesentlichen Mechanismen zur Verf"ugung, um einfach Matches programmieren zu k"onnen. Es enth"alt die Eigenschaften:
\begin{itemize}
\item source

Die Region zum Eingangszeitpunkt.

\item target

Die Region zum Ausgangszeitpunkt.

\item maps

Ein Hashtable, in dem die einzelenen Teilmatches abgelegt werden. Der Schl"ussel, um auf die Elemente dieses Tables zugreifen zu k"onnen ist die Quell-Komponente vom Typ RegionTreeNode.

\item name

Der Name des Matches.

\item description

Eine Beschreibung, wie das Matching funktioniert.
\end{itemize} 

Diese Klasse verf"ugt "uber einige Methoden, die wichtigen davon  sind:

\begin{itemize}

\item Der Konstruktor

Setzt Name, Beschreibung, Source und Target auf die angegebenen Werte und initialisiert ein leeres Hashtable.

\item addMatch

Diese Methode f"ugt ein neues Match von Source nach Target ein. Sollte es noch kein Match von Source aus geben, so legt er ein neues Match an, und erweitert anderenfalls das Vorhandene.

\item getMatches

Diese Methode liefert ein Feld mit allen Targets, die von Source aus gematcht sind.

\item getTargetChildren

Diese Methode liefert alle Kinder der Targets als Feld aus. Falls ein Target ein ConvexHullTreeNode ist, dann finden sich im R"uckgabefeld alle seine Kinder  wieder, falls Target ein Face ist, dann werden alle Holes und die Kinder des Cycles zur"uckgegeben. Diese Sonderbehandlung des Faces ist n"otig, da man ein Face mit seinem Cycle identifizieren kann, und die L"ocher also quasi Kinder des Cycles sind.

\item fertig

Die Erzeugung von Dreiecken bzw. MovingLines mit der Klasse mLineRep funktioniert nur, falls nur 1:1 Matchings vorkommen. Nach der Erzeugung des Matchings ist das im Allgemeinen nicht gew"ahrleistet, desshalb muss man am Ende der Erzeugung diese Methode aufrufen, die sich darum k"ummert. Auch die Beseitigung von zu stark gedrehten Konkativit"aten findet hier statt. N"aheres zum Ablauf dieser Funktion folgt weiter unten.

\item Die Bewertungsfunktionen

In dieser Klasse sind auch einige der Bewertungsverfahren implementiert, die in dem allgemeinen Matching-Teil beschrieben sind. Im einzelnen sind dass:
\begin{itemize}
\item Das Area-Rating
\item Das Hausdorff-Rating
\item Das Linear-Rating
\item Das Overlap-Rating
\end{itemize}

\end{itemize}

\section{Beseitigung von 1:n Matches}

Falls es ein 1:n Matching gibt, dann muss diese aufgel"ost werden. Hierbei existieren 2 M"oglichkeiten:
\begin{itemize}
\item Alle $n$ Targets sind Kinder einer einzigen ConvexHullTreeNode

Dieser Fall ist der einfachere, seine Behandlung wurde schon von Herrn T\o{}ssebro beschrieben. Kurz gesagt geht es darum, die konvexe H"ulle aller Targets zu bilden, und das Matching von den $n$ Targets auf diese neue H"ulle umzuleiten.

\item Alle n Targets haben unterschiedliche V"ater

In diesem Fall kommen wir mit der Vereinigung der Targets, wie oben beschrieben, nicht weiter, also m"ussen wir versuchen, den Source aufzuteilen. Hiebei ist zu beachten:
\begin{itemize}
\item Eine ConvexHullTreeNode kann man nur an Eckpunkten, oder an Punkten auf Linien teilen, die keine Kinder haben, da man sonst den ConvexHullTree zerst"oren w"urde.

\item Eine ConvexHullTreeNode kann man nur an zwei Punkten teilen, wenn das beschriebene Polygon auch nur in zwei Teile zerf"allt.
\item Zerteilt man ein Face, so sollte man dabei kein Hole zerteilen. Falls sich das nicht verhindern l"asst, so zerf"allt das Loch in zwei Konkavit"aten, was eine Neuberechnung der entsprechenden Matchings zu Folge hat.

\item Die Zerteilung der Source-Komponente sollte die Lage und das Verh"altnis der Fl"acheninhalte der Target-Komponenten weitestgehend wiederspiegeln.

\end{itemize} 
\end{itemize} 
\section{Beseitigung von "`gedrehten Konkativit"aten"'}
In manchen F"allen versagt das in \cite{TG} genannte Verfahren, um aus Matchings Moving-Regions zu erzeugen. Dieses, in Kapitel "`6 Interpolating between two arbitray polygones"' beschriebene Verfahren setzt voraus, dass die beiden gematchten Kinderpolygone ein gemeinsames, aus zwei Dreiecken zusammengesetztes Trapez in der Aussenh"ulle der beider Vaterpolygone besitzen. 

Dies ist zum Biespiel dann nicht der Fall, wenn wir uns als Quellpolygon ein "`U"', und als Zielpolygon ein um 90$\degree$ gedrehtes "`U"' vorstellen. Auch wenn die Konkativit"aten richtig zueinander gematcht sind, versagt das bekannte Verfahren.

Die, das Matching abschlie"sende, Funktion kann solche F"alle erkenne, indem es die Winkel betrachtet, die die gemeinsame Kante von Kind und Vater, sowie die beiden Nachbarkanten des Vates, mit der x-Achse haben. Ist der Winkel der gemeinsamen Kante auf der einen Seite nicht im  Intervall der Winkel der Nachbarkanten der anderen Seite, so liegt der Fal vor, dass das Verfahren nicht funktioniert.

Wenn ein solcher Fall erkannt wird, so gibt es zwei M"oglichkeiten zu reagieren:
\begin{itemize}
\item Beide Konkativit"aten werden gegen $null$ gematcht

In diesem Fall sehen wir, wie die Konkativit"at auf der einen Seite verschwindet, und zeitgleich auf der anderen Seite eine Neue entsteht. Obwohl dieses Verfahren das deutlich Einfachere ist, sieht das Resultat recht gut aus.

\item Die beiden Konkativit"aten werden zu L"ochern umgewandelt

In diesem Fall werden beide Konkavit"aten in L"ocher verwandelt, die dann zueinander gematcht werden. In dem Resultat w"urde man also sehen, wie sich die Konkativit"at von der einen Seite abl"ost, und zu der anderen Seite wandert. M"oglicherweise sieht dieses Verfahren nat"urlicher aus, man muss sich aber noch "uberlegen, was passiert, wenn der Weg zwischen den beiden Positionen dicht "`frei"' ist (etwa weil sich hier ein weiteres Loch oder eine Konkativit"at befindet).

\end{itemize}


\section{Eine Beispielimplementation}

Der folgende Quellcode ist ein Beispiel f"ur die Implementierung eines Matches, er ist der Klasse CentroidMatch entnommen, k"onnte aber auch aus der Klasse OverlapingMatch stammen. 

\begin{lstlisting}
public ExampleMatch(Region source, Region target,int threshold){
   super(source,target,"ExampleMatch",description);
   this.addMatch(source,target);
   HashSet unmatched=new HashSet();
   for(int i=0;i< source.getNrOfFaces();i++) {
      for(int j=0;j<target.getNrOfFaces();j++) {                         
         if(isMatch()) {
            this.addMatch(source.getFace(i),target.getFace(j));
            this.addMatch(target.getFace(j),source.getFace(i));
            this.addMatch(source.getFace(i).getCycle(),target.getFace(j).getCycle());
            this.addMatch(target.getFace(j).getCycle(),source.getFace(i).getCycle());
         }
      }
      unmatched.add(source.getFace(i));
   }
   for(int i=0;i<target.getNrOfFaces();i++) {
      unmatched.add(target.getFace(i));
   }
   while(!unmatched.isEmpty()) {
      Face next=(Face)(unmatched.iterator().next());
      unmatched.remove(next);
      RegionTreeNode[] matches=this.getMatches(next);
      if(matches!=null&&matches[0]!=null) {
         if(matches.length>1) {
            int dimMatch=0;
            for(int i=0;i<matches.length;i++) {
               unmatched.remove(matches[i]);
               dimMatch+=((Face)matches[i]).getCycle().getChildren().length;
            }
            this.matchCHTNs(next.getCycle().getChildren(),this.getTargetChildren(next),threshold);
         }
         else {
            if(getMatches(matches[0]).length>1) {
               for(int i=0;i<getMatches(matches[0]).length;i++) {
                  unmatched.remove(getMatches(matches[0])[i]);
               }
               this.matchCHTNs(((Face)matches[0]).getCycle().getChildren(),this.getTargetChildren(matches[0]),threshold);
            }
            else {
               unmatched.remove(matches[0]);
               this.matchCHTNs(next.getCycle().getChildren(),((Face)matches[0]).getCycle().getChildren(),threshold);
            }
         }
      }
   }
   this.fertig();
}
\end{lstlisting}
Man kann sehen, dass die eigentliche Arbeit in dem Konstruktor passiert. 

In den Zeilen 2-4 wird der Superkonstruktor aufgerufen, dabei werden Name, Beschreibung, Source und Target gesetzt. Dann wird ein Match f"ur die Regionen source und target hinzugef"ugt und es wird die HashTabe unmatched initialisiert.

In den Zeilen 5-15 werden alle Kombinationen von Source- und Target-Faces durchgegangen. Falls ein Match gefunden wird (hier von der Dummy-Methode isMatch()), so werden die entsprechenden Faces und die Cycles der Faces gematcht (in beiden Richtungen). In Zeile 14 werden ausserdem alle Source-Faces der Table unnmatched hinzugef"ugt.

In den Zeilen 16-18 ereilt dieses Schicksal auch alle Target-Faces, so dass in dem Table jetzt alle Faces der beteiligten Regionen zu finden sind.

Die Zeilen 19-45 werden solage duchlaufen, bis unmatched leer ist, also alle Faces weiterbearbeitet sind.

In den Zeilen 22-24 werden die Zuordungen vorgenommen:
\begin{itemize}
\item next wird zum n"achsten unbearbeiteten Face
\item next wird aus unmatched gel"oscht (next wird ja gerade bearbeitet)
\item matches werden die Targets von next

\end{itemize} 
Falls matches nicht null ist, werden alle zu next gematchten Faces gesucht, aus dem Table gel"oscht, und es wird die Funktion matchCHTN mit den entsprechenden Kindelementen aufgerufen. Die mehrfache Verzweigung dieses Codeteiles liegt daran, dass next auf mehreren Seiten einen 1:n Beziehung liegen k"onnte. Die Methode matchCHTN macht im Prinzip das gleiche wie der Konstruktor, nur entf"allt die Sonderbehandlung der Holes und Cycles.

In Zeile wird endlich die Funktion fertig aufgerufen, die das Matching, wie oben beschrieben, bereinigt.

%\chapter{Vom Matching zum MovingRegion}

%\printindex

%\nocite{KOP}
%\nocite{AAR}
%\nocite{Sch}
%\nocite{AHS}
%\nocite{BW}
%\nocite{Doe1}
%\nocite{Doe1a}
%\nocite{Doe2}
%\nocite{Schi}
%\nocite{Ber}
%\nocite{Lei}
%\nocite{Gru}
%\nocite{AFRW}
