\documentclass[a4paper,10pt,twoside]{scrreprt}

\usepackage{ngerman}
\usepackage[T1]{fontenc}

\usepackage{index}
  \newindex{default}{idx}{ind}{Schlagwortverzeichnis}
\renewcommand{\labelenumi}{\theenumi)}
\renewcommand{\labelenumii}{enumii)}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{eufrak} 
\usepackage{listings}
\usepackage{bibgerm}
\lstset{language=java}
\lstset{emph={HashSet,Region,Face, ConvexHullTreeNode,RegionTreeNode}}
\lstset{breaklines=true,frame=tlrb,numbers=left,emphstyle=\textbf}
%opening
\title{Das Matching in der praktischen Umsetzung}
\author{Andreas RuloffsMatchingPaxis}
\pagestyle{headings}
\begin{document}
\maketitle

\begin{abstract}
In diesem Dokument beschreibe ich, wie man das Matching, unter Verwendung der abstrakten Match-Klasse, konkret implementieren kann. Hierbei gehe ich auch auf die internen Vorg"ange in dieser Klasse ein.
\end{abstract}
\tableofcontents
\chapter{Das Matching in der Praxis}

\section{Benutzte Hilfsklassen}
\subsection{RegionTreeNode}

Dieses Interface dient dazu, Region, Faces und ConvexHullTreeNodes gleichbehandeln zu k"onnen. Implementiert sind nur hashCode und equals, zum Auffinden von SingleMatches in HashSets.

\subsection{\index{SingleMatch}SingleMatch}

Diese Klasse repr"asentiert eine einzelnes Teilmatch.  Es enth"alt eine Source-Komponente und ein Feld von Target-Komponenten. Alle Komponenten sind RegionTreeNodes.
Die wichtigsten Methoden sind:

\begin{enumerate}
\item Der Konstruktor

Der Konstruktor legt ein SingleMatch zwischen den Komponenten Source und Target an. Es kann nur ein einziges Target "ubergeben werden, weitere m"ussen mit addTarget hinzugef"ugt werden.
\begin{enumerate}


\item addTarget

Diese Methode f"ugt eine weitere Target-Komponente hinzu.

\item getNrTargets
\end{enumerate}
Diese Methode liefert die Anzahl der Targets.
\cite{AAR}\begin{center}

\end{center}
\item getTargetAt

Diese Methode liefert das Target mit dem "ubergebenen Index zur"uck.

\item removeTargets

Diese Methode l"oscht alle Targets dieses SingleMatches.

\item hashCode

Liefert den Hashwert des Matches.

\item equals

"Uberpr"uft zwei Komponenten auf Gleichheit.

Die beiden letzten Methoden dienen dazu, SingleMatches in einem HashSet ablegen zu k"onnen, wobei nur die source-Komponente f"ur das Auffinden des Matches herangezogen wird.

\end{enumerate}

\section{Die abstrakte Klasse Match}
Diese Klasse stellt die wesentlichen Mechanismen zur Verf"ugung, um einfach Matches programmieren zu k"onnen. Es enth"alt die Eigenschaften:
\begin{itemize}
\item source

Die Region zum Eingangszeitpunkt.

\item target

Die Region zum Ausgangszeitpunkt.

\item maps

Ein Hashtable, in dem die einzelenen Teilmatches abgelegt werden. Der Schl"ussel, um auf die Elemente dieses Tables zugreifen zu k"onnen ist die Quell-Komponente vom Typ RegionTreeNode.

\item name

Der Name des Matches.

\item description

Eine Beschreibung, wie das Matching funktioniert.
\end{itemize} 

Diese Klasse verf"ugt "uber einige Methoden, die wichtigen davon  sind:

\begin{itemize}

\item Der Konstruktor

Setzt Name, Beschreibung, Source und Target auf die angegebenen Werte und initialisiert ein leeres Hashtable.

\item addMatch

Diese Methode f"ugt ein neues Match von Source nach Target ein. Sollte es noch kein Match von Source aus geben, so legt er ein neues Match an, und erweitert anderenfalls das Vorhandene.

\item getMatches

Diese Methode liefert ein Feld mit allen Targets, die von Source aus gematcht sind.

\item getTargetChildren

Diese Methode liefert alle Kinder der Targets als Feld aus. Falls ein Target ein ConvexHullTreeNode ist, dann finden sich im R"uckgabefeld alle seine Kinder  wieder, falls Target ein Face ist, dann werden alle Holes und die Kinder des Cycles zur"uckgegeben. Diese Sonderbehandlung des Faces ist n"otig, da man ein Face mit seinem Cycle identifizieren kann, und die L"ocher also quasi Kinder des Cycles sind.

\item fertig

Die Erzeugung von Dreiecken bzw. MovingLines mit der Klasse mLineRep funktioniert nur, falls nur 1:1 Matchings vorkommen. Nach der Erzeugung des Matchings ist das im Allgemeinen nicht gew"ahrleistet, desshalb muss man am Ende der Erzeugung diese Methode aufrufen, die sich darum k"ummert. N"aheres zum Ablauf dieser Funktion folgt weiter unten.

\item Die Bewertungsfunktionen

In dieser Klasse werden sp"ater auch die Bewertungsverfahren implementiert, die in dem allgemeinen Matching-Teil beschrieben sind.

\end{itemize}

\section{Beseitigung von 1:n Matches}

Falls es ein 1:n Matching gibt, dann muss diese aufgel"ost werden. Hierbei existieren 2 M"oglichkeiten:
\begin{itemize}
\item Alle n Targets sind Kinder einer einzigen ConvexHullTreeNode

Dieser Fall ist der einfachere, seine Behandlung wurde schon von Herrn T\o{}ssebro beschrieben. Kurz gesagt geht es darum, die konvexe H"ulle aller Targets zu bilden, und das Matching von den n Targets auf diese neue H"ulle umzuleiten.

\item Alle n Targets haben unterschiedliche V"ater

In diesem Fall kommen wir mit der Vereinigung der Targets, wie oben beschrieben, nicht weiter, also m"ussen wir versuchen, den Source aufzuteilen. Hiebei ist zu beachten:
\begin{itemize}
\item Eine ConvexHullTreeNode kann man nur an Eckpunkten, oder an Punkten auf Linien teilen, die keine Kinder haben, da man sonst den ConvexHullTree zerst"oren w"urde.

\item Eine ConvexHullTreeNode kann man nur an zwei Punkten teilen, wenn das beschriebene Polygon auch nur in zwei Teile zerf"allt.
\nocite{KOP}
\item Zerteilt man ein Face, so sollte man dabei kein Hole zerteilen. Falls sich das nicht verhindern l"asst, so zerf"allt das Loch in zwei Konkavit"aten, was eine Neuberechnung der entsprechenden Matchings zu Folge hat.

\item Die Zerteilung der Source-Komponente sollte die Lage und das Verh"altnis der Fl"acheninhalte der Target-Komponenten weitestgehend wiederspiegeln.

\end{itemize} 
\end{itemize} 

\section{Eine Beispielimplementation}

Der folgende Quellcode ist ein Beispiel f"ur die Implementierung eines Matches, er ist der Klasse CentroidMatch entnommen, k"onnte aber auch aus der Klasse OverlapingMatch stammen. 

\begin{lstlisting}
public ExampleMatch(Region source, Region target,int threshold){
   super(source,target,"ExampleMatch",description);
   this.addMatch(source,target);
   HashSet unmatched=new HashSet();
   for(int i=0;i< source.getNrOfFaces();i++) {
      for(int j=0;j<target.getNrOfFaces();j++) {                         
         if(isMatch()) {
            this.addMatch(source.getFace(i),target.getFace(j));
            this.addMatch(target.getFace(j),source.getFace(i));
            this.addMatch(source.getFace(i).getCycle(),target.getFace(j).getCycle());
            this.addMatch(target.getFace(j).getCycle(),source.getFace(i).getCycle());
         }
      }
      unmatched.add(source.getFace(i));
   }
   for(int i=0;i<target.getNrOfFaces();i++) {
      unmatched.add(target.getFace(i));
   }
   while(!unmatched.isEmpty()) {
      Face next=(Face)(unmatched.iterator().next());
      unmatched.remove(next);
      RegionTreeNode[] matches=this.getMatches(next);
      if(matches!=null&&matches[0]!=null) {
         if(matches.length>1) {
            int dimMatch=0;
            for(int i=0;i<matches.length;i++) {
               unmatched.remove(matches[i]);
               dimMatch+=((Face)matches[i]).getCycle().getChildren().length;
            }
            this.matchCHTNs(next.getCycle().getChildren(),this.getTargetChildren(next),threshold);
         }
         else {
            if(getMatches(matches[0]).length>1) {
               for(int i=0;i<getMatches(matches[0]).length;i++) {
                  unmatched.remove(getMatches(matches[0])[i]);
               }
               this.matchCHTNs(((Face)matches[0]).getCycle().getChildren(),this.getTargetChildren(matches[0]),threshold);
            }
            else {
               unmatched.remove(matches[0]);
               this.matchCHTNs(next.getCycle().getChildren(),((Face)matches[0]).getCycle().getChildren(),threshold);
            }
         }
      }
   }
   this.fertig();
}
\end{lstlisting}
Man kann sehen, dass die eigentliche Arbeit in dem Konstruktor passiert. 

In den Zeilen 2-4 wird der Superkonstruktor aufgerufen, dabei werden Name, Beschreibung, Source und Target gesetzt. Dann wird ein Match f"ur die Regionen source und target hinzugef"ugt und es wird die HashTabe unmatched initialisiert.

In den Zeilen 5-15 werden alle Kombinationen von Source- und Target-Faces durchgegangen. Falls ein Match gefunden wird (hier von der Dummy-Methode isMatch()), so werden die entsprechenden Faces und die Cycles der Faces gematcht (in beiden Richtungen). In Zeile 14 werden ausserdem alle Source-Faces der Table unnmatched hinzugef"ugt.

In den Zeilen 16-18 ereilt dieses Schicksal auch alle Target-Faces, so dass in dem Table jetzt alle Faces der beteiligten Regionen zu finden sind.

Die Zeilen 19-45 werden solage duchlaufen, bis unmatched leer ist, also alle Faces weiterbearbeitet sind.

In den Zeilen 22-24 werden die Zuordungen vorgenommen:
\begin{itemize}
\item next wird zum n"achsten unbearbeiteten Face
\item next wird aus unmatched gel"oscht (next wird ja gerade bearbeitet)
\item matches werden die Targets von next

\end{itemize} 
Falls matches nicht null ist, werden alle zu next gematchten Faces gesucht, aus dem Table gel"oscht, und es wird die Funktion matchCHTN mit den entsprechenden Kindelementen aufgerufen. Die mehrfache Verzweigung dieses Codeteiles liegt daran, dass next auf mehreren Seiten einen 1:n Beziehung liegen k"onnte. Die Methode matchCHTN macht im Prinzip das gleiche wie der Konstruktor, nur entf"allt die Sonderbehandlung der Holes und Cycles.

In Zeile wird endlich die Funktion fertig aufgerufen, die das Matching, wie oben beschrieben, bereinigt.

\chapter{Vom Matching zum MovingRegion}

\printindex

\nocite{KOP}
\nocite{AAR}
\nocite{Sch}
\nocite{AHS}
\nocite{BW}
\nocite{Doe1}
\nocite{Doe1a}
\nocite{Doe2}
\nocite{Schi}
\nocite{Ber}
\nocite{Lei}
\nocite{Gru}
\nocite{AFRW}
\bibliography{literatur}

\bibliographystyle{geralpha}

\end{document}