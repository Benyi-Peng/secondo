/*
---- 
This file is part of SECONDO.

Copyright (C) 2004, University in Hagen, Department of Computer Science, 
Database Systems for New Applications.

SECONDO is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

SECONDO is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with SECONDO; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
----

//[%]	[\%]

May 15, 1998 RHG. Added ~model~ token.

August 8, 2000 RHG. Changed [%]p (the number of positions for Lex) to 5000.

August 10, 2000 RHG. Changed [%]e (the number of parse tree nodes) to 2000.

March 2002 Ulrich Telle Port to C++, using ~flex~ and ~bison~ instead of ~lex~ and ~yacc~.
The pattern for floating point numbers is adjusted so that numbers produced by
C/C++ programs are interpreted correctly.

January 29, 2004 RHG. Increased numbers [%]n to 2000 and [%]e to 4000.

October 14, 2004 RHG Added text and file tokens.

*/
			
%p 8000
%n 2000
%e 4000
%x TEXT

%option yylineno

%{
#include "SecParser.tab.hpp"
#include "NestedText.h"
#include <string>
#include <sstream>

#define yylval xxlval
extern int yylval;
int yywrap();

ostringstream* text_sp = 0;

#define YY_NO_UNPUT
%}

letter         	[a-zA-Z]
digit          	[0-9]
ident          	{letter}({letter}|{digit}|_)*  
num1	       	[-+]?{digit}+\.?([eE][-+]?{digit}+)?
num2	       	[-+]?{digit}*\.{digit}+([eE][-+]?{digit}+)?
number	       	{num1}|{num2}
string         	\"[^\"]*\"   
textstart       "<text>"
textend         "</text--->"
file	  	"<file>"[^<\n]+"</file--->"

%%

[ \t\n\r\v\f\b\a]+  	;

-?[0-9]+  	{yylval = NestedText::Atom( yytext, yyleng ); return ZZINTEGER;}
{number}	{yylval = NestedText::Atom( yytext, yyleng ); return ZZREAL;}
TRUE  		{yylval = NestedText::Atom( yytext, yyleng ); return ZZBOOLEAN;}
FALSE		{yylval = NestedText::Atom( yytext, yyleng ); return ZZBOOLEAN;}
{string} 	{yylval = NestedText::Atom( yytext, yyleng ); return ZZSTRING;}
fun		{yylval = NestedText::Atom( yytext, yyleng ); return ZZFUN;}
const		{yylval = NestedText::Atom( yytext, yyleng ); return ZZCONST;}
tuple		{yylval = NestedText::Atom( yytext, yyleng ); return ZZTUPLE;}
group		{yylval = NestedText::Atom( yytext, yyleng ); return ZZGROUP;}

type		{yylval = NestedText::Atom( yytext, yyleng ); return ZZTYPE;}
delete		{yylval = NestedText::Atom( yytext, yyleng ); return ZZDELETE;}
create		{yylval = NestedText::Atom( yytext, yyleng ); return ZZCREATE;}
update		{yylval = NestedText::Atom( yytext, yyleng ); return ZZUPDATE;}
kill		{yylval = NestedText::Atom( yytext, yyleng ); return ZZKILL;}
":="		{yylval = NestedText::Atom( yytext, yyleng ); return ZZASSIGN;}
query		{yylval = NestedText::Atom( yytext, yyleng ); return ZZQUERY;}
model           {yylval = NestedText::Atom( yytext, yyleng ); return ZZMODEL;}
let		{yylval = NestedText::Atom( yytext, yyleng ); return ZZLET;}
derive		{yylval = NestedText::Atom( yytext, yyleng ); return ZZDERIVE;}
persistent	{yylval = NestedText::Atom( yytext, yyleng ); return ZZPERSISTENT;}
begin		{yylval = NestedText::Atom( yytext, yyleng ); return ZZBEGIN1;}
transaction	{yylval = NestedText::Atom( yytext, yyleng ); return ZZTRANSACTION;}
commit		{yylval = NestedText::Atom( yytext, yyleng ); return ZZCOMMIT;}
abort		{yylval = NestedText::Atom( yytext, yyleng ); return ZZABORT;}
database	{yylval = NestedText::Atom( yytext, yyleng ); return ZZDATABASE;}
open		{yylval = NestedText::Atom( yytext, yyleng ); return ZZOPEN;}
close		{yylval = NestedText::Atom( yytext, yyleng ); return ZZCLOSE;}
save		{yylval = NestedText::Atom( yytext, yyleng ); return ZZSAVE;}
to		{yylval = NestedText::Atom( yytext, yyleng ); return ZZTO;}
restore		{yylval = NestedText::Atom( yytext, yyleng ); return ZZRESTORE;}
from		{yylval = NestedText::Atom( yytext, yyleng ); return ZZFROM;}
list		{yylval = NestedText::Atom( yytext, yyleng ); return ZZLIST;}
algebras	{yylval = NestedText::Atom( yytext, yyleng ); return ZZALGEBRAS;}
algebra		{yylval = NestedText::Atom( yytext, yyleng ); return ZZALGEBRA;}
databases	{yylval = NestedText::Atom( yytext, yyleng ); return ZZDATABASES;}
constructors	{yylval = NestedText::Atom( yytext, yyleng ); return ZZCONSTRUCTORS;}
operators	{yylval = NestedText::Atom( yytext, yyleng ); return ZZOPERATORS;}
types		{yylval = NestedText::Atom( yytext, yyleng ); return ZZTYPES;}
objects		{yylval = NestedText::Atom( yytext, yyleng ); return ZZOBJECTS;}
counters	{yylval = NestedText::Atom( yytext, yyleng ); return ZZCOUNTERS;}
".."		{yylval = NestedText::Atom( yytext, yyleng ); return ZZDOUBLE;}
"="		{yylval = NestedText::Atom( yytext, yyleng ); return ZZEQ;}
value		{yylval = NestedText::Atom( yytext, yyleng ); return ZZVALUE;}
{textstart}	{if(text_sp)
                   delete text_sp;
                 text_sp = new ostringstream(); 
                 (*text_sp) << "<text>";
                 BEGIN(TEXT);
                }
<TEXT>{textend} {  (*text_sp) << "</text--->";
                   string tmp = text_sp->str();
                   char* tmp2 = new char[tmp.length()+1];
                   memcpy(tmp2,tmp.c_str(),tmp.length());
                   tmp2[tmp.length()]=0;
                   yylval = NestedText::Atom(tmp2,tmp.length());
                   delete [] tmp2;
                   delete text_sp;
                   text_sp = 0;
                   BEGIN(INITIAL);
                   return ZZTEXT;
                }
<TEXT>.|\n      { text_sp->put(yytext[0]); }

{file}		{yylval = NestedText::Atom( yytext, yyleng ); return ZZFILE;}
