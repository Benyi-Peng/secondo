%
% Review
%
%

\chapter{Review}
\section{Überblick}
\begin{itemize}
	\item SQL-Standard unterscheidet in
	\subitem \enquote{scalar subqueries} (Ergebnis der Abfrage ist ein einzelner Wert)
	\subitem \enquote{row subqueries} (Ergebnis der Abfrage ist eine Liste/Menge von Werten)
	\subitem \enquote{table subqueries} (Ergebnis der Abfrage ist eine Relation)
	\item nach Korrelation
	\subitem nicht-korreliert (trivial, Ergebnis ist Konstante/Liste von Konstanten)
	\subitem korrelierte geschachtelte Abfrage
	\subsubitem ohne Aggregation
	\subsubitem mit Aggregation
	\item Ort des Auftretens
	\subitem \textbf{SELECT-Klausel}
	\subitem \textbf{FROM-Klausel}
	\subitem \textbf{WHERE-Klausel}
	\subitem (GROUP BY\dots HAVING-Klausel)
\end{itemize}

\section{Optimierungsansätze für geschachtelte Abfragen}
\subsection{Mit Standard-Operatoren}
\subsection{Mit erweiterten Operatoren}
\begin{itemize}
	\item G-Aggregation
	\item G-Join
	\item G-Restriction
	\item G-Outerjoin
	\item Apply
	\item SegmentApply
	\item NULL-rejecting Outerjoin
\end{itemize}

\cite{375748,1247598,ISO:1992:IITa} 
Die Auswertung von geschachtelten Abfragen wird im SQL-Standard \cite{ISO:1992:IITa} definiert. Hierbei wird der innere Abfrageblock für jedes Tupel des äußeren Abfrageblocks ausgewertet. Enthält die Unterabfrage korrelierte Join-Prädikate, so werden die entsprechenden Werte aus dem Tupel des äußeren Abfrageblocks als Konstanten in die Prädikate der Subquery übernommen.
\cite{319745, 38723} 
Klassifikation von Prädikaten in 
Simple(Vergleich mit Konstante(n)), 
Nested, 
Join und 
Divisionsprädikat,\\
Einschränkung bei Join-Prädikaten auf =-Operator, \\
nur eine Spalte in der Select-Klausel erlaubt in Subquery, \\
keine GROUP BY\dots HAVING-Klausel in Subquery \cite{671658}, \\
Innerer und und äußerer Abfrageblock, \\
Klassifkation in 
N =(kein Join-Prädikat, dass auf Relationen im äußeren Abfrageblock verweist, keine Aggregationsfunktion in  Select-Klausel, ergibt eine Liste von Konstanten), 
A =(kein Join-Prädikat, dass auf Relationen im äußeren Abfrageblock verweist, Aggregationsfunktion in Select-Klausel, kann vollkommen unabhängig vom äußeren Abfrageblock ausgewertet werden, Ergebnis ist immer eine Konstante, 
J =(hat Join-Prädikat das die/eine Relation aus dem äußeren Abfrageblock referenziert, keine Aggregationsfunktion in Select-Klausel), 
JA =(hat Join-Prädikat mit Verweis auf Relation im äußeren Abfrageblock, Aggregationsfunktion), 
D =(ein Divisions-Prädikat, dass in einer der beiden Abfrageblöcke ein Join-Prädikat mit Verweis auf eine Relation im äußeren Abfrageblock, drückt die relationale Divisionsoperation aus), \\
\emph{nested-iteration method}, vollständige Auswertung des inneren Abfrageblocks für jedes Tupel des äußeren Blocks
\subsection{Algorithmus \textbf{NEST-N-J}}
Alle FROM-Klausel kombinieren\\
Die Konjunktion der WHERE-Klauseln bilden\\
Das geschachtelte Prädikat \begin{math}[R_i.C_h \operatorname{op}\ (\texttt{SELECT} R_j.C_m \dots)]\end{math} ersetzen durch ein neues Join-Prädikat \begin{math}[R_i.C_h \operatorname{\emph{new-op}} R_j.C_m]\end{math}, das mit der restlichen WHERE-Klausel per Konjunktion verbunden ist\\
Die SELECT-Klausel des äußersten Abfrageblocks behalten\\

\begin{lstlisting}
select $A_1 ,\dots,A_n$ 
from $R_1 ,\dots,R_m$ 
where $P_1,\dots,P_l,$ 
	$X\operatorname{\theta}\ ($
		select 
			$T_i.B$ 
		from 
			$T_1 ,\dots,T_s$ 
		where 
			$Q_1,\dots,Q_r$
	$)$
\end{lstlisting}

wird transformiert in 

\begin{lstlisting}
select $A_1,\dots,A_n$
from $R_1,\dots,R_m,T_1,\dots,T_s$
where $P_1,\dots,P_l$,
	$Q_1,\dots,Q_r$
	$X\operatorname{\theta^'}T_i.B$
\end{lstlisting}

\begin{math}
X \subset\{A_1,\ldots,A_n\} \\[1em]
\theta \in \{\operatorname{IN},\operatorname{NOT\ IN},=,\not=,>,\geq,<,\leq\} \\[1em]
\theta^{'} = 
\begin{cases}
=&\quad\text{falls}\ \theta = \operatorname{IN}, \\
\not=&\quad\text{falls}\ \theta = \operatorname{NOT\ IN}, \\
\theta&\quad\text{sonst}.
\end{cases}
\end{math}

\subsection{Algorithmus \textbf{NEST-JA2}}
1. temporäre Relation = Projektion der äußeren Relation(en) auf die Join-Spalten und Restriktion durch \emph{simple} Prädikate, die in der äußeren WHERE-Klausel enthalten sind\\
2. temporäre Relation = Join aus 1. temporärer und innerer/en Relationen, falls Aggregationsfunktion = COUNT, dann müssen die simplen Prädikate auf die innere Relation vor dem Join angewandt werden. Ist die Aggregationsfunktion COUNT(*), dann muss COUNT über die/eine Join-Spalte ausgeführt werden. Das Join-Prädikat muss den selben Operator enthalten, wie die ursprüngliche geschachtelte Abfrage. Der Join-Operator in der ursprünglichen Abfrage muss in \emph{=} geändert werden. In der SELECT-Klausel muss die Join-Spalte der äußeren Relation anstelle der Inneren Relation verwendet werden\\

\begin{lstlisting}
select $A_1,\dots,A_n$
from $R_1,\dots,R_m$
where $P_1 (R_1 ),\dots,P_k (R_1 )$,
	$P_1 ,\ldots,P_l,$,
	$R_i.X \operatorname{\theta}\ ($
		select $\operatorname{AGGR}(T_j.A)$
		from $T_1 ,\dots,T_s$			
		where $Q_1 ,\dots,Q_r$,
			pred$[R_1.Y \operatorname{op} T_1.Z]$
	$)$
\end{lstlisting}

Die Projektion der äußeren Relation

\begin{lstlisting}
TEMP1 = (
	select distinct $R_1.Y$
	from $R_1$
	where	$P_1(R_1),\dots,P_k(R_1)$
	)
\end{lstlisting}

\begin{lstlisting}
TEMP2 = (
	select $T_j.A,T_1.Z$
	from $T_1,\dots,T_s$
	where $Q_1,\dots,Q_r$
	)
\end{lstlisting}

\begin{lstlisting}
TEMP3 = (
	select $T_1.Y,\operatorname{AGGR}(T_j.A)$ as AggrResult
  from TEMP1, TEMP2
  where pred$[R_1.Y \operatorname{op} T_1.Z]$
  group by
  	$T_1.Y$
  $)$
\end{lstlisting}

\begin{lstlisting}
TEMP3 = (
	select $T_1.Y,\operatorname{AGGR}(T_j.A)$ as AggrResult
  from TEMP1 outer join TEMP2
    on pred$[R_1.Y \operatorname{op} T_1.Z]$
  group by
  	$T_1.Y$
  $)$
\end{lstlisting}

\begin{lstlisting}
select $A_1,\dots,A_n$
from $R_1,\dots,R_m$,TEMP3
where $P_1,\dots,P_l,$
	$R_i.X \operatorname{\theta}$ TEMP3.AggrResult, 
	$R_1.Y=$Temp3.Z
\end{lstlisting}

\begin{math}\theta \in\{=,\not=,>,\geq,<,\leq\}\end{math}

allgemeiner Algorithmus zur Entschachtelung mit temporären Tabellen, auf der Basis von Join- und Outerjoin-Operatoren und temporären Tabellen,


%
% EOF
%
%