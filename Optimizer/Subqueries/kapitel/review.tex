%
% Review
%
%

\chapter{Review}
\section{Überblick}
\subsection{Beschreibung Secondo}
\begin{itemize}
	\item Erweiterbares Datenbanksystem
	\item Second-Order-Signatures
	\item Kernel/Algebren
	\item Optimierer
	\item GUI
\end{itemize}
\subsection{SQL}

\begin{itemize}
	\item Datenbanksprache
	\subitem Datendefinition (DDL)
	\subitem Datenmanipulation (DML)
	\subitem Rechtevergabe (DCL)
	\item Abfrageblock bestehend aus 
	\subitem SELECT-Klausel
	\subitem FROM-Klausel
	\subitem WHERE-Klausel
	\subitem GROUP BY\dots HAVING-Klausel
	\subitem ORDER BY-Klausel
	\item geschachtelte Abfragen
	\subitem in der SELECT-Klausel
	\subitem in der FROM-Klausel
	\subitem in der WHERE Klausel
	\subitem in der GROUP BY\dots HAVING-Klausel (nicht implementiert)
\end{itemize}
\begin{itemize}
	\item SQL-Standard unterscheidet in
	\subitem \enquote{scalar subqueries} (Ergebnis der Abfrage ist ein einzelner Wert)
	\subitem \enquote{row subqueries} (Ergebnis der Abfrage ist eine Liste/Menge von Werten)
	\subitem \enquote{table subqueries} (Ergebnis der Abfrage ist eine Relation)
	\item nach Korrelation
	\subitem nicht-korreliert (trivial, Ergebnis ist Konstante/Liste von Konstanten)
	\subitem korrelierte geschachtelte Abfrage
	\subsubitem ohne Aggregation
	\subsubitem mit Aggregation
	\item Ort des Auftretens
	\subitem \textbf{SELECT-Klausel}
	\subitem \textbf{FROM-Klausel}
	\subitem \textbf{WHERE-Klausel}
	\subitem (GROUP BY\dots HAVING-Klausel)
\end{itemize}

\subsection{TPC-D Benchmark}

\section{Ausführunsstrategien}
\subsection{Geschachtelte Iteration}
\subsection{Entschachtelung}
\begin{itemize}
	\item G-Aggregation
	\item G-Join
	\item G-Restriction
	\item G-Outerjoin
	\item Apply
	\item SegmentApply
	\item NULL-rejecting Outerjoin
\end{itemize}

\cite{375748,1247598,ISO:1992:IITa} 
Die Auswertung von geschachtelten Abfragen wird im SQL-Standard \cite{ISO:1992:IITa} definiert. Hierbei wird der innere Abfrageblock für jedes Tupel des äußeren Abfrageblocks ausgewertet. Enthält die Unterabfrage korrelierte Join-Prädikate, so werden die entsprechenden Werte aus dem Tupel des äußeren Abfrageblocks als Konstanten in die Prädikate der Subquery übernommen.
\cite{319745, 38723} 
Klassifikation von Prädikaten in 
Simple(Vergleich mit Konstante(n)), 
Nested, 
Join und 
Divisionsprädikat,\\
Einschränkung bei Join-Prädikaten auf =-Operator, \\
nur eine Spalte in der Select-Klausel erlaubt in Subquery, \\
keine GROUP BY\dots HAVING-Klausel in Subquery \cite{671658}, \\
Innerer und und äußerer Abfrageblock, \\
Klassifkation in 
N =(kein Join-Prädikat, dass auf Relationen im äußeren Abfrageblock verweist, keine Aggregationsfunktion in  Select-Klausel, ergibt eine Liste von Konstanten), 
A =(kein Join-Prädikat, dass auf Relationen im äußeren Abfrageblock verweist, Aggregationsfunktion in Select-Klausel, kann vollkommen unabhängig vom äußeren Abfrageblock ausgewertet werden, Ergebnis ist immer eine Konstante, 
J =(hat Join-Prädikat das die/eine Relation aus dem äußeren Abfrageblock referenziert, keine Aggregationsfunktion in Select-Klausel), 
JA =(hat Join-Prädikat mit Verweis auf Relation im äußeren Abfrageblock, Aggregationsfunktion), 
D =(ein Divisions-Prädikat, dass in einer der beiden Abfrageblöcke ein Join-Prädikat mit Verweis auf eine Relation im äußeren Abfrageblock, drückt die relationale Divisionsoperation aus), \\
\emph{nested-iteration method}, vollständige Auswertung des inneren Abfrageblocks für jedes Tupel des äußeren Blocks

\section{Klassifikation geschachtelter Abfragen}
\subsection{Typ A}
geschachtelte Abfrage mit Aggregationsfunktion, ohne Prädikate die Attribute aus den äußeren Relationen verwenden, kann unabhängig vom äußeren Abfrageblock ausgewertet werden, hat einen Wert als Ergebnis, nicht Liste wg. Aggregationsfunktion. Beispiel: Den Ort mit der höchsten Postleitzahl aus der Relation PLZ
\begin{lstlisting}
select ort 
from plz
where
	plz = (select max(p:plz) from plz as p)
\end{lstlisting}
\subsection{Typ N}
Abfrage ohne Aggregationsfunktion, ohne Prädikate die Attribute aus der äußeren Relationen beinhalten. Kann unabhängig vom äußeren Abfrageblock ausgewertet werden, hat eine Liste von Werten als Ergebnis. Beispiel: Alle Städte mit einer Postleitzahl > 5000
\begin{lstlisting}
select sname 
from staedte
where sname in (select ort from plz where plz > 5000)
\end{lstlisting}
\subsection{Typ J}
Abfrage mit mindestens einem Verweis auf Attribute einer äußeren Relation, keine Aggregationsfunktion. Beispiel: Finde alle Städte, deren Bevölkerung größer als die Postleitzahl ist
\begin{lstlisting}
select sname
from staedte
where sname in (select ort from plz where plz < bev)
\end{lstlisting}
\subsection{Typ JA}
korrelierte Abfrage mit Aggregationsfunktion. Beispiel: Alle Orte mit ihrer maximalen Postleitzahl
\begin{lstlisting}
select ort 
from plz
where plz = (select max(p:plz) from plz as p where ort = p:ort)
\end{lstlisting}

%
% EOF
%
%