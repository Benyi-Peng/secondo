%
% Review
%
%

\chapter{Review}
\section{Überblick}
Ein Datenbanksystem ist eine Menge zusammenhängender Dateien und Programmen, die es einem Benutzer erlauben auf diese Dateien zuzugreifen und diese zu ändern. Eine Hauptaufgabe eines Datenbanksystems ist es, dem Benutzer eine abstrakte Sicht auf die Daten zu ermöglichen. Die physikalische Ablage und der eigentliche Zugriff auf die Daten werden dabei vor dem Benutzer verborgen. Dabei können drei Abstraktionsebenen unterschieden werden. Die physische Ebene beschreibt, wie die Daten physikalisch abgelegt werden. Mit Hilfe von systemnahen komplexen Datenstrukturen wird die physische Ablage der Daten beschrieben. 

Die logische Ebene umfasst die Beschreibung der Art der Daten und der Beziehungen zwischen den Daten. In ihr wird die gesamte Datenbank auf der Basis von vergleichsweise einfachen Strukturen beschrieben. Bei der Realisierung der Strukturen auf der logischen Ebene kann auf die Strukturen der physischen Ebene zurückgegriffen werden. Für einen Benutzer der logischen Ebene, z.B. einem Datenbankadministrator muss dies jedoch nicht sichtbar sein.

Auf der höchsten Abstraktionsebene, der Sichtenebene wird nur ein Teil der Datenbank beschrieben. Obwohl die logische Ebene mit einfacheren Strukturen arbeitet, bleibt eine gewisse Komplexität wegen der Unterschiedlichkeit der in einer großen Datenbank gespeicherten Informationen. Viele Benutzer eines Datenbanksystems benötigen nicht alle Informationen; stattdessen brauchen sie nur einen Teil der Datenbank. Die Sichtenebene dient der Vereinfachung beim Zugriff auf das System. Es können beliebig viele Sichten auf eine Datenbank existieren.

Jedem Datenbanksystem liegt ein Datenmodell zugrunde. Das Datenmodell beschreibt die konzeptionellen Einheiten und Werkzeuge um Daten, Beziehungen zwischen den Daten, die Semantik der Daten und Konsistenzeinschränkungen zu beschreiben. Verbreitete Datenmodelle für Datenbanken sind das relationale und das objektorientierte Datenbankmodell. 
\subsection{Beschreibung SECONDO}
\textsc{Secondo} ist ein modular aufgebautes, erweiterbares Datenbanksystem. Über den Formalismus der Signaturen zweiter Ordnung (\textbf{SECOND} \textbf{O}rder Signatures) lassen sich die Datentypen und Operationen auf den Datentypen beschreiben. Signaturen zweiter Ordnung sind zwei gekoppelte Signaturen. Die Sorten der ersten Signatur werden \enquote{Kinds} genannt, die Operationen Typ-Konstruktoren. Die im System verfügbaren Datentypen sind genau die Ausdrücke dieser Signatur. Die zweite Signatur beschreibt Operationen auf diesen Datentypen. Über die Implementierung von Algebramodulen lässt sich \textsc{Secondo} um beliebige Datentypen und Operationen auf diesen Datentypen erweitern. 

\textsc{Secondo} besteht aus den drei Komponenten Kernel, Optimierer und grafischer Benutzeroberfläche (GUI). Diese drei Komponenten können getrennt aber auch im Zusammenspiel genutzt werden. Der Kernel bietet die Möglichkeit Ausdrücke in der \textsc{Secondo}-eigenen Syntax auszuführen. Mit dem Optimierer können SQL-ähnliche Ausdrücke in ausführbare Pläne übersetzt werden.
\begin{itemize}
	\item Erweiterbares Datenbanksystem
	\item Second-Order-Signatures
	\item Kernel/Algebren
	\item Optimierer
	\item GUI
	\item Client/Server Betrieb
\end{itemize}
\subsection{SQL}

\begin{itemize}
	\item Datenbanksprache
	\subitem Datendefinition (DDL)
	\subitem Datenmanipulation (DML)
	\subitem Rechtevergabe (DCL)
	\item Ein typischer Abfrageblock hat die Form
	\begin{lstlisting}
	select §$A_1,A_2,\cdots,A_n$§
	from §$r_1,r_2,\cdots,r_m$§
	where P
	\end{lstlisting}
	\subitem Die SELECT-Klausel entspricht der Projektions-Operation der relationalen Algebra. In ihr werden alle Attribute der Ergebnisrelation angegeben. Um alle Attribute der beteiligten Relationen zu erhalten gibt es die spezielle Notation \enquote{*}.
	\subitem Die FROM-Klausel entspricht dem kartesischen Produkt in der relationalen Algebra. Hier werden alle in der Abfrage verwendeten Relationen aufgeführt.
	\subitem Die WHERE-Klausel entspricht der Selektions-Operation der relationalen Algebra. Das Prädikat P ist ein boolescher Ausdruck über den Attributen der in der FROM-Klausel aufgelisteten Relationen. Ist der Ausdruck die Konjunktion mehrerer Terme, so spricht man auch bei den einzelnden Termen von einem Prädikat der Abfrage.
	\subitem GROUP BY\dots HAVING-Klausel Die Eingabemenge der Aggregationsfunktion wird in \enquote{Gruppen} mit gleichen Attributwerten in den angegebenen Attributen partitioniert; die Aggregationsfunktion wird dann jeweils separat für jede Gruppe berechnet. Die optionale HAVING-Klausel erlaubt die Selektions-Operation auf den Ergebnissen der Aggregationsfunktion(en).
	\subitem In der ORDER BY-Klausel werden die Ergebnis Attribute angegeben, nach welchen das Ergebnis sortiert werden soll. Mit dem Zusatz ASC bzw. DESC hinter dem Attributnamen kann auf- und absteigende Sortierung gewählt werden.
	\item geschachtelte Abfragen
	\subitem in der SELECT-Klausel 
	\subitem in der FROM-Klausel 
	\subitem in der WHERE Klausel
	\subitem in der GROUP BY\dots HAVING-Klausel (nicht implementiert)
\end{itemize}
\begin{itemize}
	\item SQL-Standard unterscheidet in
	\subitem \enquote{scalar subqueries} (Ergebnis der Abfrage ist ein einzelner Wert)
	\subitem \enquote{row subqueries} (Ergebnis der Abfrage ist eine Liste/Menge von Werten)
	\subitem \enquote{table subqueries} (Ergebnis der Abfrage ist eine Relation)
	\item nach Korrelation
	\subitem nicht-korreliert (trivial, Ergebnis ist Konstante/Liste von Konstanten)
	\subitem korrelierte geschachtelte Abfrage
	\subsubitem ohne Aggregation
	\subsubitem mit Aggregation
	\item Ort des Auftretens
	\subitem \textbf{SELECT-Klausel}
	\subitem \textbf{FROM-Klausel}
	\subitem \textbf{WHERE-Klausel}
	\subitem \textbf{(GROUP BY\dots HAVING-Klausel)}
\end{itemize}

\subsection{TPC-D Benchmark}
TPC = Transaction Processing Performance Council. Stellt Benchmarks zum Vergleich von OLTP Systemen auf. Je nach Anwendungsgebiet werden verschiedene Metriken zum Vergleich von real verfügbaren Systemen bereitgestellt. Der in dieser Arbeit für den Vergleich herangezogene Benchmark TPC-D ist ein Entscheidungshilfe-Benchmark. In dem Benchmark sind 22 Abfragen zusammengefasst, die Antworten auf betriebswirtschaftliche Fragestellungen geben. Insgesamt 10 dieser Abfragen haben geschachtelte Abfrageblöcke und eignen sich daher als Anschauungsobjekt für die Optimierung geschachtelter Anfragen. In Kapitel \ref{chp:Leistungsbewertung} findet sich eine Gegenüberstellung der geschachtelten und der optimierten Ausführung dieser Abfragen.

\section{Ausführunsstrategien}
\subsection{Geschachtelte Iteration}
\cite{375748,1247598,ISO:1992:IITa} 
Die Semantik der Auswertung von geschachtelten Abfragen wird im SQL-Standard \cite{ISO:1992:IITa} definiert. Hierbei wird der innere Abfrageblock für jedes Tupel des äußeren Abfrageblocks ausgewertet. Enthält die Unterabfrage korrelierte Prädikate, d.h. Prädikate, die sich auf Attribute der Relationen des äußeren Abfrageblocks beziehen, so werden die entsprechenden Werte aus dem Tupel des äußeren Abfrageblocks als Konstanten in die Prädikate der Subquery übernommen.
\cite{319745, 38723} 
\subsection{Entschachtelung}
In \cite{319745} wurde erstmals die Möglichkeit vorgestellt, eine geschachtelte Abfrage durch Transformation in eine semantisch äquivalente, nicht geschachtelte Abfrage zu optimieren. Die dort vorgestellten Algorithmen benötigen nur die erweiterten Standard-Operationen der Relationen Algebra. Ziel der Entschachtelungen ist die Überführung geschachtelter Abfrageblöcke in eine semantisch äquivalente Form. Zwei Abfrageblöcke sind semantisch äquivalent, wenn für jede beliebige Interpretation (Belegung mit Werten) der Variablen (in diesem Fall Relationen, Attribute und Konstanten), das Ergebnis der Abfrage übereinstimmt. Grundsätzlich haben die Entschachtelungsansätze gemeinsam, dass Äquivalenzen aufgestellt werden, die die Transformation einer Abfrage in eine strukturell anders aufgebaute Abfrage erlauben. \cite{375748} wird die SQL-Abfrage erst einmal in eine algebraische Darstellung übersetzt. Um die Transformationen leisten zu können, wird die relationale Algebra um einige Operatoren erweitert, mit deren Hilfe sich der Term, der durch die Übersetzung entsteht, in eine entschachtelte Variante überführen lässt. 
\begin{itemize}
	\item G-Aggregation 
	\item G-Join
	\item G-Restriction
	\item G-Outerjoin
	\item Apply
	\item SegmentApply
	\item NULL-rejecting Outerjoin
\end{itemize}

SQL Prädikate lassen sich in verschiedene Klassen einteilen. Abhängig von der Semantik der Operation, kann man in \emph{einfache} Prädikate, \emph{Join}-Prädikate, \emph{Divisions}-Prädikate und \emph{geschachtelte} Prädikate unterscheiden. Einfache Prädikate sind solche Prädikate die zu ihrer Berechnung nur auf Konstanten und Attribute einer Relation zugreifen. Ein Beispiel für ein solches Prädikat ist \textbf{$C_m = 10$}. Join-Prädikate benötigen zu ihrer Berechnung Attribute aus zwei oder mehr Relationen. Sie \emph{verbinden} (to join -- engl. verbinden) die verwendeten Relationen. 
\begin{lstlisting} 
select * from §$R_i, R_j$§ where §$R_i.C_n=R_j.C_m$§ 
\end{lstlisting} 
Divisions-Prädikate berechnen die relationale Division über zwei Relationen. Geschachtelte Prädikate enthalten eine Unterabfrage in ihrem Ausdruck.
Klassifikation von Prädikaten in 
Simple(Vergleich mit Konstante(n)), 
Nested, 
Join und 
Divisionsprädikat,\\
Einschränkung bei Join-Prädikaten auf =-Operator, \\
nur eine Spalte in der Select-Klausel erlaubt in Subquery, \\
keine GROUP BY\dots HAVING-Klausel in Subquery \cite{671658}, \\
Innerer und und äußerer Abfrageblock, \\
Klassifkation in 
N =(kein Join-Prädikat, dass auf Relationen im äußeren Abfrageblock verweist, keine Aggregationsfunktion in  Select-Klausel, ergibt eine Liste von Konstanten), 
A =(kein Join-Prädikat, dass auf Relationen im äußeren Abfrageblock verweist, Aggregationsfunktion in Select-Klausel, kann vollkommen unabhängig vom äußeren Abfrageblock ausgewertet werden, Ergebnis ist immer eine Konstante, 
J =(hat Join-Prädikat das die/eine Relation aus dem äußeren Abfrageblock referenziert, keine Aggregationsfunktion in Select-Klausel), 
JA =(hat Join-Prädikat mit Verweis auf Relation im äußeren Abfrageblock, Aggregationsfunktion), 
D =(ein Divisions-Prädikat, dass in einer der beiden Abfrageblöcke ein Join-Prädikat mit Verweis auf eine Relation im äußeren Abfrageblock, drückt die relationale Divisionsoperation aus), \\
\emph{nested-iteration method}, vollständige Auswertung des inneren Abfrageblocks für jedes Tupel des äußeren Blocks

\section{Klassifikation geschachtelter Abfragen}
Grundsätzlich lassen sich geschachtelte Abfragen in unabhängige Abfragen und korrelierte Abfragen unterscheiden. Unabhängige Abfragen lassen sich unabhängig vom äußeren Abfrageblock auswerten. Ist eine unabhängige Auswertung nicht möglich spricht man korrelierten Abfragen, da das Ergebnis der inneren Abfrage vom Wert des Tupels des äußeren Abfrageblocks abhängt.
\subsection{Typ A}
geschachtelte Abfrage mit Aggregationsfunktion, ohne Prädikate die Attribute aus den äußeren Relationen verwenden, kann unabhängig vom äußeren Abfrageblock ausgewertet werden, hat einen Wert als Ergebnis, nicht Liste wg. Aggregationsfunktion. Beispiel: Den Ort mit der höchsten Postleitzahl aus der Relation PLZ
\begin{lstlisting}
select ort 
from plz
where
	plz = (select max(p:plz) from plz as p)
\end{lstlisting}
\subsection{Typ N}
Eine geschachtelte Abfrage ist vom Typ N, genau dann wenn die innere Abfrage keine  Aggregationsfunktion enthält und alle Prädikate entweder simple Prädikate oder Join-Prädikate über Attributen der Relationen des inneren Abfrageblocks sind. Prädikate vom Typ N können unabhängig vom äußeren Abfrageblock ausgewertet werden; ihr Ergebnis ist eine Liste von Konstanten. Beispiel: Alle Städte mit einer Postleitzahl > 5000
\begin{lstlisting}
select sname 
from staedte
where sname in (select ort from plz where plz > 5000)
\end{lstlisting}
\subsection{Typ J}
Eine Abfrage hat den Typ J, wenn mindestens ein Attribut der äußeren Relation im Prädikat verwendet wird, aber keine Aggregationsfunktion in der SELECT-Klausel vorkommt. Beispiel: Finde alle Städte, deren Bevölkerung größer als die Postleitzahl ist
\begin{lstlisting}
select sname
from staedte
where sname in (select ort from plz where plz < bev)
\end{lstlisting}
\subsection{Typ JA}
Korrelierte Abfragen mit Aggregationsfunktion in der SELECT-Klausel heißen vom Typ JA. Beispiel: Alle Orte mit ihrer maximalen Postleitzahl
\begin{lstlisting}
select ort 
from plz
where plz = (select max(p:plz) from plz as p where ort = p:ort)
\end{lstlisting}

%
% EOF
%
%