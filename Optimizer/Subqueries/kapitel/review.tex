%
% Review
%
%

\chapter{Review}
\section{Überblick}
\subsection{Beschreibung SECONDO}
\begin{itemize}
	\item Erweiterbares Datenbanksystem
	\item Second-Order-Signatures
	\item Kernel/Algebren
	\item Optimierer
	\item GUI
\end{itemize}
\subsection{SQL}

\begin{itemize}
	\item Datenbanksprache
	\subitem Datendefinition (DDL)
	\subitem Datenmanipulation (DML)
	\subitem Rechtevergabe (DCL)
	\item Ein typischer Abfrageblock hat die Form
	\begin{lstlisting}
	select §$A_1,A_2,\cdots,A_n$§
	from §$r_1,r_2,\cdots,r_m$§
	where P
	\end{lstlisting}
	\subitem Die SELECT-Klausel entspricht der Projektions-Operation der relationalen Algebra. In ihr werden alle Attribute der Ergebnisrelation angegeben. Um alle Attribute der beteiligten Relationen zu erhalten gibt es die spezielle Notation \enquote{*}.
	\subitem Die FROM-Klausel entspricht dem kartesischen Produkt in der relationalen Algebra. Hier werden alle in der Abfrage verwendeten Relationen aufgeführt.
	\subitem Die WHERE-Klausel entspricht der Selektions-Operation der relationalen Algebra. Das Prädikat P ist ein boolescher Ausdruck über den Attributen der in der FROM-Klausel aufgelisteten Relationen.
	\subitem GROUP BY\dots HAVING-Klausel Die Eingabemenge der Aggregationsfunktion wird in \enquote{Gruppen} mit gleichen Attributwerten in den angegebenen Attributen partitioniert; die Aggregationsfunktion wird dann jeweils separat für jede Gruppe berechnet. Die optionale HAVING-Klausel erlaubt die Selektions-Operation auf den Ergebnissen der Aggregationsfunktion(en).
	\subitem In der ORDER BY-Klausel werden die Ergebnis Attribute angegeben, nach welchen das Ergebnis sortiert werden soll. Mit dem Zusatz ASC bzw. DESC hinter dem Attributnamen kann auf- und absteigende Sortierung gewählt werden.
	\item geschachtelte Abfragen
	\subitem in der SELECT-Klausel
	\subitem in der FROM-Klausel
	\subitem in der WHERE Klausel
	\subitem in der GROUP BY\dots HAVING-Klausel (nicht implementiert)
\end{itemize}
\begin{itemize}
	\item SQL-Standard unterscheidet in
	\subitem \enquote{scalar subqueries} (Ergebnis der Abfrage ist ein einzelner Wert)
	\subitem \enquote{row subqueries} (Ergebnis der Abfrage ist eine Liste/Menge von Werten)
	\subitem \enquote{table subqueries} (Ergebnis der Abfrage ist eine Relation)
	\item nach Korrelation
	\subitem nicht-korreliert (trivial, Ergebnis ist Konstante/Liste von Konstanten)
	\subitem korrelierte geschachtelte Abfrage
	\subsubitem ohne Aggregation
	\subsubitem mit Aggregation
	\item Ort des Auftretens
	\subitem \textbf{SELECT-Klausel}
	\subitem \textbf{FROM-Klausel}
	\subitem \textbf{WHERE-Klausel}
	\subitem \textbf{(GROUP BY\dots HAVING-Klausel)}
\end{itemize}

\subsection{TPC-D Benchmark}
TPC = Transaction Processing Performance Council. Stellt Benchmarks zum Vergleich von OLTP Systemen auf. 

\section{Ausführunsstrategien}
\subsection{Geschachtelte Iteration}
\subsection{Entschachtelung}
\begin{itemize}
	\item G-Aggregation
	\item G-Join
	\item G-Restriction
	\item G-Outerjoin
	\item Apply
	\item SegmentApply
	\item NULL-rejecting Outerjoin
\end{itemize}

\cite{375748,1247598,ISO:1992:IITa} 
Die Auswertung von geschachtelten Abfragen wird im SQL-Standard \cite{ISO:1992:IITa} definiert. Hierbei wird der innere Abfrageblock für jedes Tupel des äußeren Abfrageblocks ausgewertet. Enthält die Unterabfrage korrelierte Join-Prädikate, so werden die entsprechenden Werte aus dem Tupel des äußeren Abfrageblocks als Konstanten in die Prädikate der Subquery übernommen.
\cite{319745, 38723} 

SQL Prädikate lassen sich in verschiedene Klassen einteilen. Abhängig von der Semantik der Operation, kann man in \emph{einfache} Prädikate, \emph{Join}-Prädikate, \emph{Divisions}-Prädikate und \emph{geschachtelte} Prädikate unterscheiden. Einfache Prädikate sind solche Prädikate die zu ihrer Berechnung nur auf Konstanten und Attribute einer Relation zugreifen. Ein Beispiel für ein solches Prädikat ist \textbf{$C_m = 10$}. Join-Prädikate benötigen zu ihrer Berechnung Attribute aus zwei oder mehr Relationen. Sie \emph{verbinden} (to join -- engl. verbinden) die verwendeten Relationen. 
\begin{lstlisting} 
select * from §$R_i, R_j$§ where §$R_i.C_n=R_j.C_m$§ 
\end{lstlisting} 
Divisions-Prädikate berechnen die relationale Division über zwei Relationen. Geschachtelte Prädikate enthalten eine Unterabfrage in ihrem Ausdruck.
Klassifikation von Prädikaten in 
Simple(Vergleich mit Konstante(n)), 
Nested, 
Join und 
Divisionsprädikat,\\
Einschränkung bei Join-Prädikaten auf =-Operator, \\
nur eine Spalte in der Select-Klausel erlaubt in Subquery, \\
keine GROUP BY\dots HAVING-Klausel in Subquery \cite{671658}, \\
Innerer und und äußerer Abfrageblock, \\
Klassifkation in 
N =(kein Join-Prädikat, dass auf Relationen im äußeren Abfrageblock verweist, keine Aggregationsfunktion in  Select-Klausel, ergibt eine Liste von Konstanten), 
A =(kein Join-Prädikat, dass auf Relationen im äußeren Abfrageblock verweist, Aggregationsfunktion in Select-Klausel, kann vollkommen unabhängig vom äußeren Abfrageblock ausgewertet werden, Ergebnis ist immer eine Konstante, 
J =(hat Join-Prädikat das die/eine Relation aus dem äußeren Abfrageblock referenziert, keine Aggregationsfunktion in Select-Klausel), 
JA =(hat Join-Prädikat mit Verweis auf Relation im äußeren Abfrageblock, Aggregationsfunktion), 
D =(ein Divisions-Prädikat, dass in einer der beiden Abfrageblöcke ein Join-Prädikat mit Verweis auf eine Relation im äußeren Abfrageblock, drückt die relationale Divisionsoperation aus), \\
\emph{nested-iteration method}, vollständige Auswertung des inneren Abfrageblocks für jedes Tupel des äußeren Blocks

\section{Klassifikation geschachtelter Abfragen}
\subsection{Typ A}
geschachtelte Abfrage mit Aggregationsfunktion, ohne Prädikate die Attribute aus den äußeren Relationen verwenden, kann unabhängig vom äußeren Abfrageblock ausgewertet werden, hat einen Wert als Ergebnis, nicht Liste wg. Aggregationsfunktion. Beispiel: Den Ort mit der höchsten Postleitzahl aus der Relation PLZ
\begin{lstlisting}
select ort 
from plz
where
	plz = (select max(p:plz) from plz as p)
\end{lstlisting}
\subsection{Typ N}
Ein geschachteltes Prädikat ist vom Typ N, genau dann wenn die innere Abfrage keine  Aggregationsfunktion enthält und alle Prädikate entweder simple Prädikate oder Join-Prädikate über Attributen der Relationen des inneren Abfrageblocks sind. Prädikate vom Typ N können unabhängig vom äußeren Abfrageblock ausgewertet werden; ihr Ergebnis ist eine Liste von Konstanten. Beispiel: Alle Städte mit einer Postleitzahl > 5000
\begin{lstlisting}
select sname 
from staedte
where sname in (select ort from plz where plz > 5000)
\end{lstlisting}
\subsection{Typ J}
Abfrage mit mindestens einem Verweis auf Attribute einer äußeren Relation, keine Aggregationsfunktion. Beispiel: Finde alle Städte, deren Bevölkerung größer als die Postleitzahl ist
\begin{lstlisting}
select sname
from staedte
where sname in (select ort from plz where plz < bev)
\end{lstlisting}
\subsection{Typ JA}
korrelierte Abfrage mit Aggregationsfunktion. Beispiel: Alle Orte mit ihrer maximalen Postleitzahl
\begin{lstlisting}
select ort 
from plz
where plz = (select max(p:plz) from plz as p where ort = p:ort)
\end{lstlisting}

%
% EOF
%
%