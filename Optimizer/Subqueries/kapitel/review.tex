%
% Review
%
%

\chapter{Review}\label{chp:Review}
\section{Überblick}\label{sct:Überblick}
Ein Datenbanksystem ist eine Menge zusammenhängender Dateien und Programmen, die es einem Benutzer erlauben auf diese Dateien zuzugreifen und diese zu ändern. Eine Hauptaufgabe eines Datenbanksystems ist es, dem Benutzer eine abstrakte Sicht auf die Daten zu ermöglichen. Die physikalische Ablage und der eigentliche Zugriff auf die Daten werden dabei vor dem Benutzer verborgen. Dabei können drei Abstraktionsebenen unterschieden werden. 

Die interne Ebene beschreibt, wie die Daten physikalisch abgelegt werden. Mit Hilfe von systemnahen komplexen Datenstrukturen wird die physische Ablage der Daten beschrieben. 

Die konzeptuelle Ebene umfasst die Beschreibung der Art der Daten und der Beziehungen zwischen den Daten. In ihr wird die gesamte Datenbank auf der Basis von vergleichsweise einfachen Strukturen beschrieben. Bei der Realisierung der Strukturen auf der konzeptuellen Ebene kann auf die Strukturen der physischen Ebene zurückgegriffen werden. Für einen Benutzer der logischen Ebene, z.B. einem Datenbankadministrator muss dies jedoch nicht sichtbar sein.

Auf der höchsten Abstraktionsebene, der externen Ebene wird nur ein Teil der Datenbank beschrieben. Obwohl die konzeptuelle Ebene mit einfacheren Strukturen arbeitet, bleibt eine gewisse Komplexität wegen der Unterschiedlichkeit der in einer großen Datenbank gespeicherten Informationen. Viele Benutzer eines Datenbanksystems benötigen nicht alle Informationen; stattdessen brauchen sie nur einen Teil der Datenbank. Die externe Ebene dient der Vereinfachung beim Zugriff auf das System. Es können beliebig viele Sichten auf eine Datenbank existieren.

Jedem Datenbanksystem liegt ein Datenmodell zugrunde. Das Datenmodell beschreibt die konzeptionellen Einheiten und Werkzeuge um Daten, Beziehungen zwischen den Daten, die Semantik der Daten und Konsistenzeinschränkungen zu beschreiben. Verbreitete Datenmodelle für Datenbanken sind das relationale und das objektorientierte Datenbankmodell. 

Die Grundelemente des relationalen Datenmodells sind Attribute, Tupel und Relationen.  Eine Relation wird durch ihr Relationenschema eindeutig beschrieben. Ein Relationenschema ist eine Menge von Attributen. Durch einen zugeordneten Datentyp und einen Namen bestimmt ein Attribut die möglichen Werte, die die Ausprägungen des Attributs annehmen können. Ein Tupel ist eine konkrete Ausprägung, d.h. eine Zeile einer Relation (Tabelle).

\subsection{Beschreibung SECONDO}
\textsc{Secondo} ist ein modular aufgebautes, erweiterbares Datenbanksystem. 

Über den Formalismus der Signaturen zweiter Ordnung (\textbf{SECOND} \textbf{O}rder Signatures) lassen sich die Datentypen und Operationen auf den Datentypen beschreiben. Signaturen zweiter Ordnung sind zwei gekoppelte Signaturen. Die Sorten der ersten Signatur werden \enquote{Kinds} genannt, die Operationen Typ-Konstruktoren. Die im System verfügbaren Datentypen sind genau die Ausdrücke dieser Signatur. Die zweite Signatur beschreibt Operationen auf diesen Datentypen. Über die Implementierung von Algebramodulen lässt sich \textsc{Secondo} um beliebige Datentypen und Operationen auf diesen Datentypen erweitern. 

\textsc{Secondo} besteht aus den drei Komponenten Kernel, Optimierer und grafischer Benutzeroberfläche (GUI). Diese drei Komponenten können getrennt aber auch im Zusammenspiel genutzt werden. 

Der Kernel bietet die Möglichkeit Ausdrücke in der \textsc{Secondo}-eigenen Syntax auszuführen. Hierzu gibt es eine Kommandozeilen-Schnittstelle, über die mit dem Kernel kommuniziert werden kann. Zusätzlich kann der Kernel auch im Client/Server-Betriebsmodus gestartet werden. Er bietet dann anderen Komponenten die Möglichkeit, auf den Kernel zuzugreifen. 

Mit dem Optimierer können SQL-ähnliche Ausdrücke in ausführbare Pläne übersetzt werden. Dies kann losgelöst von den anderen Komponenten über die Kommandozeile erfolgen. Zusätzlich gibt es auch beim Optimierer die Möglichkeit, ihn im Client/Server-Modus zu starten. 

Mit der GUI können Abfragen sowohl an den Optimierer als auch an den Kernel gestellt werden. Zusätzlich ist sie in der Lage z.B. raum-zeitliche Datentypen darzustellen. Es wird eine zweidimensionale Projektion der Daten dargestellt, die über die Zeitachse abgespielt werden kann. Hierbei kann die Geschwindigkeit variiert werden. Da die GUI die Möglichkeit bietet, das Ergebnis einer Abfragen in einem eigenen Foramt zu speichern, kann man ihre Darstellungsmöglichkeiten auch ohne Kernel und Optimierer benutzen.

Basis des Optimierers ist ein in \cite{} vorgestellter Optimierungsalgorithmus der auf kürzesten Pfaden in einem predicate order graph (pog) beruht. Ein pog zu einer Liste von n Prädikaten ist ein n-dimensionaler Hyperwürfel mit zwei ausgezeichneten Knoten maximaler Entfernung, die mit 0 bzw. $2^n$ bezeichnet werden. Hierbei stellen die Pfade die Permutationen der Konjunktionsterme des Prädikats dar. Jeder Knoten gibt durch seine Nummer die ausgewerteten Prädikate an. Die ausgewerteten Prädikate werden in Bits kodiert. Beim Knoten mit der Nummer 5 (binär 101) sind also die Prädikate 1 und 3 bereits ausgewertet. Jede Kante steht für einen booleschen Ausdruck. Für jede Übersetzungsmöglichkeit dieses Ausdrucks wird eine \enquote{ausführbare Kante} erzeugt. Durch die Bewertung der Kanten mit Kosten (die sich aus der Selektivität und den Ausführungskosten des Ausdrucks zusammensetzen) entspricht ein bezüglich der Kosten kürzester Pfad einer optimalen Reihenfolge der Prädikatsauswertung.

Die Implementierung des Optimierers ist in Prolog geschrieben. Da die vom Optimierer erkannte SQL-ähnliche Sprache aus gültigen Prolog-Ausdrücken besteht, werden das Parsen und Übersetzen in entsprechende Datenstrukturen von der Prolog-Laufzeitumgebung übernommen. Die Übersetzung der SQL-ähnlichen Ausdrücke in die ausführbare \textsc{Secondo}-Syntax besteht aus den im Folgenden beschriebenen Phasen. In der ersten Phase wird der Ausdruck umgeschrieben. Abhängig von den gewählten Optionen des Optimierers werden z.B. enthaltene Makros ausgewertet, redundante Prädikate entfernt oder der Ausdruck so umstrukturiert, dass an mehreren Stellen verwendete Teilausdrücke nur einmal ausgeführt werden müssen (CSE -- common subexpression elimination). In diese Phase integrieren sich die Ent\-schach\-te\-lungs\-al\-go\-rith\-men, die im Rahmen dieser Arbeit implementiert wurden. Im zweiten Schritt werden die Schema-Daten der an der Abfrage beteiligten Datenbankobjekte (Attribute, Relationen und konstante Objekte) ermittelt und als Prolog-Fakten gespeichert. Sie werden zum Aufbau des predicate order graphs benötigt. Im nächsten Schritt wird der optimale Plan mit dem oben beschriebenen Optimierungsalgorithmus ermittelt. Im letzten Schritt wird aus dem Plan, der immer noch ein gültiger Prolog-Term ist, ein Ausdruck in der ausführbaren Syntax des \textsc{Secondo}-Kernels generiert. Falls vom Benutzer gewünscht, kann die Abfrage direkt aus dem Optimierer heraus an den \textsc{Secondo}-Kernel gestellt werden. Das Ergebnis wird dann ebenfalls im Optimierer ausgegeben.

Die vom Optimierer unterstützte SQL-Syntax ist in Anhang \ref{apd:Secondo SQL} angegeben, inklusive der in dieser Arbeit implementierten Erweiterungen.

\begin{itemize}
	\item Erweiterbares Datenbanksystem
	\item Second-Order-Signatures
	\item Kernel/Algebren
	\item Optimierer
	\item GUI
	\item Client/Server Betrieb
\end{itemize}

\subsection{SQL}

Relationale Datenbanken beruhen auf dem von E.F. Codd vorgeschlagenen Relationenalgebra und dem ebenfalls von Codd vorgestellten Relationenkalkül\cite{DBLP:books/mg/SilberschatzKS01}. Ein grundsätzlicher Vorteil des relationalen Datenbankmodells ist die Möglichkeit, die gewünschten Ergebnisse einer Abfrage auf einem hohen Abstraktionsniveau formulieren zu können. Die Zugriffspfade auf die Daten müssen hier nicht mit angegeben werden. Da die mathematischen Grundlagen der Relationenalgebra und des Relationenkalküls für nicht-technische Benutzer einer Datenbank nicht einfach zu verstehen sind, wurde viel Arbeit in die Entwicklung einer Datenbanksprache gesteckt, die genauso mächtig wie das Relationenkalkül und die Relationenalgebra ist, sich aber leichter erlernen lässt. Eines der interessantesten Merkmale von SQL ist die Möglichkeit Abfrageblöcke beliebig zu schachteln.
SQL ist eine auf dem relationalen Datenbankmodell beruhende Datenbanksprache. Mit ihr können in relationalen Datenbanken die Metadaten der Relationen angelegt und geändert werden. Außerdem erlaubt sie die Manipulation der Daten. Auch die granulare Vergabe von Berechtigungen wurde in SQL standardisiert.
\begin{itemize}
	\item Datenbanksprache
	\subitem Datendefinition (DDL)
	\subitem Datenmanipulation (DML)
	\subitem Rechtevergabe (DCL)
	\item Ein typischer Abfrageblock hat die Form
	\begin{lstlisting}
	select §$A_1,A_2,\cdots,A_n$§
	from §$r_1,r_2,\cdots,r_m$§
	where P
	\end{lstlisting}
Grundsätzlich besteht eine SQL-Abfrage aus den drei Klauseln SELECT, FROM und WHERE. In der SELECT-Klausel werden die Attribute der Ergebnisrelation angegeben. Die FROM-Klausel gibt die Quellrelationen an, aus denen das Ergebnis ermittelt wird. Die optionale WHERE-Klausel gibt schließlich Einschränkungen an, denen die Ergebnistupel genügen müssen.
	\subitem Die SELECT-Klausel entspricht der Projektions-Operation der Relationenalgebra. In ihr werden alle Attribute der Ergebnisrelation angegeben. Um alle Attribute der beteiligten Relationen zu erhalten gibt es die spezielle Notation \enquote{*}.
	\subitem Die FROM-Klausel entspricht dem kartesischen Produkt in der Relationenlgebra. Hier werden alle in der Abfrage verwendeten Relationen aufgeführt.
	\subitem Die WHERE-Klausel entspricht der Selektions-Operation der Relationenalgebra. Das Prädikat P ist ein boolescher Ausdruck über den Attributen der in der FROM-Klausel aufgelisteten Relationen. Ist der Ausdruck die Konjunktion mehrerer Terme, so spricht man auch bei den einzelnen Termen von einem Prädikat der Abfrage.
	\subitem GROUP BY\dots HAVING-Klausel Die Eingabemenge der Aggregationsfunktion wird in \enquote{Gruppen} mit gleichen Attributwerten in den angegebenen Attributen partitioniert; die Aggregationsfunktion wird dann jeweils separat für jede Gruppe berechnet. Die optionale HAVING-Klausel erlaubt die Selektions-Operation auf den Ergebnissen der Aggregationsfunktion(en). Hierzu wird ein Prädikat angegeben, dass auf das Ergebnis der Aggregation angewandt wird. Nur Ergebnistupel, für die dieses Prädikat zu \enquote{WAHR} auswertet, werden in die Ergebnisrelation übernommen.
	\subitem In der ORDER BY-Klausel werden die Ergebnis Attribute angegeben, nach welchen das Ergebnis sortiert werden soll. Mit dem Zusatz ASC bzw. DESC hinter dem Attributnamen kann zwischen auf- und absteigender Sortierung für das entsprechende Attribut gewählt werden. Die Reihenfolge der Attribute in der ORDER BY-Klausel gibt die Rangfolge bei der Sortierung an.
	\item geschachtelte Abfragen
	
	\subitem in der SELECT-Klausel. 
	\subitem in der FROM-Klausel 
	\subitem in der WHERE Klausel
	\subitem in der GROUP BY\dots HAVING-Klausel (nicht implementiert) Die GROUP BY\dots HAVING-Klausel erlaubt die Angabe eines Prädikats, das auf das Ergebnis einer Aggregation angewandt wird.
\end{itemize}
\begin{itemize}
	\item SQL-Standard unterscheidet in
	\subitem \enquote{scalar subqueries} (Ergebnis der Abfrage ist ein einzelner Wert). Diese Form der Unterabfrage darf an jeder Stelle in einem Abfrageblock verwendet werden, an dem auch eine skalare Konstante zulässig wäre.
	\subitem \enquote{row subqueries} (Ergebnis der Abfrage ist eine Liste/Menge von Werten)
	\subitem \enquote{table subqueries} (Ergebnis der Abfrage ist eine Relation) 
	\item nach Korrelation
	\subitem nicht-korreliert (trivial, Ergebnis ist Konstante/Liste von Konstanten)
	\subitem korrelierte geschachtelte Abfrage
	\subsubitem ohne Aggregation
	\subsubitem mit Aggregation
	\item Ort des Auftretens
	\subitem \textbf{SELECT-Klausel} das Ergebnis der Auswertung der geschachtelten Abfrage wird in die Ergebnisrelation aufgenommen. In der SELECT-Klausel sind nur skalare Unterabfragen zulässig. 
	\subitem \textbf{FROM-Klausel} komplexe Abfragen über mehrere Relationen lassen sich oft verständlicher formulieren, wenn in einem ersten Schritt die notwendigen Daten zu einer Relation zusammengefasst werden. Im darauf folgenden Schritt wird dann die eigentliche Abfrage über dieser neuen Relation formuliert. Diese Form der Strukturierung lässt sich durch Unterabfragen in der FROM-Klausel bewerkstelligen. Die Unterabfrage liefert die Zusammenfassung der Daten, auf deren Basis die Abfrage formuliert wird. 
	\subitem \textbf{WHERE-Klausel} geschachtelte Abfragen in der WHERE-Klausel bieten die Möglichkeit, das Ergebnis einer Abfrage in einer Bedingung zu verwenden. Hierzu können die Operatoren \sql{in}, \sql{exists}, \sql{all}, \sql{any} und skalare Vergleichsoperatoren benutzt werden. Die Semantik dieser Operatoren wird im nächsten Absatz kurz skizziert.
	
Der \sql{in}-Operator prüft das Enthaltensein eines Werts in einer Menge. Die Menge kann durch Auflistung oder durch eine Abfrage spezifiziert werden. Ein geschachteltes Prädikat mit dem \sql{in}-Operator ist genau dann wahr, wenn der Wert auf der linken Seite (Attribut oder Zeile) im Ergebnis der Unterabfrage enthalten ist. 
\begin{lstlisting}
§$A_i$§ in (select §$A_j$§ from §$R_n$§ where P)
\end{lstlisting} 

Mit dem \sql{exists}-Operator wird die Ergebnisrelation darauf überprüft, ob sie mindestens ein Ergebnistupel enthält. In nicht-korrelierten Prädikaten ist die Verwendung von \sql{exits} meist nicht relevant, da das Prädikat in diesem Fall zu der Konstant \sql{TRUE} bzw. \sql{FALSE} auswertet. Bei korrelierten Prädikaten lassen sich mit \sql{exists} komplexe Bedingungen prüfen. 
\begin{lstlisting}
exists(select §$A_j$§ from §$R_n$§ where P)
\end{lstlisting}

Die Operatoren \sql{any} und \sql{all} entsprechen den Quantoren \exists und \all der Prädikatenlogik erster Stufe. Das Ergebnis eines Prädikats mit dem \sql{any}-Operator ist genau dann wahr, wenn mindestens ein Tupel der Ergebnisrelation den Vergleich $\theta$ erfüllt. Als Vergleichsoperator sind die skalaren Operatoren $<, <=, =, >, >=$ mit ihrer üblichen Semantik und der Operator <> mit der Bedeutung \enquote{ungleich} zulässig. Um den semantischen Unterschied des Operators \sql{any} zu der Verwendung des Wortes \enquote{any} in der englischen Sprache zu betonen und Missverständnisse zu vermeiden, wurde mit SQL92 der Operator \sql{some} mit identischer Semantik eingeführt.
\begin{lstlisting}
§$A_i$§ §$\theta$§ any(select §$A_j$§ from §$R_n$§ where P)
\end{lstlisting}

Der \sql{all}-Operator wertet zu \sql{TRUE} aus, wenn der Vergleich für alle Ergebnistupel positiv ausfällt. Die zulässigen Vergleichsoperatoren sind die selben wie beim Operator \sql{any}.
\begin{lstlisting}
§$A_i$§ §$\theta$§ all(select §$A_j$§ from §$R_n$§ where P)
\end{lstlisting}


	\subitem \textbf{(GROUP BY\dots HAVING-Klausel)} Auch in den Prädikaten der HAVING-Klausel kann auf Unterabfragen zurückgegriffen werden. Allerdings kann nur auf die Attribute der Ergebnisrelation der zuvorstehenden Abfrage zugegriffen werden. D.h. die Ausdrücke in einem Prädikat beziehen sich auf ein GROUP-Attribut oder ein Aggregationsergebnis.
\begin{lstlisting}
   select §$A_i$§, §$avg(A_j)$§
      from §$R_n$§ as R
      group by §$A_i$§
      having §$avg(A_j)$§ >
         (select §$avg(A_j)$§
            from §$R_n$§
            where §$R.A_i$§ = §$A_i$§)
\end{lstlisting}
\end{itemize}

\subsection{TPC-D Benchmark}
TPC = Transaction Processing Performance Council. Stellt Benchmarks zum Vergleich von Datenbankystemen auf. Je nach Anwendungsgebiet werden verschiedene Metriken zum Vergleich von real verfügbaren Systemen bereitgestellt. Der in dieser Arbeit für den Vergleich herangezogene Benchmark TPC-D ist ein Entscheidungshilfe-Benchmark. In dem Benchmark sind 22 Abfragen zusammengefasst, die Antworten auf betriebswirtschaftliche Fragestellungen geben. Insgesamt 10 dieser Abfragen haben geschachtelte Abfrageblöcke und eignen sich daher als Anschauungsobjekt für die Optimierung geschachtelter Anfragen. In Kapitel \ref{chp:Leistungsbewertung} findet sich eine Gegenüberstellung der geschachtelten und der optimierten Ausführung dieser Abfragen. Ziel des Benchmarks ist der Vergleich von Datenbanksystemen über Metriken, die sowohl die Performance, gemessen über die Antwortzeiten der Abfragen, als auch die Kosten für die verwendete Hardware mit einbezieht ermöglicht. Die Ergebnisse eines solchen Benchmarks können nach einer Überprüfung durch den TPC auf der Website \url{http://www.tpc.org/} veröffentlicht werden.

\section{Ausführunsstrategien}
\subsection{Geschachtelte Iteration}
\cite{375748,1247598,ISO:1992:IITa} 
Die Semantik der Auswertung von geschachtelten Abfragen wird im SQL-Standard \cite{ISO:1992:IITa} definiert. Das Ergebnis erhält man, indem der innere Abfrageblock für jedes Tupel des äußeren Abfrageblocks ausgewertet wird. Enthält die Unterabfrage korrelierte Prädikate, d.h. Prädikate, die sich auf Attribute der Relationen des äußeren Abfrageblocks beziehen, so werden die entsprechenden Werte aus dem Tupel des äußeren Abfrageblocks als Konstanten in die Prädikate der Subquery übernommen. Diese Form der Auswertung ist für große äußere Relationen nicht sehr performant. In \cite{319745, 38723} werden Kostenberechnungen für Beispiele durchgeführt, die eine Verbesserung der notwendigen I/O-Operationen für eine Abfrage um zwei bis drei Größenordnung zeigen.


\subsection{Entschachtelung}
In \cite{319745} wurde erstmals die Möglichkeit vorgestellt, eine geschachtelte Abfrage durch Transformation in eine inhaltlich äquivalente, nicht geschachtelte Abfrage zu optimieren. Die dort vorgestellten Algorithmen benötigen nur die erweiterten Standard-Operationen der Relationenalgebra. Ziel der Entschachtelungen ist die Überführung geschachtelter Abfrageblöcke in eine inhaltlich äquivalente Form. Zwei Abfrageblöcke sind inhaltlich äquivalent, wenn für jede beliebige Interpretation (Belegung mit Werten) der Variablen (in diesem Fall Relationen, Attribute und Konstanten), das Ergebnis der Abfrage übereinstimmt. Grundsätzlich haben die Entschachtelungsansätze gemeinsam, dass Äquivalenzen aufgestellt werden, die die Transformation einer Abfrage in eine strukturell anders aufgebaute Abfrage erlauben. 

In \cite{375748} wird die SQL-Abfrage erst einmal in eine algebraische Darstellung übersetzt. Um die Transformationen leisten zu können, wird die relationale Algebra um einige Operatoren erweitert, mit deren Hilfe sich der Term, der durch die Übersetzung entsteht, in eine entschachtelte Variante überführen lässt. 
\cite{375748} werden die Ansätze zur Entschachtelung korrelierter Unterabfragen mit Aggregationsfunktion in die Vorgehensweisen Nested-Iteration, erst Outer-Join, dann Aggregation, erst Aggregation, dann Outer-Join und in orthogonale Optimierung unterschieden. Die orthogonale Optimierung geht in folgenden Schritten vor: Zerlegung der Abfrage in einen Operatorbaum auf der Basis des \sql{apply}-Operators. \sql{apply} ist ein relationaler Operator zweiter Ordnung, der die parametrierte Ausführung von Teilausdrücken abstrahiert. Im zweiten Schritt wird \sql{apply} in andere Operatoren umgeschrieben wie z.B. \sql{outerjoin}. Die Vorgehensweise zur Entfernung der Korrelation beruht auf den gleichen Mechanismen wie in \cite{671634}. Anschließend wird sofern möglich der Outer-Join noch vereinfacht. So lässt sich Outer-Join in Gegenwart von \sql{NULL}-verwerfenden Prädikaten in Join umwandeln. Zusätzlich werden \sql{group-by}-Ausdrücke möglichst spät ausgewertet. Nachteil dieser Vorgehensweise ist die mögliche Einführung gemeinsamer Teilausdrücke (CSEs) bei der Entschachtelung. 
\begin{itemize}
	\item G-Aggregation (Generalized-Aggregation)
	\item G-Join (Generalized-Join)
	\item G-Restriction (Generalized-Restriction)
	\item G-Outerjoin (Generalized-Outer-Join)
	\item Apply ist eine Ausprägung des Generalized-Projection Operators wie er z.B. in \cite{DBLP:books/mg/SilberschatzKS01} für die erweiterte Relationenalgebra vorgestellt wird. Der Generalized-Projection-Operator erlaubt nicht nur die Projektion auf Attribute der Ursprungsrelation, sondern auch auf Funktionsergebnisse die über den Attributen dieser Relation formuliert werden.
	\item SegmentApply
	\item NULL-rejecting Outer-Join Ein Outer-Join heißt NULL-verwerfend, wenn das Join-Prädikat NULL-verwerfend ist und die Menge A der Attribute Teilmenge des Schemas der zweiten Relation. Ist ein Outer-Join-Prädikat NULL-verwerfend, so ist es äquivalent zu einem Join-Prädikat mit der gleichen Join-Bedingung. Diese Äquivalenz ermöglicht die Ausführungsreihenfolge zumindest für gewisse Outer-Joins und Joins zu vertauschen.
\end{itemize}

SQL Prädikate lassen sich in verschiedene Klassen einteilen. Abhängig von der Semantik der Operation, kann man in \emph{einfache} Prädikate, \emph{Join}-Prädikate, \emph{Divisions}-Prädikate und \emph{geschachtelte} Prädikate unterscheiden. Einfache Prädikate sind solche Prädikate, die zu ihrer Berechnung nur auf Konstanten und Attribute einer Relation zugreifen. Ein Beispiel für ein solches Prädikat ist \textbf{$C_m = 10$}. Join-Prädikate benötigen zu ihrer Berechnung Attribute aus zwei oder mehr Relationen. Sie \emph{verbinden} (to join -- engl. verbinden) die verwendeten Relationen. In der Relationenalgebra entspricht diese Operation der Kombination von Kreuzprodukt und Selektion. 
\begin{lstlisting} 
select * from §$R_i, R_j$§ where §$R_i.C_n=R_j.C_m$§ 
\end{lstlisting} 
entspricht in der Relationenalgebra dem Ausdruck 
\begin{displaymath}
	\sigma_{R_i.C_n=R_j.C_m}(R_i \times R_j)
\end{displaymath}


Divisions-Prädikate berechnen die relationale Division über zwei Relationen. 

Geschachtelte Prädikate enthalten eine Unterabfrage in ihrem Ausdruck. Abhängig von der Ergebnismächtigkeit der Unterabfrage spricht der SQL-Standard von skalaren Unterabfragen, deren Ergebnis genau ein Wert ist; Zeilen-Unterabfragen (row subqueries), Ergebnis dieser Abfragen ist ein Tupel, das aus mehreren Attributen bestehen kann, sowie von Tabellen-Unterabfragen, deren Ergebnis eine Relation ist. Je nach Ergebnistyp ist die Verwendung von Unterabfragen an verschiedenen Stellen eines Abfrageblocks zulässig. Skalare Unterabfragen sind an jeder Stelle zulässig, an der auch Literale erlaubt sind.

Klassifikation von Prädikaten in 
einfache(Vergleich mit Konstante(n)), 
Nested, 
Join und 
Divisionsprädikat,\\
Einschränkung bei Join-Prädikaten auf =-Operator, \\
nur eine Spalte in der Select-Klausel erlaubt in Subquery, \\
keine GROUP BY\dots HAVING-Klausel in Subquery \cite{671658}, \\
Innerer und und äußerer Abfrageblock, \\
Klassifikation in 
N =(kein Join-Prädikat, dass auf Relationen im äußeren Abfrageblock verweist, keine Aggregationsfunktion in  Select-Klausel, ergibt eine Liste von Konstanten), 
A =(kein Join-Prädikat, dass auf Relationen im äußeren Abfrageblock verweist, Aggregationsfunktion in Select-Klausel, kann vollkommen unabhängig vom äußeren Abfrageblock ausgewertet werden, Ergebnis ist immer eine Konstante, 
J =(hat Join-Prädikat das die/eine Relation aus dem äußeren Abfrageblock referenziert, keine Aggregationsfunktion in Select-Klausel), 
JA =(hat Join-Prädikat mit Verweis auf Relation im äußeren Abfrageblock, Aggregationsfunktion), 
D =(ein Divisions-Prädikat, dass in einer der beiden Abfrageblöcke ein Join-Prädikat mit Verweis auf eine Relation im äußeren Abfrageblock, drückt die relationale Divisionsoperation aus), \\
\emph{nested-iteration method}, vollständige Auswertung des inneren Abfrageblocks für jedes Tupel des äußeren Blocks

\section{Klassifikation geschachtelter Abfragen}
Grundsätzlich lassen sich geschachtelte Abfragen in unabhängige Abfragen und korrelierte Abfragen unterscheiden. Unabhängige Abfragen lassen sich unabhängig vom äußeren Abfrageblock auswerten. Ist eine unabhängige Auswertung nicht möglich spricht man korrelierten Abfragen, da das Ergebnis der inneren Abfrage vom Wert des Tupels des äußeren Abfrageblocks abhängt. Kim stellt in \cite{319745} eine Klassifikation geschachtelter Abfragen auf, auf deren Basis seine ebendort vorgestellten Entschachtelungsalgorithmen arbeiten.

\subsection{Typ A}
geschachtelte Abfrage mit Aggregationsfunktion, ohne Prädikate die Attribute aus den äußeren Relationen verwenden, kann unabhängig vom äußeren Abfrageblock ausgewertet werden, hat einen Wert als Ergebnis, nicht Liste wg. Aggregationsfunktion. Beispiel: Den Ort mit der höchsten Postleitzahl aus der Relation PLZ
\begin{lstlisting}
select ort 
from plz
where
	plz = (select max(p:plz) from plz as p)
\end{lstlisting}

\subsection{Typ N}
Eine geschachtelte Abfrage ist vom Typ N, genau dann wenn die innere Abfrage keine  Aggregationsfunktion enthält und alle Prädikate entweder simple Prädikate oder Join-Prädikate über Attributen der Relationen des inneren Abfrageblocks sind. Prädikate vom Typ N können unabhängig vom äußeren Abfrageblock ausgewertet werden; ihr Ergebnis ist eine Liste von Konstanten. Beispiel: Alle Städte mit einer Postleitzahl > 5000
\begin{lstlisting}
select sname 
from staedte
where sname in (select ort from plz where plz > 5000)
\end{lstlisting}

\subsection{Typ J}
Eine Abfrage hat den Typ J, wenn mindestens ein Attribut der äußeren Relation im Prädikat verwendet wird, aber keine Aggregationsfunktion in der SELECT-Klausel vorkommt. Beispiel: Finde alle Städte, deren Bevölkerung größer als die Postleitzahl ist. 
\begin{lstlisting}
select sname
from staedte
where sname in (select ort from plz where plz < bev)
\end{lstlisting}

\subsection{Typ JA}
Korrelierte Abfragen mit Aggregationsfunktion in der SELECT-Klausel heißen vom Typ JA. Das Ergebnis der Unterabfrage hängt vom Wert eines Attributs der äußeren Relationen ab. Beispiel: Alle Orte mit ihrer maximalen Postleitzahl. Der Wert des Maximums ist vom gerade betrachteten Ort abhängig.
\begin{lstlisting}
select ort 
from plz
where plz = (select max(p:plz) from plz as p where ort = p:ort)
\end{lstlisting}

%
% EOF
%
%