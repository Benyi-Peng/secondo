%
% Kapitel Implementierung
%
%

\chapter{Implementierung}
\section{Ein Full-Outer-Join-Operator für SECONDO}
\textsc{Secondo} enthält bereits mehrere allgemeine Join-Operatoren. Als Vorlage für die Implementierung des Full-Outer-Join-Operators wurde der Operator \secondo{sortmergejoin} ausgewählt, da sich der zugrunde liegende Algorithmus mit wenigen Änderungen in einen Full-Outer-Join umbauen lässt. Sort-Merge-Join ist ein Algorithmus zur Berechnung von Equi-Joins. Voraussetzung ist die Sortierung der Relationen bzw. Ströme bezüglich der Join-Attribute. Diese Anforderung kann durch das vorhergehende Sortieren der Relationen erfüllt werden. In \textsc{Secondo} wird diese Aufgabe von dem Operator \secondo{sortmergejoin} erledigt. 

Zu Beginn des Algorithmus zeigen die beiden Zeiger auf den Anfang jeder Relation. 
\begin{enumerate}
\item Jetzt werden alle Tupel der ersten Relation mit übereinstimmenden Wert im Join-Attribut in einen Puffer gelesen und der Zeiger jeweils auf das aktuell gelesene Tupel gesetzt. 
\item Im nächsten Schritt werden alle Tupel der zweiten Relation in einen Puffer gelesen, die bezüglich ihres Join-Attribut-Werts übereinstimmen. 
\subitem Ist der Wert des Join-Attributs kleiner, als der des Tupels im ersten Puffer, wird der Zeiger in der zweiten Relation um eine Position erhöht. 
\subitem Besteht Gleichheit im Wert des Join-Attributs, so wird ein Tupel der Ergebnisrelation erzeugt, das aus der Aneinanderreihung der Tupel der Eingaberelationen besteht, für jedes Tupel das im ersten Puffer steht. Anschließend wird das Tupel aus dem zweiten Puffer gelöscht und mit dem nächsten Tupel aus diesem Puffer fortgefahren. Ist der zweite Puffer erschöpft, wird auch der erste Puffer geleert und mit dem ersten Schritt fortgefahren. 
\subitem Ist der Wert des Join-Attributs im zweiten Puffer größer, als im ersten, so wird der Zeiger in der ersten Relation solange erhöht, bis einer der oben genannten Fälle eintritt. 
\item Ist eine der beiden Relationen erschöpft, ist der Algorithmus beendet.
\end{enumerate}

Dieser Algorithmus lässt sich auf folgende Art und Weise zum Full-Outer-Join ausbauen. Bei jedem Vergleichsschritt wird jetzt mindestens ein Tupel der Ausgaberelation erzeugt. Ist der Wert im ersten Puffer größer als im zweiten, so besteht das Tupel der Ergebnismenge aus einer Verkettung des Tupels aus dem Puffer und einem mit NULL-Werten gefüllten Tupel der zweiten Relation. Auf die gleiche Art wird mit jedem Tupel des Puffers verfahren. Ist der Attribut-Wert gleich, so wird wie beim Sort-Merge-Join verfahren. Ist der Wert größer, so wird für jedes Tupel im zweiten Puffer ein Ausgabe-Tupel erzeugt, dass aus einer Aneinanderreihung eines NULL-Tupels der ersten Relation und dem Tupel aus dem Puffer besteht.

\begin{itemize}
	\item Beschreibung Sortmergejoin
	\subitem Zwei Tupelbuffer
	\subitem sortieren
	\subitem immer mit dem kleineren Tupel arbeiten und vergleichen
	\subitem falls Treffer, merge Schritt
	\subitem sonst Tupel verwerfen und mit nächstem Tupel weiterarbeiten
\end{itemize}
Basis ist sortmergejoin, jedes nicht \enquote{matchende} Tupel wird mit NULL-Werten aufgefüllt, nur Equi-Outerjoin\\
Ausblick: Full-Outer-Join auf Basis von Symmjoin. Die Tupel der beiden Ströme werden um ein Attribut TupelID erweitert. Zu jedem Tupel, das über den Symmjoin-Algorithmus einen Partner gefunden hat, wird die TupelID in einer Hash-Tabelle gespeichert. Dabei werden die TupelIDs für jeden Strom in einer eigenen Hash-Tabelle abgelegt. Nach Beendigung des Symmjoin-Algorithmus wird jeder Tupelpuffer ein zweites Mal durchlaufen. Ist die TupelID eines Tupels nicht in der entsprechenden Hash-Tabelle enthalten, so wird ein Ergebnistupel erzeugt, das die Werte aus dem betrachteten Tupel übernimmt und für die zusätzlichen Spalten mit NULL-Werten aufgefüllt wird. zwei Hash-Tabelle mit Tupel-Ids für alle gematchten Tupel, Tupelbuffer durchlaufen und ein mit NULL-Werten aufgefülltes Tupel erzeugen für alle nicht gematchten Tupel

\section{Umschreiben quantifizierter Prädikate}
Prädikate mit den quantifizierenden Operatoren \sql{EXISTS, NOT EXISTS, ANY} und \sql{ALL} werden in äquivalente Prädikate mit Aggregationen überführt. Damit sind sie den in \ref{chp:Entwurf} beschriebenen Algorithmen zur Entschachtelung zugänglich. Exists und Not-Exists werden in einen Vergleich der Anzahl Tupel mit 0 transformiert. Also \sql{exists(select §$C_n$§ from §$R_m$§ where P)} in \sql{0 < (select count(§$C_n$§) from §$R_m$§ where P)} und \sql{not exists(select §$C_n$§ from §$R_m$§ where P)} in \sql{0 = (select count(§$C_n$§) from §$R_m$§ where P)}. Dieser Schritt erfolgt bei jedem geschachtelten Prädikat, unabhängig davon, ob eine Entschachtelung möglich ist.

\section{Entschachtelung}
Die Reihenfolge der auf eine Abfrage angewandte Entschachtelungsalgorithmen ist: Entschachtelung von nicht korrelierten Unterabfragen in der SELECT-Klausel, Entschachtelung von nicht korrelierten Unterabfragen in der FROM-Klausel und Entschachtelung von Unterabfragen in der WHERE-Klausel. Implementierung des allgemeinen Entschachtelungsalgorithmus nach Kim/Ganski,Wong. Rekursive Entschachtelung von Abfragen. Dabei werden die oben beschriebenen Schachtelungstypen unterschieden. Je nach Schachtelungstyp wird der entsprechende Entschachtelungsalgorithmus angewendet. \enquote{Temporäre Relationen} werden für die Entschachtelung korrelierter Abfragen mit Aggregationsfunktion benötigt. Um die Geschwindigkeit bei wiederholtem Ausführen der Abfragen zu beschleunigen, werden die zum Entschachteln eines Prädikats notwendigen temporären Relationen zur Laufzeit in einem Prolog-Fakt gespeichert. Beim Schließen der Datenbank werden alle temporären Relationen gelöscht, um in jeder neuen Sitzung eine saubere Datenbankumgebung bereitzustellen. Die Implementierung des allgemeinen Entschachtelungsalgorithmus nach Kim/Ganski/Wong wurde mit dem Prädikat \prolog{transformNestedPredicates} realisiert. Je nach Schachtelungstyp des Prädikats wird der entsprechende Entschachtelungsalgorithmus angewandt. Da SQL beliebig tief geschachtelte Abfragen zulässt, wird der Algorithmus rekursiv auf das Ergebnis der Entschachtelung angewandt, bis das Ergebnis durch die implementierten Algorithmen nicht weiter entschachtelt werden kann. 

Über die Erkennung des Schachtelungstyps wird der Algorithmus ausgewählt, der auf das Prädikat angewandt wird. Für Typ-A Abfragen wird die Abfrage ausgewertet und das Ergebnis der Abfrage an ihrer Stelle eingefügt. Hierbei kann es bei Gleitkommazahlen zu numerischen Fehlern kommen, da die Werte zwischen dem Optimierer und \textsc{Secondo} nur mit einer begrenzten Genauigkeit ausgetauscht werden. Die Genauigkeit, mit der \textsc{Secondo} Gleitkommazahlen behandelt, lässt sich beim kompilieren festlegen.

Die Transformation geschachtelter Prädikate wird über eine Depth-First-Suche rekursiv angewandt. D.h. es wird bei den Blättern des Abfragegraphen mit der Optimierung begonnen. Da die Entschachtelungsalgorithmen eine Abfrage der Schachtelungstiefe n in eine Abfrage der Schachtelungstiefe n-1 überführen, entspricht dies genau der Vorgehensweise in \cite{38723}. 

Die Umsetzung von Algorithmus NEST-N-J\ref{sct:Algorithmus NEST-N-J} ist trivial. Da die Relationen der \sql{from}-Klausel bereits als Liste vorliegen, müssen nur die Listen der Unterabfrage und der äußeren Abfrage vereinigt werden. Auch die Prädikate liegen als Liste von Konjunktionstermen vor, und können über das Prädikat \prolog{append} zu einer Liste zusammengeführt werden. Im letzten Schritt des Algorithmus wird das zusätzliche Join-Prädikat erzeugt. Der Operator des neuen Prädikats ist =, falls das geschachtelte Prädikat den Operator \sql{in} beinhaltete, andernfalls wird der ursprüngliche Operator beibehalten.

Die komplexeste Behandlung erfordert Algorithmus NEST-JA2\ref{sct:Algorithmus NEST-JA2}. Im ersten Schritt werden die Prädikate der Unterabfrage in einfache Prädikate, Join-Prädikate der inneren Abfrage und korrelierte Prädikate partitioniert. Danach werden die drei oben beschriebenen temporären Relationen erzeugt. Tritt bei der Erstellung einer dieser Relationen ein Fehler auf wird die Verarbeitung mit einer Exception abgebrochen. Aus der dritten temporären Relation und der ursprünglichen Abfrage wird im nächsten Schritt die entschachtelte Variante aufgebaut. Die Syntax für die Umbenennung von Relationen und Attributen im Optimierer deckt sich nicht mit der entsprechenden Syntax im \textsc{Secondo}-Kernel deckt. Daher muss bei der Erstellung der entschachtelten Variante eine Umsetzung dieser Syntax erfolgen, um korrekt auf die Attribute der dritten temporären Relation zugreifen zu können. Die Syntax im Optimierer ist Name:Attribut, während im \textsc{Secondo}-Kernel Attribut\_Name verwendet wird. Jede Verwendung von Name:Attribut muss nun in Attribut\_Name geändert werden, sofern sie sich auf ein Attribut der dritten temporären Relation bezieht. Um sicherzustellen, dass es keine Namenskonflikte durch die neu erstellte Relation gibt, wird diese mit einer automatischen Umbenennung in die entschachtelte Abfrage aufgenommen.

\section{Schema-Lookup}
Um die weitere Verarbeitung geschachtelter Abfragen zu ermöglichen, müssen in der Phase des Schema-Lookups auch die Metadaten der Objekte der Unterabfragen nachgeschlagen werden. Hierzu werden die Daten zu den Selektionsattributen der Unterabfrage entsprechend den Attributen des äußeren Abfrageblocks ermittelt. Beim Nachschlagen der Relationen wird auf die Eindeutigkeit der Attributnamen über alle Abfrageblöcke hinweg geachtet. D.h. enthält eine Relation ein Attribut \emph{A} so darf keine weitere Relation ohne Umbenennung in der Abfrage verwendet werden, die ein Attribut namens \emph{A} enthält. Auch die Metadaten der in einem Prädikat verwendeten Relationen werden für die Unterabfrage bestimmt. Da die für die Optimierung notwendigen Datenstrukturen wie z.B. die Kanten des pog zu Beginn der Optimierung einer Abfrage zurückgesetzt werden, müssen bereits an dieser Stelle die notwendigen Abfragen auf den Stichproben-Relationen für die Prädikate der Unterabfrage erfolgen. Die Ermittlung der Selektivitäten erfolgt also ebenso wie die Entschachtelung Bottom-Up. Ein geschachteltes Prädikat, das zwei Relationen der äußeren Abfrage referenziert, wird bei der Ermittlung der Selektivität wie ein einfaches Join-Prädikat behandelt. Die Abfrage über den Stichprobenrelationen für ein Join-Prädikat wird immer mit einem \secondo{loopjoin} ausgeführt. Daher wird auch hier wie unten beschrieben, das geschachtelte Prädikat mit Hilfe einer Mapping Funktion übersetzt. Die Relationen der Unterabfrage werden auf entsprechenden Stichprobenrelationen geändert. Die Größe des Ergebnisses der Stichprobenabfrage wird auf insgesamt maximal 250.000 Tupel eingeschränkt. Hierzu wird die Anzahl der in der Stichprobenabfrage verwendeten Relationen gezählt. Bei n Relationen wird nur auf die ersten $\sqrt[n]{250.000}$ Tupel jeder Stichprobenrelation zugegriffen. Die maximal in einer Selektivitätsabfrage verwendete Anzahl von Tupeln pro Relation und insgesamt sind als Prolog-Fakten \prolog{maxSampleCard} und \prolog{maxSelCard} hinterlegt.
\begin{itemize}
	\item Selektionsattribute der Subquery
	\item Innere Tabellen
	\item Prädikate
	\subitem nach dem Lookup eines Prädikats immer die Selektivität ermitteln, um die globalen Datenstrukturen (pog etc.) nicht während der Plan-Ermittlung durch Subqueries zerstören
\end{itemize}

\section{Ermittlung des Ausführungsplans}
Der Ausführungsplan für eine geschachtelte Abfrage wird in folgenden Schritten ermittelt. Handelt es sich um eine Abfrage vom Typ N/J oder vom Typ A so kann die Ermittlung direkt über den Optimierer erfolgen, da die Abfrage keine korrelierten Prädikate enthält. Für die Planermittlung bei korrelierten Unterabfragen werden in einem ersten Schritt die korrelierten Prädikate aus der Abfrage entfernt. Die nicht-korrelierte Abfrage kann dann wieder vom Optimierer bearbeitet werden. Der daraus resultierende Plan wird nun um die korrelierten Prädikate erweitert. Hierbei werden diese in Form von \secondo{filter}-Ausdrücken an den Plan angefügt. Der \textsc{Secondo}-Operator \secondo{filter} erwartet als Argumente einen Tupelstrom (gegeben durch den Teilplan) und ein Prädikat, das auf eben diesen Strom angewandt wird. Dabei werden Prädikate mit niedriger Selektivität zuerst angewandt, um die Anzahl der zu verarbeitenden Ergebnistupel zu minimieren. Da der Optimierer nach dem gleichen Prinzip arbeitet, sollte diese Vorgehensweise eine positive Auswirkung auf die Laufzeit geschachtelter Abfragen gegenüber der wahlfreien Ausführung dieser Selektionen haben.
\begin{itemize}
	\item korrelierte Prädikate der Subquery entfernen. Hierzu werden die Prädikate untersucht, ob sie Attribute aus Relationen des äußeren Abfrageblocks verwenden.
	\item Plan für Subquery ohne korrelierte Prädikate ermitteln. Unterabfragen ohne korrelierten Prädikate werden durch die Standardmechanismen des \textsc{Secondo}-Optimierers übersetzt, um einen möglichst effizienten Ausführungsplan zu ermitteln. 
	\item korrelierte Prädikate mit aufsteigender Selektivität an Plan \enquote{anflanschen}. 
\end{itemize}

\section{Übersetzung des Plans in ausführbare Syntax}
\subsection{IN Operator}
Der in-Operator wird mit dem \textsc{Secondo} Operator \secondo{in} der Collection-Algebra übersetzt, unter Zuhilfenahme der Operatoren \secondo{collect\_set} und \secondo{projecttransformstream}. Der Operator \secondo{projecttransformstream} hat die Signatur 

\secondo{$stream(tuple((a_1 t_1)\cdots(a_n t_n)))\times a_n$ $\rightarrow$ $(stream t_n)$} 

und wandelt einen Tupel-Strom in einen Strom von Werten um. Hierbei wird das Selektions-Attribute der geschachtelten Abfrage als zu wählender Parameter mitgegeben. Der Strom wird dann mit dem Operator \secondo{collect\_set} in eine Menge umgewandelt und für jedes Tupel des äußeren Stroms wird mit \secondo{in} geprüft, ob der entsprechende Attributwert enthalten ist. D.h. es wird genau die mengenbasierte Semantik des \sql{in}-Operators erreicht.

\begin{lstlisting}
§$A_i$§ in (select §$A_j$§ from §$R_n$§)
\end{lstlisting}

wird in den \textsc{Secondo}-Ausdruck 

\secondo{filter[.$A_i$ in $R_n$ feed projecttransformstream[$A_j$] collect\_set]} übersetzt. 

\subsection{Using Parameter functions}
\textsc{Secondo} unterstützt im Moment Prädikate die aus Attributen von bis zu zwei Relationen aufgebaut sind. Da diese Beschränkung durch den nur durch Erweiterungen am zentralen Optimierungs-Algorithmus aufgehoben werden kann, gilt sie auch für Prädikate mit geschachtelten Abfragen. D.h. in einer Unterabfrage können maximal Attribute aus zwei äußeren Relationen verwendet werden. Da durch die Entschachtelung neue, temporäre Tabellen eingeführt werden können, kann es zu der Situation kommen, dass ein Prädikat in seiner geschachtelten Form ein Ausdruck über den Attributen zweier Relationen ist, aber bei der Entschachtelung zu einem Ausdruck über drei oder mehr Relationen wird. 

Je nach Anzahl der verwendeten äußeren Relationen wird die geschachtelte Abfrage mit einer allgemeine Mapping-Funktion mit einer entsprechenden Anzahl Parameter übersetzt. Die innere Abfrage wird in einen \enquote{normalen} \textsc{Secondo}-Ausdruck übersetzt, auf die Attribute der äußeren Relation kann dann über die Parameter der Mapping-Fuktion zugegriffen werden. Für den Zugriff auf die Paramter der Mapping-Funktion müssen noch zusätzliche Operatoren eingefügt werden. Diese benötigen die Parameternamen, um Zugriff zu ermöglichen.

Der Filter Operator erwartet neben einem Tupelstrom eine Mapping-Funktion, die vom Datentyp \secondo{tupel} nach \secondo{bool} abbildet. Handelt es sich bei dem zu übersetzenden Prädikat um ein geschachteltes Prädikat mit einem skalaren Vergleichsoperator, so hat die Funktion die Form $A_i \theta\!$ \secondo{query}-Ausdruck. Der \textsc{Secondo}-Parser prüft Attribut und Ergebnis des \secondo{query}-Ausdrucks auf Typ-Kompatibilität. 
\begin{itemize}
	\item Mit einem Parameter (normalerweise Filter)
	
	\item mit zwei Parametern für symmjoin (akzeptiert allgemeine Funktion) Wird in einem geschachtelten Prädikat auf zwei Relationen des äußeren Abfrageblocks verwiesen, so handelt es sich semantisch um ein Join-Prädikat. Symmjoin ist der einzige Algorithmus, der die Join-Operation auch für andere Fälle als den Equi-Join ausführen kann. Der Operator akzeptiert zwei Tupelströme und eine Mapping-Funktion mit zwei Parameter als Argumente. Die Mapping-Funktion hat die Signatur $(streamelem1, streamelem2) \rightarrow bool$. Über die Parameter streamelem1 und streamelem2 kann innerhalb der Unterabfrage auf die gerade betrachteten Tupel der äußeren Relationen zugegriffen werden. 
\end{itemize}



%
% EOF
%