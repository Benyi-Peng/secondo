%
% Kapitel Leistungsbewertung
%
%

\chapter{Leistungsbewertung}\label{chp:Leistungsbewertung}
Die geschachtelten Abfragen des TPC-D Benchmarks, die mit den in dieser Arbeit implementierten Algorithmen übersetzt werden können, dienen in diesem Kapitel als Beispiel, um die einzelnen Transformationsschritte bei der Entschachtelung darzustellen. Am Vergleich der Laufzeiten der einzelnen Phasen des Optimierers lässt sich erkennen, in welchen Fällen eine entschachtelte Ausführung der iterativ geschachtelten über- bzw. unterlegen ist. Die Abfragen werden auf einer Datenbank ausgeführt, die über ein Generierungsskript erzeugt werden kann. Um die Größe der Datenbank zu beeinflussen existiert ein Skalierungsfaktor, der bei der Erzeugung der Datenbank angegeben werden muss. Jede Abfrage wurde auf Datenbanken mit Skalierungsfaktor \begin{math} s \in \left\{ 2{^n}*10^{-4} | n >= 0 \wedge n <= 7 \right\}\end{math} ausgeführt. Die Darstellung der unterschiedlichen Laufzeiten für die einzelnen Phasen des Optimierers wurde anhand der Laufzeiten der Datenbank mit Skalierungsfaktor 0,0001 vorgenommen. Bei dieser Datenbankgröße unterscheiden sich die Laufzeiten der einzelnen Phasen nur um wenige Größenordnungen, so dass die graphische Darstellung der Aufteilung der Gesamtlaufzeit sinnvoll möglich ist.

\section{Laufzeit- und Strukturvergleich}\label{sct:Laufzeit- und Strukturvergleich}
\subsection{TPC-D Q2}
Diese Abfrage dient der Ermittlung des günstigsten Lieferanten für ein gegebenes Bauteil in einer Region. Für ein Bauteil einer bestimmten Art und Größe wird der Lieferant ermittelt, der dieses zu den günstigsten Konditionen anbietet. Gibt es mehrere Lieferanten in der gewählten Region, die das gewünschte Teil zu den günstigsten Konditionen anbieten, so werden die 100 Lieferanten mit dem höchsten Kontostand angezeigt. Von jedem Lieferanten werden der Kontostand, der Name und das Land, die Teilenummer und der Hersteller, die Lieferantenadresse, Telefonnummer und eine Bemerkung angezeigt. Als Werte der Parameter SIZE, TYPE und REGION wurden die Werte aus der Abfrageüberprüfung des Benchmarks gewählt.

\begin{itemize}
	\item SIZE = 15
	\item TYPE = BRASS
	\item REGION = EUROPE
\end{itemize}

\begin{lstlisting}[caption=Abfrage Q2,label=Q2:nested]
select
	[sacctbal, sname,
	 nname, ppartkey,
	 pmfgr, saddress,
	 sphone, scomment]
from
	[part, supplier,
	 partsupp, nation, region]
where
	[ppartkey = pspartkey,
	ssuppkey = pssuppkey,
	psize = 15,
	ptype contains "BRASS",
	snationkey = nnationkey,
	nregionkey = rregionkey,	
  rname = "EUROPE",
	pssupplycost = (
		select
			min(ps:pssupplycost)
		from
			[partsupp as ps, supplier as s,
			nation as n, region as r]
		where
			[ppartkey = ps:pspartkey,
		 	s:ssuppkey = ps:pssuppkey,
		 	s:snationkey = n:nnationkey,
		 	n:nregionkey = r:rregionkey,	
		 	r:rname = "EUROPE"]
	 )]
orderby
	[sacctbal desc,
	nname,
	sname,
	ppartkey] 
first 100
\end{lstlisting}

Die innere Abfrage ist vom Typ JA, da eine Aggregation (das Minimum) berechnet wird und sie ein Prädikat \sql{ppartkey = ps:ppartkey} enthält, das auf die Relation \emph{pssupplycost} des äußeren Abfrageblocks zugreift. Der Optimierer wendet also den in \ref{sct:Algorithmus NEST-JA2} beschriebenen Algorithmus an. Hierzu werden insgesamt drei temporäre Tabellen benötigt. Die erste temporäre Relation ist die Restriktion der im inneren Abfrageblock verwendeten Relationen des äußeren Blocks auf die benötigten Attribute.

\begin{lstlisting}[caption=erste temporäre Relation zu Q2,label=Q2:trelxx1]
trelxx1 = 
select distinct
	[ppartkey, 
	pspartkey] 
from 
	[part, 
	partsupp]
\end{lstlisting}

Die zweite temporäre Relation ist die Einschränkung der inneren Relation durch alle \emph{einfachen} Prädikaten.

\begin{lstlisting}[caption=zweite temporäre Relation zu Q2,label=Q2:trelxx2]
trelxx2 =
select [ps:pspartkey, ps:pssupplycost]
from 
	[partsupp as ps, supplier as s, 
	nation as n, region as r]
where 
	[s:ssuppkey = ps:pssuppkey, 
	s:snationkey = n:nnationkey, 
	n:nregionkey = r:rregionkey, 
	r:rname = "EUROPE"]
\end{lstlisting}

Die dritte temporäre Relation wird aus dem Equi-Join der ersten und zweiten temporären Relationen unter Berechnung der Aggregation gebildet. Man beachte die Attributnamen mit \enquote{\_ps}. Diese sind notwendig, da sich Optimierer und \textsc{Secondo} in der Syntax für umbenannte Tupel unterscheiden. Es muss hier auf die ausführbare Syntax der Spalten zurück gegriffen werden. 

\begin{lstlisting}[caption=dritte temporäre Relation zu Q2,label=Q2:trelxx3]
trelxx3 = 
select [pspartkey_ps, min(pssupplycost_ps) as var1] 
from [trelxx1, trelxx2] 
where [ppartkey = pspartkey_ps] 
groupby pspartkey_ps
\end{lstlisting}

\begin{lstlisting}[caption=Entschachtelte Variante von Abfrage Q2,label=Q2:unnested]
select 
	[sacctbal, sname, nname, 
	ppartkey, pmfgr, saddress, 
	sphone, scomment]
from 
	[part, supplier, partsupp, 
	nation, region, trelxx3 as alias1]
where 
	[ppartkey = pspartkey, 
	ssuppkey = pssuppkey, 
	psize = 15, 
	ptype contains["BRASS"], 
	snationkey = nnationkey, 
	nregionkey = rregionkey, 
	rname = ["EUROPE"], 
	ppartkey = alias1:pspartkey_ps, 
	pssupplycost = alias1:var1]
orderby 
	[sacctbal desc, nname, 
	sname, ppartkey]
first 100
\end{lstlisting}

\begin{lstlisting}[language=secondoscript,caption=Ausführbare Syntax der entschachtelten Variante von Q2,label=Q2:excutable_unnested]
PART feedproject[pMFGR, pPARTKEY, pSIZE, pTYPE] 
SUPPLIER feedproject[sACCTBAL, sADDRESS, sCOMMENT, sNAME, sNATIONKEY, sPHONE, sSUPPKEY]  
NATION feedproject[nNAME, nNATIONKEY, nREGIONKEY]  
REGION feedproject[rNAME, rREGIONKEY]  
sortmergejoin[nREGIONKEY , rREGIONKEY] {0.007992, 0.808}  
sortmergejoin[sNATIONKEY , nNATIONKEY] {0.004995, 0.5} 
PARTSUPP feedproject[psPARTKEY, psSUPPKEY, psSUPPLYCOST] 
symmjoin[(.sSUPPKEY = ..psSUPPKEY)] {0.00024975, 0.02525} 
symmjoin[(.pPARTKEY = ..psPARTKEY)] {1.24875e-05, 0.001275} 
trelxx3 feedproject[psPARTKEY_ps, Var1] {alias1}
symmjoin[(.psSUPPLYCOST = ..Var1_alias1)] {2.93824e-05, 0.00302941}
filter[(.pPARTKEY = .psPARTKEY_ps_alias1)] {9.18199e-05, 0.0102022}  
filter[(.pTYPE contains "BRASS")] {0.00624375, 0.625}  
filter[(.pSIZE = 15)] {0.00624375, 0.60625}  
filter[(.rNAME = "EUROPE")] {0.1998, 19.4} 
project[sACCTBAL, sNAME, nNAME, pPARTKEY, pMFGR, sADDRESS, sPHONE, sCOMMENT]  
sortby[sACCTBAL desc, nNAME asc, sNAME asc, pPARTKEY asc]  
head[100]  
consume
\end{lstlisting}

\begin{lstlisting}[caption=Ausführbare Syntax Q2 ohne Entschachtelung,label=Q2:executable]
PART feedproject[pMFGR, pPARTKEY, pSIZE, pTYPE] 
SUPPLIER feedproject[sACCTBAL, sADDRESS, sCOMMENT, sNAME, sNATIONKEY, sPHONE, sSUPPKEY]  
NATION feedproject[nNAME, nNATIONKEY, nREGIONKEY]  REGION feedproject[rNAME, rREGIONKEY]  
sortmergejoin[nREGIONKEY , rREGIONKEY] {0.007992, 0.808}  
sortmergejoin[sNATIONKEY , nNATIONKEY] {0.004995, 0.5} 
PARTSUPP feedproject[psPARTKEY, psSUPPKEY, psSUPPLYCOST] 
symmjoin[(.sSUPPKEY = ..psSUPPKEY)] {0.00024975, 0.02525} 
symmjoin[(.pPARTKEY = ..psPARTKEY)] {1.24875e-05, 0.001275}  
\textbf{
filter[
	fun (alias3: TUPLE) 
	(
		attr(alias3, psSUPPLYCOST) 
		= 
		SUPPLIER feedproject[sNATIONKEY, sSUPPKEY] {s}  
		NATION feedproject[nNATIONKEY, nREGIONKEY] {n}  
		REGION feedproject[rNAME, rREGIONKEY] {r}  
		sortmergejoin[nREGIONKEY_n , rREGIONKEY_r] {0.007992, 0.8}  
		sortmergejoin[sNATIONKEY_s , nNATIONKEY_n] {0.004995, 0.505}  
		filter[(.rNAME_r = "EUROPE")] {0.1998, 19.4} 
		PARTSUPP feedproject[psPARTKEY, psSUPPKEY, psSUPPLYCOST] {ps} 
		symmjoin[(.sSUPPKEY_s = ..psSUPPKEY_ps)] {0.00024975, 0.026}  
		filter[(attr(alias3, pPARTKEY) = .psPARTKEY_ps)]  
		min[psSUPPLYCOST_ps] 
	)] {1.24875e-05, 0.001675}  
}
filter[(.pSIZE = 15)] {0.00624375, 0.60625}  
filter[(.pTYPE contains "BRASS")] {0.00624375, 0.625}  
filter[(.rNAME = "EUROPE")] {0.1998, 19.4} 
project[sACCTBAL, sNAME, nNAME, pPARTKEY, pMFGR, sADDRESS, sPHONE, sCOMMENT]  
sortby[sACCTBAL desc, nNAME asc, sNAME asc, pPARTKEY asc]  
head[100]  
consume
\end{lstlisting}

Das geschachtelte Prädikat 

\begin{lstlisting}[caption=geschachteltes Prädikat]
pssupplycost = (
		select
			min(ps:pssupplycost)
		from
			[partsupp as ps, supplier as s,
			nation as n, region as r]
		where
			[ppartkey = ps:pspartkey,
		 	s:ssuppkey = ps:pssuppkey,
		 	s:snationkey = n:nnationkey,
		 	n:nregionkey = r:rregionkey,	
		 	r:rname = "EUROPE"]
	 )
\end{lstlisting}

wurde durch die zwei Prädikate \sql{pssupplycost = trelxx4:var1} und \sql{ppartkey = trelxx4:pspartkey\_ps} ersetzt. Das erste der beiden Prädikate ergibt sich direkt aus dem geschachtelten Prädikat, während das zweite Prädikat die Übernahme des korrelierten Prädikats in die endgültige Abfrage darstellt. Zusätzlich wurde die neue Relation trelxx3 in die FROM-Klausel aufgenommen. Alle nicht korrelierten Prädikate der Unterabfrage wurden bereits bei der Erstellung der Relation trelxx3 berücksichtigt. Die Prädikate der entschachtelten Variante sind nur noch einfache und Join-Prädikate. 

\begin{table}[h]
\centering
\begin{tabular}{@{}lrrrr@{}} \toprule
& \multicolumn{4}{c}{Laufzeit in ms} \\ \cmidrule(l){2-5}
& \multicolumn{2}{c}{iterativ} & \multicolumn{2}{c}{entschachtelt} \\ 
Phase & \multicolumn{1}{c}{kalt} & warm & \multicolumn{1}{c}{kalt} & warm\\ \midrule
Rewrite & 1 & 1 & 1138 & 1 \\
Lookup & 275 & 38 & 3 & 3 \\
QueryToPlan & 371 & 398 & 903 & 937 \\
Execute & 1440 & 1480 & 390 & 401 \\
\cmidrule(l){1-5} 
Total & 2087 & 1917 & 2434 & 1342 \\
\bottomrule\end{tabular}
  \caption{Detaillierte Laufzeiten von Q2 bei Skalierungsfaktor = 0.0001 der DB}
  \label{tab:Q2 Laufzeit}
\end{table}

Der Optimierer berechnet für Skalierungsfaktor 0,0001 Kosten von 528,18 für die entschachtelte und 481,189 für die iterative Ausführung. Dies entspricht in etwa dem tatsächlichen Verhältnis der Laufzeiten, wie man Tabelle \ref{tab:Q2 Laufzeit} entnehmen kann. Die erneute Ausführung der entschachtelten Variante ist wie man sehen kann schneller, da hier die bereits erstellten temporären Relationen wiederverwendet werden. Die Laufzeit für deren Erstellung entfällt hier also, was sich auch an den Laufzeiten ablesen lässt. Bei der iterativen Ausführung entfallen bei der zweiten Ausführung nur die Ermittlung der Selektivitäten, was sich an der kürzeren Laufzeit der Lookup-Phase erkennen lässt.

\pgfplotsset{every x tick label/.style={below, yshift=-0.25em, rotate=30, xshift=-1.5em}, every y tick label/.style={/pgf/number format/1000 sep={.}}}

\begin{tikzpicture}
\begin{axis}[
x tick label style={
/pgf/number format/1000 sep=},
xtick=data,
ylabel=Sekunden,
xticklabels={A kalt,A warm,B kalt,B warm},
enlargelimits=0.10,
legend style={at={(1.65,0.5)},
area legend,
anchor=east,legend columns=1},
ybar stacked,
]
\addplot coordinates {(0,	1138	)(1,	1	)(2,	1	)(3,	1	)};
\addplot coordinates {(0,	3	)(1,	3	)(2,	275	)(3,	38	)};
\addplot coordinates {(0,	903	)(1,	937	)(2,	371	)(3,	398	)};
\addplot coordinates {(0,	390	)(1,	401	)(2,	1440	)(3,	1480	)};
\legend{Rewrite,Lookup,QueryToPlan,Execute}
\end{axis}
\end{tikzpicture}

\begin{figure}
\begin{tikzpicture}
\begin{axis}[
x tick label style={
/pgf/number format/1000 sep=},
xtick=data,
%axis y line=left,
ylabel=Sekunden,
xlabel=Skalierungsfaktor,
xlabel style={yshift=-2.5em},
xticklabels={,0.0016,0.0032,0.0064,0.0128},%0.0001,0.0002,0.0004,0.0008,0.0016,0.0032,0.0064},
enlargelimits=0.10,
legend style={at={(1.65,0.5)},
%area legend,
anchor=east,legend columns=1},
scaled x ticks=base 10:0,
%ybar stacked,
sharp plot
]

\addplot coordinates {(0.0008,	1.79	)(0.0016,	2.975	)(0.0032,	7.381	)(0.0064,	15.645	)(0.0128,	57.756	)};
\addplot coordinates {(0.0008,	1.063	)(0.0016,	1.887	)(0.0032,	5.095	)(0.0064,	8.094	)(0.0128,	31.848	)};
\addplot coordinates {(0.0008,	8.241	)(0.0016,	4.882	)(0.0032,	33.689	)(0.0064,	302.276	)(0.0128,	2568.521	)};
\addplot coordinates {(0.0008,	8.213	)(0.0016,	4.813	)(0.0032,	33.764	)(0.0064,	300.085	)(0.0128,	2525.131	)};
\legend{entschachtelt kalt, entschachtelt warm, iterativ kalt, iterativ warm}
\end{axis}
\end{tikzpicture}
\caption{Laufzeit von Q2 für die Ausführungstrategien nach Skalierungsfaktor}
\label{plot:Q2 line}
\end{figure}

Während die Laufzeit für die entschachtelte Ausführung nur linear ansteigt, wächst die Laufzeit für die iterative Ausführung exponentiell. Schon bei einem Skalierungsfaktor von 0.0064 verringert sich die Laufzeit der Abfrage durch Entschachtelung um eine Größenordnung. Bei 


\subsection{TPC-D Q4}
Diese Abfrage ermittelt, wie gut das Bestell-Prioritätssystem funktioniert. Es wird die Anzahl der Bestellungen ermittelt, bei welchen mindestens ein Teil nach dem versprochenen Lieferdatum beim Kunden einging. Die Abfrage führt die Anzahl solcher Bestellungen in der Reihenfolge der Bestellprioritäten auf.
Als Parameter DATE wurde der Wert \enquote{1993-07-01} aus der Abfrage-Überprüfung gewählt

\begin{lstlisting}[caption=Abfrage Q4]
select
	[oorderpriority, count(*) as ordercount]
from orders
where		
	[oorderdate >= instant("1993-07-01"),		
	oorderdate < theInstant(
		year_of(instant("1993-07-01")), 
	 	month_of(instant("1993-07-01")) + 3, 
	 	day_of(instant("1993-07-01"))
	),
	exists(
	 	select *
		from lineitem
		where
			[lorderkey = oorderkey, 
			lcommitdate < lreceiptdate]
	)]
groupby [oorderpriority]
orderby	[oorderpriority]
\end{lstlisting}

Die Abfrage ist vom Typ J, da das geschachtelte Prädikat keine Aggregation enthält, aber über das Prädikat \sql{lorderkey = oorderkey} mit dem äußeren Abfrageblock korreliert ist.

Die Projektion der äußeren Relation auf die Join-Spalte ergibt
\begin{lstlisting}[caption=TempRel1]
select distinct[oorderkey] 
from orders
\end{lstlisting}

Einschränkung der inneren Relation mit allen \emph{einfachen} Prädikate.
\begin{lstlisting}[caption=TempRel2]
select [lorderkey]
from [lineitem]
where [lcommitdate < lreceiptdate]
\end{lstlisting}


Als dritte temporäre Relation muss daher der Full-Outer-Join zwischen den temporären Relationen trelxx1 und trelxx2 berechnet werden.
\begin{lstlisting}[caption=TempRel3]
trelxx1  feed 
trelxx2  feed  
smouterjoin[oORDERKEY, lORDERKEY] 
sortby[oORDERKEY asc] 
groupby[oORDERKEY;Var1: group feed filter[not(isempty(.lORDERKEY))] count] 
projectextend[Var1; lORDERKEY: .oORDERKEY] 
consume
\end{lstlisting}

\begin{lstlisting}[caption=Entschachtelte Variante von Q4]
select [oorderpriority, count(*) as ordercount] 
from [orders, trelxx3 as alias1] 
where 
	[oorderdate>=instant("1993-07-01"), 
	oorderdate<theInstant(
		year_of(instant("1993-07-01")), 
		month_of(instant("1993-07-01")) + 3, 
		day_of(instant("1993-07-01"))
	), 
	oorderkey = alias1:lorderkey, 
	0 < alias1:var1] 
groupby [oorderpriority] 
orderby [oorderpriority]
\end{lstlisting}

\begin{lstlisting}[caption=Q4 ausführbare Syntax entschachtelte Version]
ORDERS feedproject[oORDERDATE, oORDERKEY, oORDERPRIORITY]  
filter[(.oORDERDATE < theInstant(
	year_of(instant("1993-07-01")), 
	(month_of(instant("1993-07-01")) + 3), 
	day_of(instant("1993-07-01")))
)] {0.001665, 0.0841667}  
filter[(.oORDERDATE >= instant("1993-07-01"))] {0.0058275, 0.0833333} 
trelxx3 feedproject[lORDERKEY, Var1] {alias1} 
symmjoin[(.oORDERKEY = ..lORDERKEY_alias1)] {0.000803196, 0.007608}  
filter[(0 < .Var1_alias1)] {0.373792, 0.0875}  
sortby[oORDERPRIORITY asc] 
groupby[oORDERPRIORITY; Ordercount: group feed  count ]
project[oORDERPRIORITY, Ordercount]  
sortby[oORDERPRIORITY asc]  
consume
\end{lstlisting}

\begin{lstlisting}[caption=Q4 ausführbare Syntax geschachtelte Version]
ORDERS feedproject[oORDERDATE, oORDERKEY, oORDERPRIORITY]  
filter[(.oORDERDATE < theInstant(
	year_of(instant("1993-07-01")), 
	(month_of(instant("1993-07-01")) + 3), 
	day_of(instant("1993-07-01"))))
]  {0.001665, 0.0841667}  
filter[(.oORDERDATE >= instant("1993-07-01"))] {0.0058275, 0.0833333}  
filter[
	fun (alias2: TUPLE) (
		0 
		< 
		LINEITEM feedproject[lCOMMITDATE, lORDERKEY, lRECEIPTDATE]  
		filter[(.lCOMMITDATE < .lRECEIPTDATE)] {0.0034965, 0.059}  
		filter[(.lORDERKEY = attr(alias2, oORDERKEY))]  
		count 
	)] {0.0008325, 0.0925}  
sortby[oORDERPRIORITY asc] 
groupby[oORDERPRIORITY; Ordercount: group feed  count ]
project[oORDERPRIORITY, Ordercount]  
sortby[oORDERPRIORITY asc]  
consume
\end{lstlisting}

\begin{tikzpicture}
\begin{axis}[
x tick label style={
/pgf/number format/1000 sep=},
xtick=data,
ylabel=Millisekunden,
scaled ticks=base 10:0,
xticklabels={A kalt,A warm,B kalt,B warm},
enlargelimits=0.10,
legend style={at={(1.65,0.5)},
area legend,
anchor=east,legend columns=1},
ybar stacked,
]
\addplot coordinates {(0,	1222	)(1,	1	)(2,	1	)(3,	2	)};
\addplot coordinates {(0,	2	)(1,	2	)(2,	169	)(3,	2	)};
\addplot coordinates {(0,	387	)(1,	9	)(2,	4	)(3,	4	)};
\addplot coordinates {(0,	9597	)(1,	9638	)(2,	4710	)(3,	4703	)};
\legend{Rewrite,Lookup,QueryToPlan,Execute}
\end{axis}
\end{tikzpicture}

\begin{figure}
\begin{tikzpicture}
\begin{axis}[
x tick label style={
/pgf/number format/1000 sep=},
xtick=data,
ylabel=Sekunden,
xlabel=Skalierungsfaktor,
xlabel style={yshift=-2.5em},
xticklabels={,,,0.0016,0.0032,0.0064},
enlargelimits=0.10,
legend style={at={(1.65,0.5)},
anchor=east,legend columns=1},
scaled x ticks=base 10:0,
sharp plot
]
\addplot coordinates {(0.0002,	0.067	)(0.0004,	0.489	)(0.0008,	7.03	)(0.0016,	25.483	)(0.0032,	98.154	)(0.0064,	383.557	)};
\addplot coordinates {(0.0002,	0.058	)(0.0004,	0.076	)(0.0008,	6.277	)(0.0016,	24.222	)(0.0032,	95.008	)(0.0064,	382.824	)};
\addplot coordinates {(0.0002,	0.504	)(0.0004,	0.684	)(0.0008,	3.313	)(0.0016,	88.478	)(0.0032,	354.426	)(0.0064,	1442.454  )};
\addplot coordinates {(0.0002,	0.434	)(0.0004,	0.643	)(0.0008,	3.297	)(0.0016,	88.188	)(0.0032,	353.111	)(0.0064,	1439.432  )};
\legend{entschachtelt kalt, entschachtelt warm, iterativ kalt, iterativ warm}
\end{axis}
\end{tikzpicture}
\caption{Laufzeit von Q4 für die Ausführungstrategien nach Skalierungsfaktor}
\label{plot:Q4 line}
\end{figure}

\subsection{TPC-D Q7}
Diese Abfrage listet für zwei gewählte Länder den Wert der versandten Waren. Es wird Wert der Waren der zwischen Lieferanten und Kunden länderübergreifend versandt wurde ausgegeben, gruppiert nach Land des Lieferanten, Land des Kunden und Jahr. 
\begin{lstlisting}[caption=Abfrage Q7]
select [supp_nation, cust_nation, lyear, sum(volume) as revenue]
from ( 
	select 
		[n1:nname as supp_nation,
		 n2:nname as cust_nation,
		 year_of(lshipdate) as lyear,
		 lextendedprice * (1 - ldiscount) as volume]
	from
		[supplier, lineitem, orders, 
		customer,	nation as n1, nation as n2]
	where
		[ssuppkey = lsuppkey,
		oorderkey = lorderkey,
		ccustkey = ocustkey,
		snationkey = n1:nnationkey,
		cnationkey = n2:nnationkey,
		(n1:nname = "FRANCE" and n2:nname = "GERMANY")
		or 
		(n1:nname = "GERMANY" and n2:nname = "FRANCE"),
		between(instant2real(lshipdate), 
			instant2real(instant("1995-01-01")), 
			instant2real(instant("1996-12-31"))
		)]
	) as shipping
groupby	[supp_nation, cust_nation, lyear]
orderby	[supp_nation, cust_nation, lyear]
\end{lstlisting}

Ermittlung der Grunddaten, über die selektiert wird.
\begin{lstlisting}[caption=TempRel1]
select 
	[n1:nname as supp_nation, 
	n2:nname as cust_nation, 
	year_of(lshipdate)as lyear, 
	lextendedprice* (1-ldiscount)as volume]
from 
	[supplier, lineitem, orders, 
	customer, nation as n1, nation as n2]
where 
	[ssuppkey = lsuppkey, 
	oorderkey = lorderkey, 
	ccustkey = ocustkey, 
	snationkey = n1:nnationkey, 
	cnationkey = n2:, 
	(n1:nname = "FRANCE" and n2:nname = "GERMANY")
	or 
	(n1:nname = "GERMANY" and n2:nname = "FRANCE"), 
	between(instant2real(lshipdate), 
		instant2real(instant("1995-01-01")), 
		instant2real(instant("1996-12-31"))
	)]
\end{lstlisting}

\begin{lstlisting}[caption=Entschachtelte Variante von Q7]
select 
	[supp_nation, cust_nation, 
	lyear, sum(volume)as revenue]
from trelxx1 
groupby [supp_nation, cust_nation, lyear]
orderby [supp_nation, cust_nation, lyear]
\end{lstlisting}

\begin{lstlisting}[caption=Q7 ausführbar entschachtelt]
trelxx4  feed  
sortby[Supp_nation asc, Cust_nation asc, Lyear asc] 
groupby[Supp_nation, Cust_nation, Lyear; Revenue: group feed  sum[Volume] ]
project[Supp_nation, Cust_nation, Lyear, Revenue]  
sortby[Supp_nation asc, Cust_nation asc, Lyear asc]  
consume
\end{lstlisting}

\begin{lstlisting}[caption=Q7 ausführbar geschachtelt]
CUSTOMER feedproject[cCUSTKEY, cNATIONKEY] 
SUPPLIER feedproject[sNATIONKEY, sSUPPKEY]  
NATION feedproject[nNAME, nNATIONKEY] {n1}  
sortmergejoin[sNATIONKEY , nNATIONKEY_n1] {0.004995, 0.505} 
NATION feedproject[nNAME, nNATIONKEY] {n2} 
symmjoin[(((.nNAME_n1 = "FRANCE") and (..nNAME_n2 = "GERMANY")) or ((.nNAME_n1 = "GERMANY") and (..nNAME_n2 = "FRANCE")))] {0.0015984, 0.1696}
symmjoin[(.cNATIONKEY = ..nNATIONKEY_n2)] {0.001665, 0.0336667} 
ORDERS feedproject[oCUSTKEY, oORDERKEY] 
symmjoin[(.cCUSTKEY = ..oCUSTKEY)] {0.001998, 0.00526667} 
LINEITEM feedproject[lDISCOUNT, lEXTENDEDPRICE, lORDERKEY, lSHIPDATE, lSUPPKEY] 
symmjoin[(.oORDERKEY = ..lORDERKEY)] {3.996e-06, 0.00042}  
filter[(.sSUPPKEY = .lSUPPKEY)] {0.001998, 0.026}  
filter[instant2real(.lSHIPDATE) between[instant2real(instant("1995-01-01")) , instant2real(instant("1996-12-31"))] ] {0.0004995, 0.0505}  extend[Supp_nation: .nNAME_n1, Cust_nation: .nNAME_n2, Lyear: year_of(.lSHIPDATE), Volume: (.lEXTENDEDPRICE * (1 - .lDISCOUNT))] project[Supp_nation, Cust_nation, Lyear, Volume]  
sortby[Supp_nation asc, Cust_nation asc, Lyear asc] 
groupby[Supp_nation, Cust_nation, Lyear; Revenue: group feed  sum[Volume] ]
project[Supp_nation, Cust_nation, Lyear, Revenue]  
sortby[Supp_nation asc, Cust_nation asc, Lyear asc]  
consume
\end{lstlisting}

\begin{tikzpicture}
\begin{axis}[
x tick label style={
/pgf/number format/1000 sep=},
xtick=data,
ylabel=Millisekunden,
scaled ticks=base 10:0,
xticklabels={A kalt,A warm,B kalt,B warm},
enlargelimits=0.10,
legend style={at={(1.65,0.5)},
area legend,
anchor=east,legend columns=1},
ybar stacked,
]
\addplot coordinates {(0,	962	)(1,	1	)(2,	1	)(3,	1	)};
\addplot coordinates {(0,	0	)(1,	0	)(2,	7	)(3,	5	)};
\addplot coordinates {(0,	0	)(1,	0	)(2,	279	)(3,	266	)};
\addplot coordinates {(0,	103	)(1,	100	)(2,	495	)(3,	510	)};
\legend{Rewrite,Lookup,QueryToPlan,Execute}
\end{axis}
\end{tikzpicture}

\begin{figure}
\begin{tikzpicture}
\begin{axis}[
x tick label style={
/pgf/number format/1000 sep=},
xtick=data,
ylabel=Sekunden,
xlabel=Skalierungsfaktor,
xlabel style={yshift=-2.5em},
xticklabels={,,,,0.0016,0.0032,0.0064,0.0128},
enlargelimits=0.10,
legend style={at={(1.65,0.5)},
anchor=east,legend columns=1},
scaled x ticks=base 10:0,
sharp plot
]
\addplot coordinates {(0.0001,	0.608	)(0.0002,	0.101	)(0.0004,	2.292	)(0.0008,	0.622	)(0.0016,	6.499	)(0.0032,	1.826	)(0.0064,	134.078	)(0.0128,	1896.151	)};
\addplot coordinates {(0.0001,	0.225	)(0.0002,	0.08	)(0.0004,	1.79	)(0.0008,	0.204	)(0.0016,	0.245	)(0.0032,	0.257	)(0.0064,	0.285	)(0.0128,	0.445	)};
\addplot coordinates {(0.0001,	0.453	)(0.0002,	2.369	)(0.0004,	1.07	)(0.0008,	0.497	)(0.0016,	6.447	)(0.0032,	1.52	)(0.0064,	133.863	)(0.0128,	1894.486	)};
\addplot coordinates {(0.0001,	0.445	)(0.0002,	2.269	)(0.0004,	1.064	)(0.0008,	0.508	)(0.0016,	6.364	)(0.0032,	1.543	)(0.0064,	133.109	)(0.0128,	1892.116	)};
\legend{entschachtelt kalt, entschachtelt warm, iterativ kalt, iterativ warm}
\end{axis}
\end{tikzpicture}
\caption{Laufzeit von Q7 für die Ausführungstrategien nach Skalierungsfaktor}
\label{plot:Q7 line}
\end{figure}


\subsection{TPC-D Q9}
Ermittelt den Gewinn, der mit bestimmten Teilen gemacht wurde, gruppiert nach Land und Jahr. Gewinn ist hier definiert als rabattierter Verkaufspreis - Einkaufspreis * Anzahl.
\begin{lstlisting}[caption=Abfrage Q9]
select [nation, oyear, sum(amount) as sumprofit]
from (
	select
		[nname as nation,
		 year_of(oorderdate) as oyear,
		 lextendedprice * (1 - ldiscount) - pssupplycost * lquantity as amount]
	from
		[part, supplier,
		 lineitem, partsupp,
		 orders, nation]
	where
		[ssuppkey = lsuppkey,
		 pssuppkey = lsuppkey,
		 pspartkey = lpartkey,
		 ppartkey = lpartkey,
		 oorderkey = lorderkey,
		 snationkey = nnationkey,
		 pname contains "green"]
	)  as profit
groupby	[nation, oyear]
orderby [nation, oyear desc]
\end{lstlisting}

\begin{lstlisting}[caption=TempRel1]
select 
	[nname as nation, 
	year_of(oorderdate)as oyear, 
	lextendedprice * (1 - ldiscount) - pssupplycost * lquantity as amount]
from 
	[part, supplier, lineitem, 
	partsupp, orders, nation]
where 
	[ssuppkey = lsuppkey, 
	pssuppkey = lsuppkey, 
	pspartkey = lpartkey, 
	ppartkey = lpartkey, 
	oorderkey = lorderkey, 
	snationkey = nnationkey, 
	pname contains "green"]
\end{lstlisting}

\begin{lstlisting}[caption=Entschachtelte Variante von Q9]
select [nation, oyear, sum(amount)as sumprofit]
from trelxx1 
groupby [nation, oyear]
orderby [nation, oyear desc]
\end{lstlisting}

\begin{lstlisting}[caption=Q9 ausführbare Syntax entschachtelt]
 trelxx5  feed  sortby[Nation asc, Oyear asc] groupby[Nation, Oyear; Sumprofit: group feed  sum[Amount] ]project[Nation, Oyear, Sumprofit]  sortby[Nation asc, Oyear desc]  consume
\end{lstlisting}

\begin{lstlisting}[caption=Q9 ausführbare Syntax geschachtelt]
ORDERS feedproject[oORDERDATE, oORDERKEY] PARTSUPP feedproject[psPARTKEY, psSUPPKEY, psSUPPLYCOST] PART feedproject[pNAME, pPARTKEY] SUPPLIER feedproject[sNATIONKEY, sSUPPKEY]  NATION feedproject[nNAME, nNATIONKEY]  sortmergejoin[sNATIONKEY , nNATIONKEY] {0.004995, 0.495} LINEITEM feedproject[lDISCOUNT, lEXTENDEDPRICE, lORDERKEY, lPARTKEY, lQUANTITY, lSUPPKEY] symmjoin[(.sSUPPKEY = ..lSUPPKEY)] {0.001998, 0.026} symmjoin[(.pPARTKEY = ..lPARTKEY)] {1.24875e-05, 0.0012875} symmjoin[(.psPARTKEY = ..lPARTKEY)] {3.996e-06, 0.000412} symmjoin[(.oORDERKEY = ..lORDERKEY)] {3.996e-06, 0.00042}  filter[(.psSUPPKEY = .lSUPPKEY)] {2.3976e-05, 0.000416}  filter[(.pNAME contains "green")] {0.00624375, 0.6375}  extend[Nation: .nNAME, Oyear: year_of(.oORDERDATE), Amount: ((.lEXTENDEDPRICE * (1 - .lDISCOUNT)) - (.psSUPPLYCOST * .lQUANTITY))] project[Nation, Oyear, Amount]  sortby[Nation asc, Oyear asc] groupby[Nation, Oyear; Sumprofit: group feed  sum[Amount] ]project[Nation, Oyear, Sumprofit]  sortby[Nation asc, Oyear desc]  consume
\end{lstlisting}

\begin{tikzpicture}
\begin{axis}[
x tick label style={
/pgf/number format/1000 sep=},
xtick=data,
ylabel=Millisekunden,
scaled ticks=base 10:0,
xticklabels={A kalt,A warm,B kalt,B warm},
enlargelimits=0.10,
legend style={at={(1.65,0.5)},
area legend,
anchor=east,legend columns=1},
ybar stacked,
]
\addplot coordinates {(0,	6154	)(1,	1	)(2,	1	)(3,	1	)};
\addplot coordinates {(0,	0	)(1,	0	)(2,	3	)(3,	3	)};
\addplot coordinates {(0,	0	)(1,	1	)(2,	231	)(3,	239	)};
\addplot coordinates {(0,	112	)(1,	114	)(2,	5515	)(3,	5510	)};
\legend{Rewrite,Lookup,QueryToPlan,Execute}
\end{axis}
\end{tikzpicture}

\begin{figure}
\begin{tikzpicture}
\begin{axis}[
x tick label style={
/pgf/number format/1000 sep=},
xtick=data,
ylabel=Sekunden,
xlabel=Skalierungsfaktor,
xlabel style={yshift=-2.5em},
%xticklabels={0.00},
enlargelimits=0.10,
legend style={at={(1.65,0.5)},
anchor=east,legend columns=1},
scaled x ticks=base 10:0,
sharp plot
]
\addplot coordinates {(0.0008,	0.856	)(0.0016,	445.54	)(0.0032,	1776.867	)(0.0064,	7127.544	)};
\addplot coordinates {(0.0008,	0.227	)(0.0016,	0.237	)(0.0032,	0.284	)(0.0064,	0.313	)};
\addplot coordinates {(0.0008,	111.962	)(0.0016,	443.399	)(0.0032,	1773.326	)(0.0064,	7148.13	)};
\addplot coordinates {(0.0008,	111.574	)(0.0016,	446.848	)(0.0032,	1777.87	)(0.0064,	7055.378	)};
\legend{entschachtelt kalt, entschachtelt warm, iterativ kalt, iterativ warm}
\end{axis}
\end{tikzpicture}
\caption{Laufzeit von Q9 für die Ausführungstrategien nach Skalierungsfaktor}
\label{plot:Q9 line}
\end{figure}

\subsection{TPC-D Q15}
Diese Abfrage ermittelt den Top-Lieferanten. Es wird der Lieferant ermittelt, der das meiste zum Umsatz im gewählten Quartal beigetragen hat, gibt es mehrere, so werden sie nach Lieferantennummer geordnet angezeigt.
\begin{lstlisting}[caption=Abfrage Q15] 
select
	[ssuppkey, sname, saddress, 
	sphone, total_revenue]
from [supplier, revenue]
where
	[ssuppkey = supplier_no,
	total_revenue = (select max(total_revenue) from revenue)]
orderby [ssuppkey]
\end{lstlisting}

Da \textsc{Secondo} keine Views unterstützt, wird hier eine temporäre Tabelle angelegt.
\begin{lstlisting}[caption=Definition von revenue]
select
	[lsuppkey as supplier_no, 
	sum(lextendedprice* (1-ldiscount))as total_revenue]
from 
	lineitem 
where
	[lshipdate>=instant("1996-01-01"), 
	lshipdate<theInstant(
		year_of(instant("1996-01-01")), 
		month_of(instant("1996-01-01"))+3, 
		day_of(instant("1996-01-01"))
	)]
groupby	[lsuppkey]
\end{lstlisting}

\begin{lstlisting}[caption=Entschachtelte Variante von Q15]
select
	[ssuppkey, 
	sname, 
	saddress, 
	sphone, 
	total_revenue]
from [supplier, revenue]
where
	[ssuppkey=supplier_no, 
	total_revenue=678596.0]
orderby	[ssuppkey]
\end{lstlisting}

\begin{lstlisting}[caption=Q15 ausführbare Syntax entschachtelt]
SUPPLIER feedproject[sADDRESS, sNAME, sPHONE, sSUPPKEY]  revenue feedproject[Supplier_no, Total_revenue]  filter[(.Total_revenue = 645989.2892999999
)] {0.124875, 12.125}  sortmergejoin[sSUPPKEY , Supplier_no] {0.124875, 1.57812} project[sSUPPKEY, sNAME, sADDRESS, sPHONE, Total_revenue]  sortby[sSUPPKEY asc]  consume
\end{lstlisting}

\begin{lstlisting}[caption=Q15 ausführbare Syntax geschachtelt]
SUPPLIER feedproject[sADDRESS, sNAME, sPHONE, sSUPPKEY]  revenue feedproject[Supplier_no, Total_revenue]  filter[fun (alias5: TUPLE) (attr(alias5, Total_revenue) = revenue  feed {r}  max[Total_revenue_r] )] {0.124875, 13}  sortmergejoin[sSUPPKEY , Supplier_no] {0.124875, 1.57812} project[sSUPPKEY, sNAME, sADDRESS, sPHONE, Total_revenue]  sortby[sSUPPKEY asc]  consume
\end{lstlisting}

\begin{tikzpicture}
\begin{axis}[
x tick label style={
/pgf/number format/1000 sep=},
xtick=data,
ylabel=Millisekunden,
scaled ticks=base 10:0,
xticklabels={A kalt,A warm,B kalt,B warm},
enlargelimits=0.10,
legend style={at={(1.65,0.5)},
area legend,
anchor=east,legend columns=1},
ybar stacked,
]
\addplot coordinates {(0,	62	)(1,	1	)(2,	1	)(3,	1	)};
\addplot coordinates {(0,	0	)(1,	0	)(2,	378	)(3,	376	)};
\addplot coordinates {(0,	721	)(1,	347	)(2,	3	)(3,	3	)};
\addplot coordinates {(0,	107	)(1,	86	)(2,	98	)(3,	123	)};
\legend{Rewrite,Lookup,QueryToPlan,Execute}
\end{axis}
\end{tikzpicture}

\begin{figure}
\begin{tikzpicture}
\begin{axis}[
x tick label style={
/pgf/number format/1000 sep=},
xtick=data,
ylabel=Sekunden,
xlabel=Skalierungsfaktor,
xlabel style={yshift=-2.5em},
xticklabels={,,,,0.0016,0.0032,0.0064,0.0128},
enlargelimits=0.10,
ymin=0,
legend style={at={(1.65,0.5)},
anchor=east,legend columns=1},
scaled x ticks=base 10:0,
sharp plot
]
\addplot coordinates {(0.0008,	0.744	)(0.0016,	0.919	)(0.0032,	1.056	)(0.0064,	2.038	)(0.0128,	5.391	)(0.0256,	9.232	)(0.0512,	9.372	)(0.1024,	23.601	)};
\addplot coordinates {(0.0008,	0.566	)(0.0016,	0.722	)(0.0032,	0.924	)(0.0064,	1.247	)(0.0128,	2.302	)(0.0256,	5.901	)(0.0512,	9.223	)(0.1024,	18.387	)};
\addplot coordinates {(0.0008,	0.601	)(0.0016,	0.68	)(0.0032,	0.918	)(0.0064,	1.262	)(0.0128,	2.238	)(0.0256,	5.875	)(0.0512,	9.868	)(0.1024,	20.801	)};
\addplot coordinates {(0.0008,	0.613	)(0.0016,	0.687	)(0.0032,	0.896	)(0.0064,	1.279	)(0.0128,	2.354	)(0.0256,	5.901	)(0.0512,	9.901	)(0.1024,	20.885	)};
\legend{entschachtelt kalt, entschachtelt warm, iterativ kalt, iterativ warm}
\end{axis}
\end{tikzpicture}
\caption{Laufzeit von Q15 für die Ausführungstrategien nach Skalierungsfaktor}
\label{plot:Q15 line}
\end{figure}

\subsection{TPC-D Q16}
Mit dieser Abfrage wird die Anzahl der Lieferanten für bestimmte Teile ermittelt. Die Teile dürfen nicht von einem bestimmten Typ sein, nicht von einer bestimmten Marke und es darf keine Kundenbeschwerden über den Lieferanten geben.
\begin{lstlisting}[caption=Abfrage Q16]
select
	[pbrand, 
	ptype, 
	psize,
	count(distinct pssuppkey) as suppliercnt]
from [partsupp, part]
where
	[ppartkey = pspartkey,
	not(pbrand = "Brand#45"),
	not(ptype starts "MEDIUM POLISHED"),
	psize in (49, 14, 23, 45, 19, 3, 36, 9),
	pssuppkey not in(
		select 
			ssuppkey
		from 
			supplier
		where
    	[scomment contains "Customer",
			 scomment contains "Complaints"]
		)]
groupby [pbrand, ptype, psize]
orderby	
	[suppliercnt desc, 
	pbrand, ptype, psize]
\end{lstlisting}

\begin{lstlisting}[caption=Q16 ausführbare Syntax]
PART feedproject[pBRAND, pPARTKEY, pSIZE, pTYPE] PARTSUPP feedproject[psPARTKEY, psSUPPKEY] symmjoin[(.pPARTKEY = ..psPARTKEY)] {2.4975e-05, 0.0012875}  filter[fun (alias7: TUPLE) not((attr(alias7, psSUPPKEY) in SUPPLIER feedproject[sCOMMENT, sSUPPKEY]  filter[(.sCOMMENT contains "Complaints")] {0.124875, 12.25}  filter[(.sCOMMENT contains "Customer")] {0.124875, 12.75}  projecttransformstream[sSUPPKEY]  collect_set ))] {0.0124875, 0.175}  filter[.pSIZE in [const set(int) value (49 14 23 45 19 3 36 9)]] {0.00624375, 0.61875}  filter[not((.pBRAND = "Brand#45"))] {0.04995, 0.61875}  filter[not((.pTYPE starts "MEDIUM POLISHED"))] {0.04995, 0.6625}  sortby[pBRAND asc, pTYPE asc, pSIZE asc] groupby[pBRAND, pTYPE, pSIZE; Suppliercnt: group feed  filter[not(isempty(.psSUPPKEY))] project[psSUPPKEY]  sort  rdup  count ]project[pBRAND, pTYPE, pSIZE, Suppliercnt]  sortby[Suppliercnt desc, pBRAND asc, pTYPE asc, pSIZE asc]  consume
\end{lstlisting}

\begin{tikzpicture}
\begin{axis}[
x tick label style={
/pgf/number format/1000 sep=},
xtick=data,
ylabel=Millisekunden,
scaled ticks=base 10:0,
xticklabels={A kalt,A warm,B kalt,B warm},
enlargelimits=0.10,
legend style={at={(1.65,0.5)},
area legend,
anchor=east,legend columns=1},
ybar stacked,
]
\addplot coordinates {(0,	2	)(1,	1	)(2,	2	)(3,	2	)};
\addplot coordinates {(0,	3	)(1,	3	)(2,	3	)(3,	3	)};
\addplot coordinates {(0,	23	)(1,	24	)(2,	29	)(3,	23	)};
\addplot coordinates {(0,	1111	)(1,	1107	)(2,	1141	)(3,	1119	)};
\legend{Rewrite,Lookup,QueryToPlan,Execute}
\end{axis}
\end{tikzpicture}

\begin{figure}
\begin{tikzpicture}
\begin{axis}[
x tick label style={
/pgf/number format/1000 sep=},
xtick=data,
ylabel=Sekunden,
xlabel=Skalierungsfaktor,
xlabel style={yshift=-2.5em},
xticklabels={,,,,0.0016,0.0032,0.0064,0.0128},
enlargelimits=0.10,
legend style={at={(1.65,0.5)},
anchor=east,legend columns=1},
scaled x ticks=base 10:0,
sharp plot
]
\addplot coordinates {(0.0004,	0.432	)(0.0008,	0.856	)(0.0016,	2.43	)(0.0032,	8.245	)(0.0064,	28.507	)(0.0128,	110.925	)};
\addplot coordinates {(0.0004,	0.441	)(0.0008,	0.808	)(0.0016,	2.344	)(0.0032,	8.153	)(0.0064,	28.099	)(0.0128,	111.069	)};
\addplot coordinates {(0.0004,	0.439	)(0.0008,	0.787	)(0.0016,	2.327	)(0.0032,	8.164	)(0.0064,	28.144	)(0.0128,	110.699	)};
\addplot coordinates {(0.0004,	0.461	)(0.0008,	0.804	)(0.0016,	2.347	)(0.0032,	8.123	)(0.0064,	27.917	)(0.0128,	110.679	)};
\legend{entschachtelt kalt, entschachtelt warm, iterativ kalt, iterativ warm}
\end{axis}
\end{tikzpicture}
\caption{Laufzeit von Q16 für die Ausführungstrategien nach Skalierungsfaktor}
\label{plot:Q16 line}
\end{figure}

\subsection{TPC-D Q17}
Diese Abfrage beantwortet, wieviel Umsatz verloren ginge, falls Bestellungen über kleine Mengen bestimmter Teile nicht mehr ausgeführt würden.
\begin{lstlisting}[caption=Abfrage Q17]
select
	[sum(lextendedprice / 7.0) as avg_yearly]		
from
	[lineitem, part]
where
	[ppartkey = lpartkey,
	 pbrand = "Brand#23",
	 pcontainer = "MED BOX",
	 lquantity < (
		select
			avg(0.2 * l1:lquantity)
		from
			[lineitem as l1]
		where
			[l1:lpartkey = ppartkey]
	)]
groupby	[]
\end{lstlisting}

\begin{lstlisting}[caption=TempRel1]
select distinct
	[lpartkey, 
	ppartkey]
from
	[lineitem,
	part]
\end{lstlisting}

\begin{lstlisting}[caption=TempRel2]
select [l1:lpartkey, l1:lquantity]
from [lineitem as l1]
\end{lstlisting}

\begin{lstlisting}[caption=TempRel3]
select
	[lpartkey_l1, 
	avg(0.2*lquantity_l1)as var1]
from
	[trelxx1, 
	trelxx2]
where
	[lpartkey_l1 = ppartkey]
groupby 
	lpartkey_l1
\end{lstlisting}

\begin{lstlisting}[caption=Entschachtelte Variante von Q17]
select
	[sum(lextendedprice/7.0)as avg_yearly]
from
	[lineitem, 
	part, 
	trelxx3 as alias1]
where
	[ppartkey = lpartkey, 
	pbrand = "Brand#23", 
	pcontainerv = "MED BOX", 
	ppartkey = alias1:lpartkey_l1, 
	lquantity < alias1:var1]
groupby []
\end{lstlisting}

\begin{lstlisting}[caption=Q17 ausführbare Syntax entschachtelt]
PART feedproject[pBRAND, pCONTAINER, pPARTKEY] trelxx8 feedproject[lPARTKEY_l1, Var1] {alias8} symmjoin[(.pPARTKEY = ..lPARTKEY_l1_alias8)] {3.90234e-05, 0.00453125}  filter[(.pBRAND = "Brand#23")] {0.00624375, 0.6125}  filter[(.pCONTAINER = "MED BOX")] {0.00624375, 0.64375} LINEITEM feedproject[lEXTENDEDPRICE, lPARTKEY, lQUANTITY] symmjoin[(.pPARTKEY = ..lPARTKEY)] {1.24875e-05, 0.0012875}  filter[(.lQUANTITY < .Var1_alias8)] {0.00014985, 0.0013} groupby[; Avg_yearly: group feed  extend[Var1: (.lEXTENDEDPRICE / 7.0000000000
)]  sum[Var1] ]project[Avg_yearly]  consume
\end{lstlisting}

\begin{lstlisting}[caption=Q17 ausführbare Syntax geschachtelt]
 PART feedproject[pBRAND, pCONTAINER, pPARTKEY]  filter[(.pBRAND = "Brand#23")] {0.00624375, 0.6125}  filter[(.pCONTAINER = "MED BOX")] {0.00624375, 0.64375} LINEITEM feedproject[lEXTENDEDPRICE, lPARTKEY, lQUANTITY] symmjoin[(.pPARTKEY = ..lPARTKEY)] {1.24875e-05, 0.0012875}  filter[fun (alias10: TUPLE) (attr(alias10, lQUANTITY) < LINEITEM  feed {l1}  filter[(.lPARTKEY_l1 = attr(alias10, pPARTKEY))]  extend[var1: (0.2000000000
 * .lQUANTITY_l1)]  avg[var1] )] {1.24875e-05, 0.00185} groupby[; Avg_yearly: group feed  extend[Var1: (.lEXTENDEDPRICE / 7.0000000000
)]  sum[Var1] ]project[Avg_yearly]  consume
\end{lstlisting}

\begin{tikzpicture}
\begin{axis}[
x tick label style={
/pgf/number format/1000 sep=},
xtick=data,
ylabel=Millisekunden,
scaled ticks=base 10:0,
xticklabels={A kalt,A warm,B kalt,B warm},
enlargelimits=0.10,
legend style={at={(1.65,0.5)},
area legend,
anchor=east,legend columns=1},
ybar stacked,
]
\addplot coordinates {(0,	5943	)(1,	1	)(2,	1	)(3,	1	)};
\addplot coordinates {(0,	2	)(1,	2	)(2,	190	)(3,	2	)};
\addplot coordinates {(0,	1085	)(1,	22	)(2,	8	)(3,	8	)};
\addplot coordinates {(0,	266	)(1,	264	)(2,	283	)(3,	268	)};
\legend{Rewrite,Lookup,QueryToPlan,Execute}
\end{axis}
\end{tikzpicture}

\begin{figure}
\begin{tikzpicture}
\begin{axis}[
x tick label style={
/pgf/number format/1000 sep=},
xtick=data,
ylabel=Sekunden,
xlabel=Skalierungsfaktor,
xlabel style={yshift=-2.5em},
xticklabels={,,,,0.0016,0.0032,0.0064,0.0128},
enlargelimits=0.10,
legend style={at={(1.65,0.5)},
anchor=east,legend columns=1},
scaled x ticks=base 10:0,
sharp plot
]
\addplot coordinates {(0.0008,	10.945	)(0.0016,	20.15	)(0.0032,	54.489	)(0.0064,	218.186	)(0.0128,	842.648	)};
\addplot coordinates {(0.0008,	1.182	)(0.0016,	1.169	)(0.0032,	2.197	)(0.0064,	7.384	)(0.0128,	28.798	)};
\addplot coordinates {(0.0008,	1.387	)(0.0016,	1.2	)(0.0032,	0.572	)(0.0064,	0.85	)(0.0128,	68.046	)};
\addplot coordinates {(0.0008,	1.199	)(0.0016,	1.167	)(0.0032,	0.467	)(0.0064,	0.657	)(0.0128,	67.591	)};
\legend{entschachtelt kalt, entschachtelt warm, iterativ kalt, iterativ warm}
\end{axis}
\end{tikzpicture}
\caption{Laufzeit von Q17 für die Ausführungstrategien nach Skalierungsfaktor}
\label{plot:Q17 line}
\end{figure}

\subsection{TPC-D Q20}
Identifiziert Lieferanten, die einen Überschuss an bestimmten Teilen haben. Überschuss ist hier definiert als mehr als 50\% der von einem Lieferanten versandten Teile über ein Jahr. Nur Teile mit einem vorgegebenen Namensbestandteil werden betrachtet.
\begin{lstlisting}[caption=Abfrage Q20]
select [sname, saddress]
from [supplier, nation]
where
	[ssuppkey in (
		select [pssuppkey]
		from [partsupp]
		where
			[pspartkey in (
				select ppartkey
				from part
				where tostring(pname) starts "forest"
			),
			psavailqty > (
				select sum(lquantity * 0.5)
				from lineitem
				where
					[lpartkey = pspartkey,
					lsuppkey = pssuppkey,
					lshipdate >= instant("1994-01-01"),
					lshipdate < theInstant(
						year_of(instant("1994-01-01")) + 1, 
					 	month_of(instant("1994-01-01")), 
					 	day_of(instant("1994-01-01"))
					 )]
			)]
		),
	 snationkey = nnationkey,
	 nname = "CANADA"]
orderby	[sname]
\end{lstlisting}

\begin{lstlisting}[caption=TempRel1]
select distinct [pspartkey, pssuppkey]
from partsupp
\end{lstlisting}

\begin{lstlisting}[caption=TempRel2]
select [lpartkey, lquantity, lshipdate, lsuppkey]
from lineitem
\end{lstlisting}

\begin{lstlisting}[caption=TempRel3]
select
	[lpartkey, 
	sum(lquantity*0.5)as var2]
from [trelxx1, trelxx2]
where [lpartkey = pspartkey]
groupby lpartkey
\end{lstlisting}

\begin{lstlisting}[caption=Entschachtelte Variante von Abfrage Q20]
select [sname, saddress]
from
	[supplier, nation, 
	partsupp, part, 
	trelxx3 as alias1]
where
	[ssuppkey = pssuppkey, 
	pspartkey = ppartkey, 
	tostring(pname) starts "forest", 
	pspartkey = alias1:lpartkey, 
	psavailqty > alias1:var1, 
	snationkey = nnationkey, 
	nname = "CANADA"]
orderby [sname]
\end{lstlisting}

\begin{lstlisting}[caption=Q20 ausführbare Syntax entschachtelt]
SUPPLIER feedproject[sADDRESS, sNAME, sNATIONKEY, sSUPPKEY]  NATION feedproject[nNAME, nNATIONKEY]  sortmergejoin[sNATIONKEY , nNATIONKEY] {0.004995, 0.495}  filter[(.nNAME = "CANADA")] {0.03996, 4.04} PARTSUPP feedproject[psAVAILQTY, psPARTKEY, psSUPPKEY] symmjoin[(.sSUPPKEY = ..psSUPPKEY)] {0.001998, 0.02875} PART feedproject[pNAME, pPARTKEY] symmjoin[(.psPARTKEY = ..pPARTKEY)] {1.24875e-05, 0.0013125} trelxx11 feedproject[lPARTKEY, Var2] {alias13} symmjoin[(.psPARTKEY = ..lPARTKEY_alias13)] {1.24875e-05, 0.001325}  filter[(.psAVAILQTY > .Var2_alias13)] {0.000786713, 0.0014125}  filter[(tostring(.pNAME) starts "forest")] {0.00624375, 0.68125} project[sNAME, sADDRESS]  sortby[sNAME asc]  consume
\end{lstlisting}

\begin{lstlisting}[caption=Q20 ausführbare Syntax geschachtetl]
SUPPLIER feedproject[sADDRESS, sNAME, sNATIONKEY, sSUPPKEY]  NATION feedproject[nNAME, nNATIONKEY]  sortmergejoin[sNATIONKEY , nNATIONKEY] {0.004995, 0.495}  filter[(.nNAME = "CANADA")] {0.03996, 4.04}  filter[fun (alias17: TUPLE) (attr(alias17, sSUPPKEY) in PARTSUPP feedproject[psAVAILQTY, psPARTKEY, psSUPPKEY]  filter[fun (alias18: TUPLE) (attr(alias18, psPARTKEY) in PART feedproject[pNAME, pPARTKEY]  filter[(tostring(.pNAME) starts "forest")] {0.00624375, 0.68125}  projecttransformstream[pPARTKEY]  collect_set )] {0.00156094, 0.173437}  filter[fun (alias19: TUPLE) (attr(alias19, psAVAILQTY) > LINEITEM feedproject[lPARTKEY, lQUANTITY, lSHIPDATE, lSUPPKEY]  filter[(.lSHIPDATE >= instant("1994-01-01"))] {0.002997, 0.0525}  filter[(.lSHIPDATE < theInstant((year_of(instant("1994-01-01")) + 1), month_of(instant("1994-01-01")), day_of(instant("1994-01-01"))))] {0.0024975, 0.0555}  filter[(.lPARTKEY = attr(alias19, psPARTKEY))]  filter[(.lSUPPKEY = attr(alias19, psSUPPKEY))]  extend[var1: (.lQUANTITY * 0.5000000000
)]  sum[var1] )] {0.0124875, 0.184375}  projecttransformstream[psSUPPKEY]  collect_set )] {0.124875, 19.5} project[sNAME, sADDRESS]  sortby[sNAME asc]  consume
\end{lstlisting}

\begin{tikzpicture}
\begin{axis}[
x tick label style={
/pgf/number format/1000 sep=},
xtick=data,
ylabel=Millisekunden,
scaled ticks=base 10:0,
xticklabels={A kalt,A warm,B kalt,B warm},
enlargelimits=0.10,
legend style={at={(1.65,0.5)},
area legend,
anchor=east,legend columns=1},
ybar stacked,
]
\addplot coordinates {(0,	19534	)(1,	1	)(2,	4	)(3,	5	)};
\addplot coordinates {(0,	2	)(1,	0	)(2,	1784	)(3,	6	)};
\addplot coordinates {(0,	1297	)(1,	150	)(2,	8	)(3,	8	)};
\addplot coordinates {(0,	228	)(1,	216	)(2,	366	)(3,	280	)};
\legend{Rewrite,Lookup,QueryToPlan,Execute}
\end{axis}
\end{tikzpicture}

\begin{figure}
\begin{tikzpicture}
\begin{axis}[
x tick label style={
/pgf/number format/1000 sep=},
xtick=data,
ylabel=Sekunden,
xlabel=Skalierungsfaktor,
xlabel style={yshift=-2.5em},
xticklabels={,,,,0.0016,0.0032,0.0064,0.0128},
enlargelimits=0.10,
legend style={at={(1.65,0.5)},
anchor=east,legend columns=1},
scaled x ticks=base 10:0,
sharp plot
]
\addplot coordinates {(0.0008,	12.294	)(0.0016,	50.163	)(0.0032,	200.383	)(0.0064,	811.211	)(0.0128,	3239.196	)};
\addplot coordinates {(0.0008,	0.348	)(0.0016,	0.594	)(0.0032,	1.289	)(0.0064,	1.433	)(0.0128,	5.977	)};
\addplot coordinates {(0.0008,	0.326	)(0.0016,	8.267	)(0.0032,	59.713	)(0.0064,	266.071	)(0.0128,	1665.556	)};
\addplot coordinates {(0.0008,	0.283	)(0.0016,	8.329	)(0.0032,	60.031	)(0.0064,	263.667	)(0.0128,	1684.976	)};
\legend{entschachtelt kalt, entschachtelt warm, iterativ kalt, iterativ warm}
\end{axis}
\end{tikzpicture}
\caption{Laufzeit von Q20 für die Ausführungstrategien nach Skalierungsfaktor}
\label{plot:Q20 line}
\end{figure}

\subsection{TPC-D Q21}
Diese Abfrage ermittelt Lieferanten die bei einer Mehr-Lieferanten Bestellung nicht pünktlich geliefert haben.
\begin{lstlisting}[caption=Abfrage Q21]
select [sname, count(*) as numwait]
from 
	[supplier, lineitem as l1,
	 orders, nation]
where
	[ssuppkey = l1:lsuppkey,
	oorderkey = l1:lorderkey,
	oorderstatus = "F",
	l1:lreceiptdate > l1:lcommitdate,
	exists(
		select *
		from lineitem as l2
		where
			[l2:lorderkey = l1:lorderkey,
			not(l2:lsuppkey = l1:lsuppkey)]
	),
	not(exists(
		select *
		from lineitem as l3
		where
			[l3:lorderkey = l1:lorderkey,
			not(l3:lsuppkey = l1:lsuppkey),
			l3:lreceiptdate > l3:lcommitdate]
	)),
	snationkey = nnationkey,
	nname = "SAUDI ARABIA"]
groupby	[sname]
orderby	[numwait desc, sname] 
first 100
\end{lstlisting}

\begin{lstlisting}[caption=TempRel1]
select distinct [l1:lorderkey, l1:lsuppkey]
from lineitem as l1
\end{lstlisting}

\begin{lstlisting}[caption=TempRel2]
select [l2:lorderkey, l2:lsuppkey]
from lineitem as l2
\end{lstlisting}

\begin{lstlisting}[caption=TempRel3]
trelxx1  feed 
trelxx2  feed  
smouterjoin[lORDERKEY_l1,lORDERKEY_l2] 
extend[var1: ifthenelse(isempty(.lORDERKEY_l2), 0, 1)] 
sortby[lORDERKEY_l1 asc] 
groupby[lORDERKEY_l1;Var1: group feed sum[var1]] 
projectextend[Var1; lORDERKEY_l2: .lORDERKEY_l1] 
consume
\end{lstlisting}

\begin{lstlisting}[caption=TempRel2 die zweite]
select [l3:lorderkey, l3:lsuppkey]
from [lineitem as l3]
where [l3:lreceiptdate > l3:lcommitdate]
\end{lstlisting}

\begin{lstlisting}[caption=TempRel3 die zweite]
trelxx1  feed 
trelxx4  feed 
smouterjoin[lORDERKEY_l1,lORDERKEY_l3] 
extend[var1: ifthenelse(isempty(.lORDERKEY_l3), 0, 1)] 
sortby[lORDERKEY_l1 asc] 
groupby[lORDERKEY_l1;Var1: group feed sum[var1]] 
projectextend[Var1; lORDERKEY_l3: .lORDERKEY_l1] 
consume
\end{lstlisting}

\begin{lstlisting}[caption=Entschachtelte Variante von Q21]
select [sname, count(*)as numwait]
from
	[supplier, lineitem as l1, 
	orders, nation, 
	trelxx3 as alias1, 
	trelxx5 as alias2]
where
	[ssuppkey = l1:lsuppkey, 
	oorderkey = l1:lorderkey, 
	oorderstatus="F", 
	l1:lreceiptdate > l1:lcommitdate, 
	l1:lorderkey = alias1:lorderkey_l2, 
	0 < alias1:var1, 
	l1:lorderkey = alias2:lorderkey_l3, 
	0 = alias2:var2, 
	snationkey = nnationkey, 
	nname = "SAUDI ARABIA"]
groupby	[sname]
orderby [numwait desc, sname]
first 100
\end{lstlisting}

\begin{lstlisting}[caption=Q21 ausführbare Syntax entschachtelt]
ORDERS feedproject[oORDERKEY, oORDERSTATUS] SUPPLIER feedproject[sNAME, sNATIONKEY, sSUPPKEY]  NATION feedproject[nNAME, nNATIONKEY]  sortmergejoin[sNATIONKEY , nNATIONKEY] {0.004995, 0.495}  filter[(.nNAME = "SAUDI ARABIA")] {0.03996, 4.2} LINEITEM feedproject[lCOMMITDATE, lORDERKEY, lRECEIPTDATE, lSUPPKEY] {l1} symmjoin[(.sSUPPKEY = ..lSUPPKEY_l1)] {0.001998, 0.04175} trelxx16 feedproject[lORDERKEY_l3, Var1] {alias21} symmjoin[(.lORDERKEY_l1 = ..lORDERKEY_l3_alias21)] {3.996e-06, 0.000448} symmjoin[(.oORDERKEY = ..lORDERKEY_l1)] {3.996e-06, 0.00048} trelxx14 feedproject[lORDERKEY_l2, Var2] {alias20} symmjoin[(.lORDERKEY_l1 = ..lORDERKEY_l2_alias20)] {3.996e-06, 0.000496}  filter[(.lRECEIPTDATE_l1 > .lCOMMITDATE_l1)] {0.0034965, 0.059}  filter[(.oORDERSTATUS = "F")] {0.00333, 0.0833333}  filter[(0 = .Var1_alias21)] {0.000835983, 0.0878661}  filter[(0 < .Var2_alias20)] {0.00668787, 0.0979079}  sortby[sNAME asc] groupby[sNAME; Numwait: group feed  count ]project[sNAME, Numwait]  sortby[Numwait desc, sNAME asc]  head[100]  consume
\end{lstlisting}

\begin{lstlisting}[caption=Q21 ausführbare Syntax geschachtelt]
 ORDERS feedproject[oORDERKEY, oORDERSTATUS] SUPPLIER feedproject[sNAME, sNATIONKEY, sSUPPKEY]  NATION feedproject[nNAME, nNATIONKEY]  sortmergejoin[sNATIONKEY , nNATIONKEY] {0.004995, 0.495}  filter[(.nNAME = "SAUDI ARABIA")] {0.03996, 4.2} LINEITEM feedproject[lCOMMITDATE, lORDERKEY, lRECEIPTDATE, lSUPPKEY] {l1} symmjoin[(.sSUPPKEY = ..lSUPPKEY_l1)] {0.001998, 0.04175} symmjoin[(.oORDERKEY = ..lORDERKEY_l1)] {3.996e-06, 0.00048}  filter[(.lRECEIPTDATE_l1 > .lCOMMITDATE_l1)] {0.0034965, 0.059}  filter[fun (alias24: TUPLE) (0 < LINEITEM  feed {l2}  filter[(.lORDERKEY_l2 = attr(alias24, lORDERKEY_l1))]  filter[not((.lSUPPKEY_l2 = attr(alias24, lSUPPKEY_l1)))]  count )] {0.0004995, 0.0645}  filter[fun (alias25: TUPLE) (0 = LINEITEM feedproject[lCOMMITDATE, lORDERKEY, lRECEIPTDATE, lSUPPKEY] {l3}  filter[(.lRECEIPTDATE_l3 > .lCOMMITDATE_l3)] {0.0034965, 0.059}  filter[(.lORDERKEY_l3 = attr(alias25, lORDERKEY_l1))]  filter[not((.lSUPPKEY_l3 = attr(alias25, lSUPPKEY_l1)))]  count )] {0.003996, 0.061}  filter[(.oORDERSTATUS = "F")] {0.00333, 0.0833333}  sortby[sNAME asc] groupby[sNAME; Numwait: group feed  count ]project[sNAME, Numwait]  sortby[Numwait desc, sNAME asc]  head[100]  consume
\end{lstlisting}

\begin{tikzpicture}
\begin{axis}[
x tick label style={
/pgf/number format/1000 sep=},
xtick=data,
ylabel=Millisekunden,
scaled ticks=base 10:0,
xticklabels={A kalt,A warm,B kalt,B warm},
enlargelimits=0.10,
legend style={at={(1.65,0.5)},
area legend,
anchor=east,legend columns=1},
ybar stacked,
]
\addplot coordinates {(0,	2662	)(1,	1	)(2,	2	)(3,	1	)};
\addplot coordinates {(0,	2	)(1,	2	)(2,	358	)(3,	2	)};
\addplot coordinates {(0,	3858	)(1,	1730	)(2,	421	)(3,	449	)};
\addplot coordinates {(0,	478	)(1,	475	)(2,	451	)(3,	503	)};
\legend{Rewrite,Lookup,QueryToPlan,Execute}
\end{axis}
\end{tikzpicture}

\begin{figure}
\begin{tikzpicture}
\begin{axis}[
x tick label style={
/pgf/number format/1000 sep=},
xtick=data,
ylabel=Sekunden,
xlabel=Skalierungsfaktor,
xlabel style={yshift=-2.5em},
xticklabels={,,,,0.0016,0.0032,0.0064,0.0128},
enlargelimits=0.10,
legend style={at={(1.65,0.5)},
anchor=east,legend columns=1},
scaled x ticks=base 10:0,
sharp plot
]
\addplot coordinates {(0.0008,	3.752	)(0.0016,	5.822	)(0.0032,	7.092	)(0.0064,	11.843	)(0.0128,	81.745	)};
\addplot coordinates {(0.0008,	1.601	)(0.0016,	1.594	)(0.0032,	1.882	)(0.0064,	2.142	)(0.0128,	62.853	)};
\addplot coordinates {(0.0008,	0.747	)(0.0016,	0.926	)(0.0032,	0.952	)(0.0064,	1.393	)(0.0128,	957.265	)};
\addplot coordinates {(0.0008,	0.686	)(0.0016,	0.8	)(0.0032,	0.996	)(0.0064,	1.32	)(0.0128,	960.547	)};
\legend{entschachtelt kalt, entschachtelt warm, iterativ kalt, iterativ warm}
\end{axis}
\end{tikzpicture}
\caption{Laufzeit von Q21 für die Ausführungstrategien nach Skalierungsfaktor}
\label{plot:Q21 line}
\end{figure}

\subsection{TPC-D Q22}
Diese Abfrage ermittelt, wieviele Kunden in den letzten 7 Jahren keine Bestellung getätigt haben, aber dennoch einen überdurchschnittlichen Umsatz auf ihrem Konto. Gruppiert nach \enquote{Länderschlüssel}, wobei Länderschlüssel als die ersten zwei Ziffern der Telefonnummer definiert ist.
\begin{lstlisting}[caption=Abfrage Q22]
select
	[cntrycode,
	 count(*) as numcust,
	 sum(cacctbal) as totacctbal]
from (
	select
		[substr(cphone, 1, 2) as cntrycode, 
		cacctbal]
	from customer 
	where
		[substr(cphone, 1, 2) in ("13","35","31","23","29","30","18"),
		cacctbal > (
			select avg(c1:cacctbal)
			from customer as c1
			where
				[c1:cacctbal > 0.00,
				substr(c1:cphone, 1, 2) in ("13","35","31","23","29","30","18")]
		),
		not( exists(
			select *
			from orders
			where	ocustkey = ccustkey
		))]
	) as custsale
groupby	[cntrycode]
orderby	[cntrycode]
\end{lstlisting}

\begin{lstlisting}[caption=TempRel1]
select distinct [ccustkey]
from customer
\end{lstlisting}

\begin{lstlisting}[caption=TempRel2]
select [ocustkey]
from orders
\end{lstlisting}

\begin{lstlisting}[caption=TempRel3]
trelxx1  feed 
trelxx2  feed 
smouterjoin[cCUSTKEY,oCUSTKEY] 
extend[var1: ifthenelse(isempty(.oCUSTKEY), 0, 1)] 
sortby[cCUSTKEY asc] 
groupby[cCUSTKEY;Var1: group feed sum[var1]] 
projectextend[Var1; oCUSTKEY: .cCUSTKEY] 
consume
\end{lstlisting}

Da es sich bei der inneren Abfrage in dem ersten geschachtelten Prädikat um eine nicht-korrelierte Abfrage handelt, wird sie in der entschachtelten Variante durch den durch ihre Ausführung erhaltenenen Wert ersetzt.

\begin{lstlisting}[caption=FROM Nesting]
select
	[substr(cphone, 1, 2)as cntrycode, 
	cacctbal]
from [customer, trelxx3 as alias1]
where
	[substr(cphone, 1, 2) in ("13","35","31","23","29","30","18"), 
	cacctbal > 5527.01, 
	ccustkey = alias1:ocustkey, 
	0 = alias1:var1]
\end{lstlisting}

\begin{lstlisting}[caption=Entschachtelte Variante von Q22]
select
	[cntrycode, 
	count(*)as numcust, 
	sum(cacctbal)as totacctbal]
from trelxx4 
groupby	[cntrycode]
orderby	[cntrycode]
\end{lstlisting}

\begin{lstlisting}[caption=Q22 ausführbare Syntax entschachtelt]
trelxx20  feed  
sortby[Cntrycode asc] 
groupby[Cntrycode; Numcust: group feed  count , Totacctbal: group feed  sum[cACCTBAL] ]
project[Cntrycode, Numcust, Totacctbal]  
sortby[Cntrycode asc]  
consume
\end{lstlisting}

\begin{lstlisting}[caption=Q22 ausführbare Syntax geschachtelt]
CUSTOMER  feed  
filter[substr(.cPHONE, 1, 2) in [const set(string) value ("13" "35" "31" "23" "29" "30" "18")]] {0.01665, 0.883333}  
filter[
	fun (alias29: TUPLE) (
		attr(alias29, cACCTBAL) 
		> 
		CUSTOMER  feed {c1}  
		filter[substr(.cPHONE_c1, 1, 2) in [const set(string) value ("13" "35" "31" "23" "29" "30" "18")]] {0.01665, 0.883333}  
		filter[(.cACCTBAL_c1 > 0.0000000000)] {0.04995, 0.875}  
		avg[cACCTBAL_c1] 
	)] {0.0333, 0.941667}  
filter[
	fun (alias30: TUPLE) 
	not((
		ORDERS  feed  
		filter[(.oCUSTKEY = attr(alias30, cCUSTKEY))]  
		head[1]  
		count  = 1)
	)] {0.058275, 0.958333}  
extend[Cntrycode: substr(.cPHONE, 1, 2)] 
project[Cntrycode, cACCTBAL]  
sortby[Cntrycode asc] 
groupby[Cntrycode; Numcust: group feed  count , Totacctbal: group feed  sum[cACCTBAL] ]
project[Cntrycode, Numcust, Totacctbal]  sortby[Cntrycode asc]  
consume
\end{lstlisting}

\begin{tikzpicture}
\begin{axis}[
x tick label style={
/pgf/number format/1000 sep=},
xtick=data,
ylabel=Millisekunden,
scaled ticks=base 10:0,
xticklabels={A kalt,A warm,B kalt,B warm},
enlargelimits=0.10,
legend style={at={(1.65,0.5)},
area legend,
anchor=east,legend columns=1},
ybar stacked,
]
\addplot coordinates {(0,	2556	)(1,	1	)(2,	1	)(3,	1	)};
\addplot coordinates {(0,	0	)(1,	0	)(2,	320	)(3,	2	)};
\addplot coordinates {(0,	0	)(1,	0	)(2,	5	)(3,	5	)};
\addplot coordinates {(0,	106	)(1,	106	)(2,	588	)(3,	599	)};
\legend{Rewrite,Lookup,QueryToPlan,Execute}
\end{axis}
\end{tikzpicture}

\begin{figure}
\begin{tikzpicture}
\begin{axis}[
x tick label style={
/pgf/number format/1000 sep=},
xtick=data,
ylabel=Sekunden,
xlabel=Skalierungsfaktor,
xlabel style={yshift=-2.5em},
xticklabels={,,,,0.0016,0.0032,0.0064,0.0128},
enlargelimits=0.10,
legend style={at={(1.65,0.5)},
anchor=east,legend columns=1},
scaled x ticks=base 10:0,
sharp plot
]
\addplot coordinates {(0.0008,	1.171	)(0.0016,	1.859	)(0.0032,	2.663	)(0.0064,	5.788	)(0.0128,	18.018	)};
\addplot coordinates {(0.0008,	0.204	)(0.0016,	0.221	)(0.0032,	0.27	)(0.0064,	0.266	)(0.0128,	0.353	)};
\addplot coordinates {(0.0008,	0.476	)(0.0016,	1.001	)(0.0032,	3.803	)(0.0064,	11.423	)(0.0128,	49.657	)};
\addplot coordinates {(0.0008,	0.435	)(0.0016,	0.981	)(0.0032,	3.71	)(0.0064,	10.525	)(0.0128,	49.663	)};
\legend{entschachtelt kalt, entschachtelt warm, iterativ kalt, iterativ warm}
\end{axis}
\end{tikzpicture}
\caption{Laufzeit von Q22 für die Ausführungstrategien nach Skalierungsfaktor}
\label{plot:Q22 line}
\end{figure}

\subsection{Laufzeit Übersicht}

\begin{tikzpicture}
\begin{axis}[
x tick label style={
xshift=1.4em, font=\footnotesize},
xtick=data,
ylabel=Sekunden,
xticklabels={Q2,Q4,Q7,
%Q9,
Q15,Q16,Q17,Q20,Q21,Q22},
scaled ticks=base 10:0,
enlargelimits=0.10,
legend style={at={(1.65,0.5)},
area legend,
anchor=east,legend columns=1},
ybar,
ybar interval=0.7,
]
\addplot coordinates {(1,	1.79	)(2,	7.03	)(3,	0.622	)
%(3,	112.071	)
(4,	0.744	)(5,	0.856	)(6,	10.945	)(7,	12.294	)(8,	3.752	)(9,	1.171	)};
\addplot coordinates {(1,	1.063	)(2,	6.277	)(3,	0.204	)
%(3,	0.227	)
(4,	0.566	)(5,	0.808	)(6,	1.182	)(7,	0.348	)(8,	1.601	)(9,	0.204	)};
\addplot coordinates {(1,	8.241	)(2,	3.313	)(3,	0.497	)
%(3,	111.962	)
(4,	0.601	)(5,	0.787	)(6,	1.387	)(7,	0.326	)(8,	0.747	)(9,	0.476	)};
\addplot coordinates {(1,	8.213	)(2,	3.297	)(3,	0.508	)
%(3,	111.574	)
(4,	0.613	)(5,	0.804	)(6,	1.199	)(7,	0.283	)(8,	0.686	)(9,	0.435	)};
\legend{entschachtelt kalt,entschachtelt warm,iterativ kalt,iterativ warm}
\end{axis}
\end{tikzpicture}

\begin{table}[h]
\centering
\begin{tabular}{@{}lrr@{}} \toprule
& \multicolumn{2}{c}{Laufzeit in s} \\ \cmidrule(l){2-3}
Abfrage Nr. & iterativ & entschachtelt\\ \midrule
Q2	&	3327	&	2863	\\
Q4	&	11947	&	5595	\\
Q7	&	1854	&	1538	\\
Q9	&	7055	&	6464	\\
Q15	&	2778	&	2051	\\
Q16	&	1880	&	1879	\\
Q17	&	8054	&	1172	\\
Q20	&	21834	&	2867	\\
Q21	&	8095	&	1973	\\
Q22	&	3404	&	1605	\\
\bottomrule\end{tabular}
  \caption{Laufzeit \enquote{kalt}}
  \label{tab_runtime_with_selectivity}
\end{table}

\begin{table}[h]
\centering
\begin{tabular}{@{}lrr@{}} \toprule
& \multicolumn{2}{c}{Laufzeit in s} \\ \cmidrule(l){2-3}
Abfrage Nr. & iterativ & entschachtelt\\ \midrule
Q2	&	2172	&	2702	\\
Q4	&	10343	&	5425	\\
Q7	&	804	&	1538	\\
Q9	&	790	&	6478	\\
Q15	&	2023	&	2093	\\
Q16	&	1808	&	1858	\\
Q17	&	971	&	963	\\
Q20	&	1067	&	942	\\
Q21	&	3234	&	1707	\\
Q22	&	809	&	1285	\\
\bottomrule\end{tabular} 
	\caption{Laufzeit \enquote{warm}}
  \label{tab_runtime}
\end{table}

\section{Fazit}
Die Laufzeiten der Abfragen ergeben ein uneinheitliches Bild. Die Abfragen Q2 und Q4 erfahren durch die Entschachtelung eine deutliche Beschleunigung der Laufzeit. Sogar dann, wenn die temporären Relationen neu erzeugt werden müssen. Die Laufzeit der entschachtelten Abfrage ist im zweiten Durchlauf bis auf Abfrage Q21 vergleichbar oder besser der Ausführung mit geschachtelter Iteration. Bei den Abfragen Q17, Q20, Q21 und Q22 ist der Aufwand für die Erzeugung der temporären Relationen ein vielfaches der Ausführungszeit der geschachtelten Ausführung. Durch die Implementierung der beschriebenen Erweiterungen ist der Optimierer in der Lage, die oben beschriebenen Abfragen ausführen zu können. Um den Benchmark vollständig ausführen zu können, muss der Optimierer noch um einige Konstrukte erweitert werden. Die Abfragen Q18 und Q11 des Benchmarks benötigen die Unterstützung der \sql{having}-Klausel. Diese entspricht einer Selektionsoperation auf dem Ergebnis einer Aggregation. Für die Abfragen Q8 und Q14 ist die Übersetzung von Ausdrücken über Aggregationsergebnissen erforderlich. 

Bis auf die in Kapitel \ref{chp:Entwurf} beschriebenen Einschränkungen lassen sich geschachtelte Abfragen mit dem Optimierer übersetzen. Das Ziel, die Entscheidung der Ausführungsstrategie dem Optimierer zu überlassen, musste jedoch schon während der Analyse des Problems fallgelassen werden. Die hierfür notwendige Infrastruktur zu erstellen und die notwendigen mathematischen Grundlagen zu erarbeiten hätten den Rahmen dieser Arbeit gesprengt.

\section{Ausblick}
Um die Entschachtelung zu vervollständigen sollte über die Implementierung eines Anti-Join-Operators nachgedacht werden. Auch ein allgemeiner Full-Outerjoin-Operator auf Basis von Symmjoin. Unterstützung von \textbf{GROUPBY...HAVING}-Klauseln inkl. Subqueries. Die Erweiterung der Optimierung um den Kostenvergleich zwischen geschachtelter und entschachtelter Ausführung auf der Basis statistisch modellierter Daten stellt mit Sicherheit eine Herausforderung dar. Geschachtelte Prädikate in Disjunktionen. Allgemeiner \sql{in}-Operator für Konstanten, möglicherweise auf der Basis des bestehenden \sql{in}-Operators der \algebra{Collection-Algebra}. Die Kosten- und Selektivitätsberechnung für geschachtelte Prädikate könnte in einer folgenden Arbeit erweitert werden, um bei der Optimierung geschachtelter Abfragen beide Ausführungsstrategien zu vergleichen. Weitere Formen von geschachtelten Abfragen, die noch nicht optimiert werden können: korrelierte Abfragen in der SELECT-Klausel und der FROM-Klausel, geschachtelte Abfragen in Disjunktionen, geschachtelte Abfragen, die mehrere Schachtelungsebenen überspringen.

%
% EOF
%
%