%
% Kapitel Entwurf
%
%

\chapter{Entwurf}\label{chp:Entwurf}
Der von Kim bzw. Ganski/Wong vorgestellten Algorithmen zur Optimierung geschachtelter Abfragen hat für die Implementierung in \textsc{Secondo} den Vorteil, dass er sich mit der Einführung eines weiteren Operators in die bestehende \textsc{Secondo}-Implementierung integrieren lässt. Zur Umsetzung der Algorithmen sind die vorhandenen Stan\-dard-Ope\-ra\-ti\-on\-en Projektion und Selektion sowie die Operationen Anti-Join und Full-Outer-Join notwendig. Im Rahmen dieser Arbeit wurde ein Full-Outer-Join-Operator für den Fall der Attribut-Gleichheit implementiert. Da sich keiner der vorhandenen Join-Algorithmen zur Umsetzung eines effizienten Anti-Join-Algorithmus eignet, wurde auf die Implementierung eines entsprechenden Algorithmus verzichtet. Geschachtelte Abfragen mit dem Operator \sql{not in} werden zwar übersetzt, die entsprechenden Prädikate sind aber keiner weiteren Optimierung zugänglich. D.h. eine Optimierung über Entschachtelung ist in diesem Spezialfall nicht möglich. Nach der Implementierung eines Anti-Join-Operators sollte die Implementierung eines Prädikats zur Entschachtelung mit dem in \cite{319745} vorgestellten trivial sein.

Bei der Analyse des Problems wurde klar, das eine echte Optimierung, d.h. ein Vergleich der geschachtelten und der nicht geschachtelten Ausführungsvariante einer Abfrage umfangreiche Berechnungen und Simulationen erfordern würde. Um die Kosten der entschachtelten Abfrage ermitteln zu können müssen die Selektivitäten der Prädikate ermittelt werden. Dies erfolgt durch Auswertung jedes einzelnen Prädikats über eine bzw. zwei Stichproben-Relationen, die aus den eigentlichen Relationen abgeleitet werden. Da die Prädikate der entschachtelten Abfrage 
möglicherweise auf temporäre Relationen bezugnehmen, müsste hier die entsprechende Selektivität simuliert werden. Um an dieser Stelle vernünftige Daten zu erhalten, wäre der Nachbau eines großen Teils der Metadaten-Ermittlung des Optimierers notwendig gewesen. Da dies den Rahmen dieser Diplomarbeit sprengen würde, wurde hierauf verzichtet.

Da der Operator \sql{in} für Tupel noch nicht implementiert ist, wurde die triviale Umsetzung von \sql{in} in die Disjunktion der angegebenen Konstanten als Übersetzung integriert. Eine Implementierung des \sql{in}-Operators für Tupelströme auf Basis \secondo{in}- und \secondo{collect\_set}-Operators der \algebra{Collection}-Algebra wäre eine mögliche Vorgehensweise zur performanten Implementierung dieses Operators. 
\begin{itemize}
	\item keine automatische Entscheidung entschachteln oder nicht
	\subitem alle Metadaten über temp. Relationen wären notwendig
	\subitem inkl. Selektivitäten
	\item \textbf{IN} ohne Subquery -> Übersetzung in geschachtelte \textbf{OR} Prädikate
\end{itemize}
In \cite{319745} wird gezeigt, dass eine Abfrage der Form 
\begin{lstlisting}
SELECT §$R_i.C_k$§
FROM §$R_i$§
WHERE §$R_i.C_h$§ IN (SELECT §$R_j.C_m$§
											FROM §$R_j$§);
\end{lstlisting}

inhaltlich äquivalent zu einer Abfrage 

\begin{lstlisting}
SELECT §$R_i.C_k$§
FROM §$R_i, R_j$§
WHERE §$R_i.C_h = R_j.C_m$§
\end{lstlisting}

ist.

Die Mengen basierte Semantik des IN-Operators wird nur dann erhalten, wenn $R_j$ bezüglich der Spalte $C_m$ duplikatfrei ist. Dies kann aber jederzeit erreicht werden, indem $R_j$ durch eine temporäre Relation $R_{j}^{'}$ ersetzt wird. $R_{j}^{'}$ erhält man, indem $R_j$ auf die Spalte $C_m$ eingeschränkt und projiziert wird. Für skalare Vergleichsoperatoren gilt die Äquivalenz ohne diese Einschränkung. Skalare Vergleichsoperatoren sind nicht \enquote{duplikats-entfernend}. 

\section{Behandlung quantifizierter Prädikate}\label{sct:Behandlung quantifizierter Prädikate}
Prädikate mit den Operatoren \sql{exists}, \sql{all} oder \sql{any} können in ein inhaltlich äquivalentes Prädikat mit Aggregationsfunktion transformiert werden. Das Prädikate \sql{exists(Q)}  ist genau dann wahr, wenn die Ergebnisrelation des Abfrageblocks  Q mindestens ein Tupel enthält. Ist \sql{Q = select $C_n$ from $R_m$ where P}, so lässt sich aber auch als \sql{0 < (select count($C_n$) from $R_m$ where P)} ausdrücken. Analog dazu kann \sql{not exists(select $C_n$ from $R_m$ where P)} in \sql{0 = (select count($C_n$) from $R_m$ where P)} überführt werden. Die Semantik der Operatoren \sql{all} und \sql{any} bleibt ebenfalls erhalten, wenn man Prädikate mit den beiden Operatoren in Prädikate umwandelt, die einen Vergleich mit dem Maximum bzw. Minimum der Unterabfrage darstellen. \sql{$C_n$ $\theta$ any(select $C_m$ from $R_i$ where P)} wird für $\theta \in {<,<=,>,>=}$ transformiert in \sql{$C_n$ $\theta$ (select AGGR($C_n$) from $R_i$ where P)}. Wobei hier gilt
\begin{math}
AGGR = 
\begin{cases}
min&\quad\text{falls}\ \theta < oder \leq, \\
max&\quad\text{falls}\ \theta > oder \geq. 
\end{cases}
\end{math}

Im Spezialfall \sql{$C_n$ = any(select $C_m$ from $R_i$ where P)} wird das Prädikat durch das semantisch äquivalente Prädikat \sql{$C_n$ in (select $C_m$ from $R_i$ where P)} ersetzt. Mit diesen Transformationen lassen sich auch quantifizierte Prädikate als Prädikate der Typen J, N, A oder JA betrachten. Dies hat zur Folge, dass sich die im folgenden beschriebenen Optimierungsalgorithmen auch auf diese Prädikate anwenden lassen.


\section{Algorithmus \textbf{NEST-N-J}}\label{sct:Algorithmus NEST-N-J}
Ziel des Algorithmus ist es, ein geschachteltes Prädikat in eine inhaltlich identische entschachtelte Form zu überführen. 
Dafür wird die Konjunktion der WHERE-Klauseln gebildet und um ein Join-Prädikat ergänzt, das aus dem ursprünglich geschachtelten Prädikat abgeleitet ist. Die Relationen des äußeren Abfrageblocks werden um die Relationen der Unterabfrage erweitert. Die WHERE-Klausel wird durch die Konjunktion der WHERE-Klauseln des äußeren und des inneren Abfrageblocks gebildet und um ein Join-Prädikat erweitert. Dieses ist der Vergleich des im geschachtelten Prädikat auf der linken Seite auftretenden Attributs mit dem Attribut der SELECT-Klausel des inneren Abfrageblocks. Der Vergleichsoperator des neuen Prädikats ist nur für die Operatoren \sql{in} und \sql{not in} abweichend von dem im geschachtelten Prädikat verwendeten Operator. Im Fall von \sql{in} wird = und im Fall von \sql{not in} <> verwendet. Die SELECT-Klausel der geschachtelten Abfrage bleibt unverändert.
Alle FROM-Klausel kombinieren. Die resultierende FROM-Klausel umfasst alle Relationen des inneren und des äußeren Abfrageblocks\\
Die Konjunktion der WHERE-Klauseln bilden.\\
Das geschachtelte Prädikat \begin{math}[R_i.C_h \operatorname{op}\ (\texttt{SELECT} R_j.C_m \dots)]\end{math} ersetzen durch ein neues Join-Prädikat \begin{math}[R_i.C_h \operatorname{\emph{new-op}} R_j.C_m]\end{math}, das mit der restlichen WHERE-Klausel per Konjunktion verbunden ist\\
Die SELECT-Klausel des äußersten Abfrageblocks behalten\\

\begin{lstlisting}
select §$A_1 ,\dots,A_n$§ 
from §$R_1 ,\dots,R_m$§ 
where §$P_1,\dots,P_l,$§ 
	§$X\operatorname{\theta}\ ($§
		select 
			§$T_i.B$§ 
		from 
			§$T_1 ,\dots,T_s$§ 
		where 
			§$Q_1,\dots,Q_r$§
	§$)$§
\end{lstlisting}

wird transformiert in 

\begin{lstlisting}
select §$A_1,\dots,A_n$§
from §$R_1,\dots,R_m,T_1,\dots,T_s$§
where §$P_1,\dots,P_l$§,
	§$Q_1,\dots,Q_r$§
	§$X\operatorname{\theta^'}T_i.B$§
\end{lstlisting}

\begin{math}
X \subset\{A_1,\ldots,A_n\} \\[1em]
\theta \in \{\operatorname{IN},\operatorname{NOT\ IN},=,\not=,>,\geq,<,\leq\} \\[1em]
\theta^{'} = 
\begin{cases}
=&\quad\text{falls}\ \theta = \operatorname{IN}, \\
\not=&\quad\text{falls}\ \theta = \operatorname{NOT\ IN}, \\
\theta&\quad\text{sonst}.
\end{cases}
\end{math}

\section{Algorithmus \textbf{NEST-JA2}}\label{sct:Algorithmus NEST-JA2}
Der Algorithmus basiert auf der Idee, die Aggregation für alle benötigten Gruppen im Voraus zu berechnen. 
Um die Auswertung der Aggregation nicht bei jedem Tupel der äußeren Relation durchführen zu müssen, wird mit temporären Tabellen gearbeitet. Es wird die Aggregation über die inneren Relationen gruppiert nach Werten des Join-Attributs der äußeren Spalte vorausberechnet. Da die temporären Relationen persistent abgelegt werden, fällt der Aufwand für ihr Anlegen nur einmal an. Ab der zweiten Ausführung kann auf die bestehenden temporären Relationen zugegriffen werden. 
Im ersten Schritt werden die benötigten äußeren Relationen auf die in der Unterabfrage verwendeten Attributspalten projiziert und durch den Zusatz \sql{distinct} um Duplikate bereinigt. Hiermit erhält man die erste temporäre Relation $Rt_1$. Die zweite temporäre Relation $Rt_2$ ist die Projektion der inneren Relationen auf die Attribute der korrelierten Prädikate und Restriktion durch alle einfachen Prädikate der Unterabfrage. Die dritte temporäre Relation $Rt_3$ ist ein Join aus den beiden vorhergehenden temporären Relationen. Hierbei wird die Aggregation vorausberechnet und nach den Join-Attributen der äußeren Relationen gruppiert. Handelt es sich bei der Aggregationsfunktion um \sql{count}, so muss ein Full-Outer-Join ausgeführt werden, da hier \sql{NULL}-Werte das Ergebnis der Aggregation beeinflussen. Wird \sql{count} in der ursprünglichen Abfrage auf Tupelebene ausgeführt (\sql{select count(*)}), so muss die Aggregation bei der Erstellung der temporären Relation auf eine der Join-Spalten geändert werden, um das Ergebnis nicht zu verfälschen. Die Projektion der Relation $Rt_3$ erfolgt auf die entsprechenden Attribute der äußeren Relationen, gegebenenfalls müssen die Attribute in der \sql{select}-Klausel umgesetzt werden. Die entschachtelte Version der Abfrage wird gebildet, indem die ursprüngliche \sql{from}-Klausel um die temporäre Relation $Rt_3$ erweitert wrid. Das geschachtelte Prädikat der \sql{where}-Klausel wird durch ein neues Join-Prädikat ersetzt, welches auf Übereinstimmung der ursprünglichen linken Seite des geschachtelten Prädikats mit der Aggregationsspalte von $Rt_3$ prüft.
1. temporäre Relation = Projektion der äußeren Relation(en) auf die Join-Spalten und Restriktion durch \emph{simple} Prädikate, die in der äußeren WHERE-Klausel enthalten sind\\
2. temporäre Relation = Join aus 1. temporärer und innerer/en Relationen, falls Aggregationsfunktion = COUNT, dann müssen die simplen Prädikate auf die innere Relation vor dem Join angewandt werden. Ist die Aggregationsfunktion COUNT(*), dann muss COUNT über die/eine Join-Spalte ausgeführt werden. Das Join-Prädikat muss den selben Operator enthalten, wie die ursprüngliche geschachtelte Abfrage. Der Join-Operator in der ursprünglichen Abfrage muss in \emph{=} geändert werden. In der SELECT-Klausel muss die Join-Spalte der äußeren Relation anstelle der Inneren Relation verwendet werden\\

\begin{lstlisting}
select §$A_1,\dots,A_n$§
from §$R_1,\dots,R_m$§
where §$P_1 (R_1 ),\dots,P_k (R_1 )$§,
	§$P_1 ,\ldots,P_l,$§,
	§$R_i.X \operatorname{\theta}\ ($§
		select §$\operatorname{AGGR}(T_j.A)$§
		from §$T_1 ,\dots,T_s$§			
		where §$Q_1 ,\dots,Q_r$§,
			pred§$[R_1.Y \operatorname{op} T_1.Z]$§
	§$)$§
\end{lstlisting}

Die Projektion der äußeren Relation auf die Join-Spalte des korrelierten Prädikats.

\begin{lstlisting}
TEMP1 = (
	select distinct §$R_1.Y$§
	from §$R_1$§
	where	§$P_1(R_1),\dots,P_k(R_1)$§
	)
\end{lstlisting}

\begin{lstlisting}
TEMP2 = (
	select §$T_j.A,T_1.Z$§
	from §$T_1,\dots,T_s$§
	where §$Q_1,\dots,Q_r$§
	)
\end{lstlisting}

Für Aggregationsfunktionen ungleich \sql{count} ergibt sich folgender Ausdruck für die dritte temporäre Relation.

\begin{lstlisting}
TEMP3 = (
	select §$T_1.Y,\operatorname{AGGR}(T_j.A)$§ as AggrResult
  from TEMP1, TEMP2
  where pred§$[R_1.Y \operatorname{op} T_1.Z]$§
  group by
  	§$T_1.Y$§
  §$)$§
\end{lstlisting}

Ist die Aggregationsfunktion \sql{count}, so muss stattdessen der Full-Outer-Join berechnet werden.

\begin{lstlisting}
TEMP3 = (
	select §$T_1.Y,\operatorname{AGGR}(T_j.A)$§ as AggrResult
  from TEMP1 outer join TEMP2
    on pred§$[R_1.Y \operatorname{op} T_1.Z]$§
  group by
  	§$T_1.Y$§
  §$)$§
\end{lstlisting}

Nach der Berechnung der temporären Tabellen vereinfacht sich die ursprüngliche Abfrage zu 

\begin{lstlisting}
select §$A_1,\dots,A_n$§
from §$R_1,\dots,R_m$§,TEMP3
where §$P_1,\dots,P_l,$§
	§$R_i.X \operatorname{\theta}$§ TEMP3.AggrResult, 
	§$R_1.Y=$§Temp3.Z
\end{lstlisting}

\begin{math}\theta \in\{=,\not=,>,\geq,<,\leq\}\end{math}

\section{Algorithmus NEST-G}\label{sct:Algorithmus NEST-G}
Ganski/Wong stellen in \cite{38723} ihren allgemeinen Algorithmus zur Optimierung geschachtelter Abfragen vor. Dieser wendet rekursiv je nach Schachtelungstyp die oben vorgestellten Algorithmen auf geschachtelte Prädikate an. 
\begin{algorithm}
\caption{Algorithmus NEST-G}
\begin{algorithmic}
\STATE \textbf{procedure} $nest\_g(Q)$
\FORALL{Prädikate p in Q}
\IF{p ist ein geschachteltes Prädikat mit Unterabfrage $Q_u$}
\STATE $nest\_g(Q_u)$
\IF{$Q_u$ ist vom Typ A}
\STATE $nest\_a(Q_u)$
\ELSIF{$Q_u$ ist vom Typ JA}
\STATE $nest\_ja2(Q_u)$
\STATE $nest\_n\_j(Q, Q_u)$
\ENDIF
\ENDIF
\STATE $nest\_n\_j(Q_u)$
\ENDFOR
\end{algorithmic}
\end{algorithm}


allgemeiner Algorithmus zur Entschachtelung mit temporären Tabellen, auf der Basis von Join- und Outerjoin-Operatoren und temporären Tabellen,


Begriffserklärung Schachtelunsgtiefe

Schritte des Optimierers
\begin{itemize}
	\item Query-Rewriting
	\item Schema-Lookup
	\item Abfrageplan-Ermittlung 
	\item Übersetzung Plan in ausführbare Syntax
\end{itemize}


durch vorhanden Operatoren in \textsc{Secondo} fast vollständig umsetzbar, nur Erweiterung um Full-Outerjoin-Operator notwendig\\
Vergleich nested-iteration/dekorrelierter Plan wird \underline{nicht} implementiert:\\
Für den Vergleich der Kosten müsste die komplette Selektivitäts- und Kostenbestimmung für die notwendigen temporären Relationen simuliert werden (**ausführlicher beschreiben**)\\
kann nicht für alle Formen von Subqueries genutzt werden (Beispiele)\\
Ergebnis sollte eine Abfrage der Schachtelungstiefe 0 sein. Der Optimierer 

\begin{enumerate}
	\item Jedes Typ-A Prädikat wird in ein einfaches Prädikat umgewandelt, indem es vollständig ausgewertet wird. Falls das Prädikat ebenfalls geschachtelt ist, wird Algorithmus NEST-G rekursiv angewandt, bis das Prädikat nicht weiter entschachtelt werden kann.
	\item Jedes Typ-JA Prädikat wird mit dem Algorithmus NEST-JA(G) in eine semantisch äquivalente Abfrage vom Typ-N oder -J umgewandelt.
	\item \emph{In dieser Arbeit nicht implementiert}: Prädikate vom Typ-D werden in ihre kanonische Form transformiert. 
	\item Die aus den bisherigen Schritten des Algorithmus resultierende Abfrage hat nur noch Prädikate vom Typ-N oder Typ-J. Diese wird mit dem Algorithmus NEST-N-J in ihre kanonische Form überführt.
\end{enumerate}

%
% EOF
%
%