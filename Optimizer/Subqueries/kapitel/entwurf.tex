%
% Kapitel Entwurf
%
%

\chapter{Entwurf}\label{chp:Entwurf}
Der von Kim bzw. Ganski/Wong vorgestellten Algorithmen zur Optimierung geschachtelter Abfragen hat für die Implementierung in \textsc{Secondo} den Vorteil, dass er sich mit der Einführung eines weiteren Operators in die bestehende \textsc{Secondo}-Implementierung integrieren lässt. Zur Umsetzung der Algorithmen sind die vorhandenen Stan\-dard-Ope\-ra\-ti\-on\-en Projektion und Selektion sowie die Operationen Anti-Join und Full-Outer-Join notwendig. Im Rahmen dieser Arbeit wurde ein Full-Outer-Join-Operator für den Fall der Attribut-Gleichheit implementiert. Da sich keiner der vorhandenen Join-Algorithmen zur Umsetzung eines effizienten Anti-Join-Algorithmus eignet, wurde auf die Implementierung eines entsprechenden Algorithmus verzichtet. Geschachtelte Abfragen mit dem Operator \sql{not in} werden zwar übersetzt, die entsprechenden Prädikate sind aber keiner weiteren Optimierung zugänglich. D.h. eine Optimierung über Entschachtelung ist in diesem Spezialfall nicht möglich. Nach der Implementierung eines Anti-Join-Operators sollte die Implementierung eines Prädikats zur Entschachtelung mit dem in \cite{319745} vorgestellten Algorithmus trivial sein. 

Bei der Analyse des Problems wurde klar, das eine echte Optimierung, d.h. ein Vergleich der geschachtelten und der nicht geschachtelten Ausführungsvariante einer Abfrage umfangreiche Berechnungen und Simulationen erfordern würde. Um die Kosten der entschachtelten Abfrage ermitteln zu können müssen die Selektivitäten der Prädikate ermittelt werden. Dies erfolgt durch Auswertung jedes einzelnen Prädikats über einer bzw. zwei Stichproben-Relationen, die aus den eigentlichen Relationen abgeleitet werden. Die Erzeugung der temporären Relationen zu diesem Zeitpunkt würde die Laufzeitkosten hierfür bei beiden Ausführungsvarianten erhöhen. Ein sinnvoller Vergleich wäre nicht mehr gegeben, da gerade die Erzeugung der temporären Relationen zu einer längeren Laufzeit bei entschachtelter Ausführung führen kann. Da die Prädikate der entschachtelten Abfrage möglicherweise auf temporäre Relationen bezugnehmen, müsste hier die entsprechende Selektivität simuliert werden. Um an dieser Stelle vernünftige Daten zu erhalten, wäre der Nachbau eines großen Teils der Metadaten-Ermittlung des Optimierers notwendig gewesen. Da dies den Rahmen dieser Diplomarbeit sprengen würde, wurde hierauf verzichtet.

Da der Operator \sql{in} für Tupel noch nicht implementiert ist, wurde die triviale Umsetzung von \sql{in} in die Disjunktion der angegebenen Konstanten als Übersetzung integriert. Eine Implementierung des \sql{in}-Operators für Tupelströme auf Basis des \secondo{in}- und \secondo{collect\_set}-Operators der \algebra{Collection}-Algebra wäre eine mögliche Vorgehensweise zur performanten Implementierung dieses Operators. 

\begin{itemize}
	\item keine automatische Entscheidung entschachteln oder nicht
	\subitem alle Metadaten über temp. Relationen wären notwendig
	\subitem inkl. Selektivitäten
	\item \textbf{IN} ohne Subquery -> Übersetzung in geschachtelte \textbf{OR} Prädikate
\end{itemize}
In \cite{319745} wird gezeigt, dass eine Abfrage der Form 
\begin{lstlisting}
SELECT §$R_i.C_k$§
FROM §$R_i$§
WHERE §$R_i.C_h$§ IN (SELECT §$R_j.C_m$§
											FROM §$R_j$§);
\end{lstlisting}

inhaltlich äquivalent zu einer Abfrage 

\begin{lstlisting}
SELECT §$R_i.C_k$§
FROM §$R_i, R_j$§
WHERE §$R_i.C_h = R_j.C_m$§
\end{lstlisting}

ist.

Die Mengen basierte Semantik des IN-Operators wird nur dann erhalten, wenn $R_j$ bezüglich der Spalte $C_m$ duplikatfrei ist. Dies kann aber jederzeit erreicht werden, indem $R_j$ durch eine temporäre Relation $R_{j}^{'}$ ersetzt wird. $R_{j}^{'}$ erhält man, indem $R_j$ auf die Spalte $C_m$ eingeschränkt und projiziert wird. Für skalare Vergleichsoperatoren gilt die Äquivalenz ohne diese Einschränkung. Skalare Vergleichsoperatoren sind nicht \enquote{duplikats-entfernend}. 

\begin{lstlisting}
SELECT §$R_i.C_k$§
FROM §$R_i$§
WHERE §$R_i.C_h$§ NOT IN (SELECT §$R_j.C_m$§
											FROM §$R_j$§);
\end{lstlisting}

lässt sich nicht mit 

\begin{lstlisting}
SELECT §$R_i.C_k$§
FROM §$R_i, R_j$§
WHERE §$R_i.C_h <> R_j.C_m$§
\end{lstlisting}

übersetzen, da die Semantik und das Ergebnis der beiden Abfragen nicht übereinstimmen. In der geschachtelten Abfrage werden als Ergebnis alle Tupel der äußeren Relation erwartet, zu denen es keine Entsprechung in der inneren Relation gibt. Das Ergebnis der zweiten Abfrage ist die Teilmenge des Kreuzprodukts der beiden Relationen, die in den Werten $C_h$ und $C_m$ nicht übereinstimmen. Die entsprechende Operationen der Relationenalgebra ist der Anti-Join. In den für \textsc{Secondo} implementierten Algebramodulen für die Relationenalgebra, \algebra{Relation-C++}- und \algebra{ExtRelation-C++}-Algebra ist kein entsprechender Operator enthalten. Eine Implementierung im Rahmen dieser Diplomarbeit erfolgte nicht. 

\section{Ein Full-Outer-Join-Operator für SECONDO}
\textsc{Secondo} enthält bereits mehrere allgemeine Join-Operatoren. Als Vorlage für die Implementierung des Full-Outer-Join-Operators wurde der Operator \secondo{sortmergejoin} ausgewählt, da sich der zugrunde liegende Algorithmus mit wenigen Änderungen in einen Full-Outer-Join umbauen lässt. Sort-Merge-Join ist ein Algorithmus zur Berechnung von Equi-Joins. Voraussetzung ist die Sortierung der Relationen bzw. Ströme bezüglich der Join-Attribute. Diese Anforderung kann durch das vorhergehende Sortieren der Relationen erfüllt werden. In \textsc{Secondo} wird diese Aufgabe von dem Operator \secondo{sortmergejoin} erledigt. 

Zu Beginn des Algorithmus zeigen die beiden Zeiger auf den Anfang jeder Relation. 
\begin{enumerate}
\item Jetzt werden alle Tupel der ersten Relation mit übereinstimmenden Wert im Join-Attribut in einen Puffer gelesen und der Zeiger jeweils auf das aktuell gelesene Tupel gesetzt. 
\item Im nächsten Schritt werden alle Tupel der zweiten Relation in einen Puffer gelesen, die bezüglich ihres Join-Attribut-Werts übereinstimmen. 
\subitem Ist der Wert des Join-Attributs kleiner, als der des Tupels im ersten Puffer, wird der Zeiger in der zweiten Relation um eine Position erhöht. 
\subitem Besteht Gleichheit im Wert des Join-Attributs, so wird ein Tupel der Ergebnisrelation erzeugt, das aus der Aneinanderreihung der Tupel der Eingaberelationen besteht, für jedes Tupel das im ersten Puffer steht. Anschließend wird das Tupel aus dem zweiten Puffer gelöscht und mit dem nächsten Tupel aus diesem Puffer fortgefahren. Ist der zweite Puffer erschöpft, wird auch der erste Puffer geleert und mit dem ersten Schritt fortgefahren. 
\subitem Ist der Wert des Join-Attributs im zweiten Puffer größer, als im ersten, so wird der Zeiger in der ersten Relation solange erhöht, bis einer der oben genannten Fälle eintritt. 
\item Ist eine der beiden Relationen erschöpft, ist der Algorithmus beendet.
\end{enumerate}

Dieser Algorithmus lässt sich auf folgende Art und Weise zum Full-Outer-Join ausbauen. Bei jedem Vergleichsschritt wird jetzt ein Tupel der Ausgaberelation erzeugt. Ist der Wert im ersten Puffer größer als im zweiten, so besteht das Tupel der Ergebnismenge aus einer Verkettung des Tupels aus dem Puffer und einem mit NULL-Werten gefüllten Tupel der zweiten Relation. Auf die gleiche Art wird mit jedem Tupel des Puffers verfahren. Ist der Attribut-Wert gleich, so wird wie beim Sort-Merge-Join verfahren. Ist der Wert größer, so wird für jedes Tupel im zweiten Puffer ein Ausgabe-Tupel erzeugt, dass aus einer Aneinanderreihung eines NULL-Tupels der ersten Relation und dem Tupel aus dem Puffer besteht.

\begin{itemize}
	\item Beschreibung Sortmergejoin
	\subitem Zwei Tupelbuffer
	\subitem sortieren
	\subitem immer mit dem kleineren Tupel arbeiten und vergleichen
	\subitem falls Treffer, merge Schritt
	\subitem sonst Tupel verwerfen und mit nächstem Tupel weiterarbeiten
\end{itemize}
Basis ist sortmergejoin, nicht \enquote{matchende} Tupel wird mit NULL-Werten aufgefüllt, nur Equi-Outerjoin\\
Ausblick: Full-Outer-Join auf Basis von Symmjoin. Die Tupel der beiden Ströme werden um ein Attribut TupelID erweitert. Zu jedem Tupel, das über den Symmjoin-Algorithmus einen Partner gefunden hat, wird die TupelID in einer Hash-Tabelle gespeichert. Dabei werden die TupelIDs für jeden Strom in einer eigenen Hash-Tabelle abgelegt. Nach Beendigung des Symmjoin-Algorithmus wird jeder Tupelpuffer ein zweites Mal durchlaufen. Ist die TupelID eines Tupels nicht in der entsprechenden Hash-Tabelle enthalten, so wird ein Ergebnistupel erzeugt, das die Werte aus dem betrachteten Tupel übernimmt und für die zusätzlichen Spalten mit NULL-Werten aufgefüllt wird. zwei Hash-Tabelle mit TupelIds für alle gefundenen Tupel, Tupelbuffer durchlaufen und ein mit NULL-Werten aufgefülltes Tupel erzeugen für alle nicht gematchten Tupel

\section{Behandlung quantifizierter Prädikate}\label{sct:Behandlung quantifizierter Prädikate}
Prädikate mit den Operatoren \sql{exists}, \sql{all} oder \sql{any} können in ein inhaltlich äquivalentes Prädikat mit Aggregationsfunktion transformiert werden. Das Prädikate \sql{exists(Q)}  ist genau dann wahr, wenn die Ergebnisrelation des Abfrageblocks  Q mindestens ein Tupel enthält. Ist \sql{Q = select $C_n$ from $R_m$ where P}, so lässt sich aber auch als \sql{0 < (select count($C_n$) from $R_m$ where P)} ausdrücken. Analog dazu kann \sql{not exists(select $C_n$ from $R_m$ where P)} in \sql{0 = (select count($C_n$) from $R_m$ where P)} überführt werden. Um die Berechnung der Aggregation zu beschleunigen, kann die Abfrage mit dem Ausdruck \secondo{first 1} noch auf das erste Tupel der Unterabfrage beschränkt werden. Dies verhindert das teure Operatoren auf allen Tupeln der Unterabfrage ausgeführt werden müssen. Das Ergebnis von Abfragen mit den Operatoren \sql{all} und \sql{any} bleibt ebenfalls erhalten, wenn man Prädikate mit den beiden Operatoren in Prädikate umwandelt, die einen Vergleich mit dem Maximum bzw. Minimum der Unterabfrage darstellen. \sql{$C_n$ $\theta$ any(select $C_m$ from $R_i$ where P)} wird für $\theta \in {<,<=,>,>=}$ transformiert in \sql{$C_n$ $\theta$ (select AGGR($C_n$) from $R_i$ where P)}. Wobei hier gilt
\begin{math}
AGGR = 
\begin{cases}
min&\quad\text{falls}\ \theta < oder \leq, \\
max&\quad\text{falls}\ \theta > oder \geq. 
\end{cases}
\end{math}

So wird 

\sql{select * from $R_i$ where $C_n$ $\leq$ any(select $C_m$ from $R_j$ where P)}

in 

\sql{select * from $R_i$ where $C_n$ $\leq$ (select min($C_m$ from $R_j$ where P)}

transformiert.

Im Spezialfall \sql{$C_n$ = any(select $C_m$ from $R_i$ where P)} wird das Prädikat durch das semantisch äquivalente Prädikat \sql{$C_n$ in (select $C_m$ from $R_i$ where P)} ersetzt. Mit diesen Transformationen lassen sich auch quantifizierte Prädikate als Prädikate der Typen J, N, A oder JA betrachten. Dies hat zur Folge, dass sich die im folgenden beschriebenen Optimierungsalgorithmen auch auf diese Prädikate anwenden lassen.


\section{Algorithmus \textbf{NEST-N-J}}\label{sct:Algorithmus NEST-N-J}
Ziel des Algorithmus ist es, ein geschachteltes Prädikat in eine inhaltlich identische entschachtelte Form zu überführen. 

\begin{algorithm}
Algorithmus NEST-N-J
\begin{algorithmic}
\STATE \textbf{procedure} $nest\_n\_j(Q)$
\STATE $combine\_from\_clauses(outer\_query\_block, inner\_query\_block)$
\STATE $combine\_where\_clauses(outer\_query\_block, inner\_query\_block)$
\STATE $inser\_new\_join\_predicate(Q)$
\end{algorithmic}
\end{algorithm}

Dafür wird die Konjunktion der WHERE-Klauseln gebildet und um ein Join-Prädikat ergänzt, das aus dem ursprünglich geschachtelten Prädikat abgeleitet ist. Die Relationen des äußeren Abfrageblocks werden um die Relationen der Unterabfrage erweitert. Die WHERE-Klausel wird durch die Konjunktion der WHERE-Klauseln des äußeren und des inneren Abfrageblocks gebildet und um ein Join-Prädikat erweitert. Dieses ist der Vergleich des im geschachtelten Prädikat auf der linken Seite auftretenden Attributs mit dem Attribut der SELECT-Klausel des inneren Abfrageblocks. Der Vergleichsoperator des neuen Prädikats ist nur für die Operatoren \sql{in} und \sql{not in} abweichend von dem im geschachtelten Prädikat verwendeten Operator. Im Fall von \sql{in} wird = und im Fall von \sql{not in} <> verwendet. Die SELECT-Klausel der geschachtelten Abfrage bleibt unverändert.
Alle FROM-Klausel kombinieren. Die resultierende FROM-Klausel umfasst alle Relationen des inneren und des äußeren Abfrageblocks\\
Die Konjunktion der WHERE-Klauseln bilden.\\
Das geschachtelte Prädikat \begin{math}[R_i.C_h \operatorname{op}\ (\texttt{SELECT} R_j.C_m \dots)]\end{math} ersetzen durch ein neues Join-Prädikat \begin{math}[R_i.C_h \operatorname{\emph{new-op}} R_j.C_m]\end{math}, das mit der restlichen WHERE-Klausel per Konjunktion verbunden ist\\
Die SELECT-Klausel des äußersten Abfrageblocks behalten\\

\begin{lstlisting}
select §$A_1 ,\dots,A_n$§ 
from §$R_1 ,\dots,R_m$§ 
where §$P_1,\dots,P_l,$§ 
	§$X\operatorname{\theta}\ ($§
		select 
			§$T_i.B$§ 
		from 
			§$T_1 ,\dots,T_s$§ 
		where 
			§$Q_1,\dots,Q_r$§
	§$)$§
\end{lstlisting}

wird transformiert in 

\begin{lstlisting}
select §$A_1,\dots,A_n$§
from §$R_1,\dots,R_m,T_1,\dots,T_s$§
where §$P_1,\dots,P_l$§,
	§$Q_1,\dots,Q_r$§
	§$X\operatorname{\theta^'}T_i.B$§
\end{lstlisting}

\begin{math}
X \subset\{A_1,\ldots,A_n\} \\[1em]
\theta \in \{\operatorname{IN},\operatorname{NOT\ IN},=,\not=,>,\geq,<,\leq\} \\[1em]
\theta^{'} = 
\begin{cases}
=&\quad\text{falls}\ \theta = \operatorname{IN}, \\
\not=&\quad\text{falls}\ \theta = \operatorname{NOT\ IN}, \\
\theta&\quad\text{sonst}.
\end{cases}
\end{math}

\section{Algorithmus \textbf{NEST-JA2}}\label{sct:Algorithmus NEST-JA2}
Der Algorithmus basiert auf der Idee, die Aggregation für alle benötigten Gruppen im Voraus zu berechnen. 
Um die Auswertung der Aggregation nicht bei jedem Tupel der äußeren Relation durchführen zu müssen, wird mit temporären Tabellen gearbeitet. Es wird die Aggregation über die inneren Relationen gruppiert nach Werten des Join-Attributs der äußeren Spalte vorausberechnet. Da die temporären Relationen persistent abgelegt werden, fällt der Aufwand für ihr Anlegen nur einmal an. Ab der zweiten Ausführung kann auf die bestehenden temporären Relationen zugegriffen werden. 

\begin{algorithm}
Algorithmus NEST-JA2
\begin{algorithmic}
\STATE \textbf{procedure} $nest\_ja2(Q)$
\STATE $temp1 = project\_outer\_relations(Q)$
\STATE $temp2 = project\_and\_restrict\_inner\_relations(Q)$
\IF{Aggregationsfunktion ist COUNT}
\IF{COUNT(*)}
\STATE \textit{Ersetze * durch Join-Attribut}
\ENDIF
\STATE $temp3 = outerjoin\_and\_aggregate(temp1, temp2)$
\ELSE
\STATE $temp3 = join\_and\_aggregate(temp1, temp2)$
\ENDIF
\STATE $equi\_join(outer\_relations, temp3)$
\end{algorithmic}
\end{algorithm}

Im ersten Schritt werden die benötigten äußeren Relationen auf die in der Unterabfrage verwendeten Attributspalten projiziert und durch den Zusatz \sql{distinct} um Duplikate bereinigt. Hiermit erhält man die erste temporäre Relation $Rt_1$. Die zweite temporäre Relation $Rt_2$ ist die Projektion der inneren Relationen auf die Attribute der korrelierten Prädikate und Restriktion durch alle einfachen Prädikate der Unterabfrage. Die dritte temporäre Relation $Rt_3$ ist ein Join aus den beiden vorhergehenden temporären Relationen. Hierbei wird die Aggregation vorausberechnet und nach den Join-Attributen der äußeren Relationen gruppiert. Handelt es sich bei der Aggregationsfunktion um \sql{count}, so muss ein Full-Outer-Join ausgeführt werden, da hier \sql{NULL}-Werte das Ergebnis der Aggregation beeinflussen. Wird \sql{count} in der ursprünglichen Abfrage auf Tupelebene ausgeführt (\sql{select count(*)}), so muss die Aggregation bei der Erstellung der temporären Relation auf eine der Join-Spalten geändert werden, um das Ergebnis nicht zu verfälschen. Die Projektion der Relation $Rt_3$ erfolgt auf die entsprechenden Attribute der äußeren Relationen, gegebenenfalls müssen die Attribute in der \sql{select}-Klausel umgesetzt werden. Die entschachtelte Version der Abfrage wird gebildet, indem die ursprüngliche \sql{from}-Klausel um die temporäre Relation $Rt_3$ erweitert wrid. Das geschachtelte Prädikat der \sql{where}-Klausel wird durch ein neues Join-Prädikat ersetzt, welches auf Übereinstimmung der ursprünglichen linken Seite des geschachtelten Prädikats mit der Aggregationsspalte von $Rt_3$ prüft.
1. temporäre Relation = Projektion der äußeren Relation(en) auf die Join-Spalten und Restriktion durch \emph{simple} Prädikate, die in der äußeren WHERE-Klausel enthalten sind\\
2. temporäre Relation = Join aus 1. temporärer und innerer/en Relationen, falls Aggregationsfunktion = COUNT, dann müssen die simplen Prädikate auf die innere Relation vor dem Join angewandt werden. Ist die Aggregationsfunktion COUNT(*), dann muss COUNT über die/eine Join-Spalte ausgeführt werden. Das Join-Prädikat muss den selben Operator enthalten, wie die ursprüngliche geschachtelte Abfrage. Der Join-Operator in der ursprünglichen Abfrage muss in \emph{=} geändert werden. In der SELECT-Klausel muss die Join-Spalte der äußeren Relation anstelle der Inneren Relation verwendet werden\\

\begin{lstlisting}
select §$A_1,\dots,A_n$§
from §$R_1,\dots,R_m$§
where §$P_1 (R_1 ),\dots,P_k (R_1 )$§,
	§$P_1 ,\ldots,P_l,$§,
	§$R_i.X \operatorname{\theta}\ ($§
		select §$\operatorname{AGGR}(T_j.A)$§
		from §$T_1 ,\dots,T_s$§			
		where §$Q_1 ,\dots,Q_r$§,
			pred§$[R_1.Y \operatorname{op} T_1.Z]$§
	§$)$§
\end{lstlisting}

Die Projektion der äußeren Relation auf die Join-Spalte des korrelierten Prädikats.

\begin{lstlisting}
TEMP1 = (
	select distinct §$R_1.Y$§
	from §$R_1$§
	where	§$P_1(R_1),\dots,P_k(R_1)$§
	)
\end{lstlisting}

\begin{lstlisting}
TEMP2 = (
	select §$T_j.A,T_1.Z$§
	from §$T_1,\dots,T_s$§
	where §$Q_1,\dots,Q_r$§
	)
\end{lstlisting}

Für Aggregationsfunktionen ungleich \sql{count} ergibt sich folgender Ausdruck für die dritte temporäre Relation.

\begin{lstlisting}
TEMP3 = (
	select §$T_1.Y,\operatorname{AGGR}(T_j.A)$§ as AggrResult
  from TEMP1, TEMP2
  where pred§$[R_1.Y \operatorname{op} T_1.Z]$§
  group by
  	§$T_1.Y$§
  §$)$§
\end{lstlisting}

Ist die Aggregationsfunktion \sql{count}, so muss stattdessen der Full-Outer-Join berechnet werden.

\begin{lstlisting}
TEMP3 = (
	select §$T_1.Y,\operatorname{AGGR}(T_j.A)$§ as AggrResult
  from TEMP1 outer join TEMP2
    on pred§$[R_1.Y \operatorname{op} T_1.Z]$§
  group by
  	§$T_1.Y$§
  §$)$§
\end{lstlisting}

Nach der Berechnung der temporären Tabellen vereinfacht sich die ursprüngliche Abfrage zu 

\begin{lstlisting}
select §$A_1,\dots,A_n$§
from §$R_1,\dots,R_m$§,TEMP3
where §$P_1,\dots,P_l,$§
	§$R_i.X \operatorname{\theta}$§ TEMP3.AggrResult, 
	§$R_1.Y=$§Temp3.Z
\end{lstlisting}

\begin{math}\theta \in\{=,\not=,>,\geq,<,\leq\}\end{math}

\section{Algorithmus NEST-G}\label{sct:Algorithmus NEST-G}
Ganski/Wong stellen in \cite{38723} ihren allgemeinen Algorithmus zur Optimierung geschachtelter Abfragen vor. Dieser wendet rekursiv je nach Schachtelungstyp die oben vorgestellten Algorithmen auf geschachtelte Prädikate an. 

\begin{algorithm}
\caption{Algorithmus NEST-G}
\begin{algorithmic}
\STATE \textbf{procedure} $nest\_g(Q)$
\FORALL{Prädikate p in Q}
\IF{p ist ein geschachteltes Prädikat mit Unterabfrage $Q_u$}
\STATE $nest\_g(Q_u)$
\IF{$Q_u$ ist vom Typ A}
\STATE $nest\_a(Q_u)$
\ELSIF{$Q_u$ ist vom Typ JA}
\STATE $nest\_ja2(Q_u)$
\STATE $nest\_n\_j(Q, Q_u)$
\ENDIF
\ENDIF
\STATE $nest\_n\_j(Q_u)$
\ENDFOR
\end{algorithmic}
\end{algorithm}

Der Algorithmus NEST-A wandelt ein geschachteltes Prädikat einer Abfrage in ein einfaches Prädikat um. Mit Algorithmus NEST-JA2 wird ein geschachteltes Prädikat vom Typ-JA in ein geschachteltes Prädikat vom Typ-J umgewandelt. Durch die Anwendung von Algorithmus NEST-N-J nach NEST-JA2 wird dieses Prädikat in ein einfaches Join-Prädikat transformiert. Damit entfernen die beiden Algorithmen NEST-A und NEST-N-J eine Schachtelungsbene aus einem Prädikat. Da NEST-G rekursiv auf die Unterabfragen angewandt wird wird in jedem Schleifendurchlauf des Algorithmus die Schachtelungstiefe eines Prädikats um eins erniedrigt. Da geschachtelte Prädikate eine Schachtelungstiefe $>= 1$ haben, ist sichergestellt, dass der Algorithmus terminiert. Nach Beendigung des Algorithmus enthält die transformierte Version von Q keine geschachtelten Prädikate der Typen A, N-J oder JA. 


allgemeiner Algorithmus zur Entschachtelung mit temporären Tabellen, auf der Basis von Join- und Outerjoin-Operatoren und temporären Tabellen,


Begriffserklärung Schachtelunsgtiefe

Schritte des Optimierers
\begin{itemize}
	\item Query-Rewriting
	\item Schema-Lookup
	\item Abfrageplan-Ermittlung 
	\item Übersetzung Plan in ausführbare Syntax
\end{itemize}


durch vorhanden Operatoren in \textsc{Secondo} fast vollständig umsetzbar, nur Erweiterung um Full-Outerjoin-Operator notwendig\\
Vergleich nested-iteration/dekorrelierter Plan wird \underline{nicht} implementiert:\\
Für den Vergleich der Kosten müsste die komplette Selektivitäts- und Kostenbestimmung für die notwendigen temporären Relationen simuliert werden (**ausführlicher beschreiben**)\\
kann nicht für alle Formen von Subqueries genutzt werden (Beispiele)\\
Ergebnis sollte eine Abfrage der Schachtelungstiefe 0 sein. Der Optimierer 

\begin{enumerate}
	\item Jedes Typ-A Prädikat wird in ein einfaches Prädikat umgewandelt, indem es vollständig ausgewertet wird. Falls das Prädikat ebenfalls geschachtelt ist, wird Algorithmus NEST-G rekursiv angewandt, bis das Prädikat nicht weiter entschachtelt werden kann.
	\item Jedes Typ-JA Prädikat wird mit dem Algorithmus NEST-JA(G) in eine semantisch äquivalente Abfrage vom Typ-N oder -J umgewandelt.
	\item \emph{In dieser Arbeit nicht implementiert}: Prädikate vom Typ-D werden in ihre kanonische Form transformiert. 
	\item Die aus den bisherigen Schritten des Algorithmus resultierende Abfrage hat nur noch Prädikate vom Typ-N oder Typ-J. Diese wird mit dem Algorithmus NEST-N-J in ihre kanonische Form überführt.
\end{enumerate}

%
% EOF
%
%