%
% Kapitel Entwurf
%
%

\chapter{Entwurf}
Der von Kim bzw. Ganski/Wong vorgestellten Algorithmen zur Optimierung geschachtelter Abfragen hat für die Implementierung in \textsc{Secondo} den Vorteil, dass er sich mit der Einführung eines weiteren Operators in die bestehende \textsc{Secondo}-Implementierung integrieren lässt. Zur Umsetzung der Algorithmen sind die vorhandenen Stan\-dard-Ope\-ra\-ti\-on\-en Projektion und Selektion sowie die Operationen Anti-Join und Full-Outer-Join notwendig. Im Rahmen dieser Arbeit wurde ein Full-Outer-Join-Operator für den Fall der Attribut-Gleichheit implementiert. Da sich mit keiner der vorhandenen Join-Algorithmen zur Umsetzung eines effizienten Anti-Join-Algorithmus eignet, wurde auf die Implementierung eines entsprechenden Algorithmus verzichtet. Geschachtelte Abfragen mit dem Operator \sql{not in} werden zwar übersetzt, die entsprechenden Prädikate sind aber keiner weiteren Optimierung zugänglich. 

Bei der Analyse des Problems wurde klar, das eine echte Optimierung, d.h. ein Vergleich der geschachtelten und der nicht geschachtelten Ausführungsvariante einer Abfrage umfangreiche Berechnungen und Simulationen erfordern würde. 

\begin{itemize}
	\item keine automatische Entscheidung entschachteln oder nicht
	\subitem alle Metadaten über temp. Relationen wären notwendig
	\subitem inkl. Selektivitäten
	\item \textbf{IN} ohne Subquery -> Übersetzung in geschachtelte \textbf{OR} Prädikate
\end{itemize}
In \cite{319745} wird gezeigt, dass eine Abfrage der Form 
\begin{lstlisting}
SELECT §$R_i.C_k$§
FROM §$R_i$§
WHERE §$R_i.C_h$§ IN (SELECT §$R_j.C_m$§
											FROM §$R_j$§);
\end{lstlisting}

semantisch äquivalent zu einer Abfrage 

\begin{lstlisting}
SELECT §$R_i.C_k$§
FROM §$R_i, R_j$§
WHERE §$R_i.C_h = R_j.C_m$§
\end{lstlisting}

ist.

Die Mengen basierte Semantik des IN-Operators wird nur dann erhalten, wenn $R_j$ bezüglich der Spalte $C_m$ duplikatfrei ist. Dies kann aber jederzeit erreicht werden, indem $R_j$ durch eine temporäre Relation $R_{j}^{'}$ ersetzt wird. $R_{j}^{'}$ erhält man, indem $R_j$ auf die Spalte $C_m$ eingeschränkt und projiziert wird. Für skalare Vergleichsoperatoren gilt die Äquivalenz ohne diese Einschränkung. Skalare Vergleichsoperatoren sind nicht \enquote{duplikats-entfernend}. 

\section{Behandlung quantifizierter Prädikate}
Prädikate mit den Operatoren \sql{exists}, \sql{all} oder \sql{any} können in eine semantische äquivalentes Prädikat mit Aggregationsfunktion transformiert werden. Das Prädikate \sql{exists(Q)}  ist genau dann wahr, wenn die Ergebnisrelation des Abfrageblocks  Q mindestens ein Tupel enthält. Ist \sql{Q = select $C_n$ from $R_m$ where P}, so lässt sich aber auch als \sql{0 < (select count($C_n$) from $R_m$ where P)} ausdrücken. Analog dazu kann \sql{not exists(select $C_n$ from $R_m$ where P)} in \sql{0 = (select count($C_n$) from $R_m$ where P)} überführt werden. Die Semantik der Operatoren \sql{all} und \sql{any} bleibt ebenfalls erhalten, wenn man Prädikate mit den beiden Operatoren in Prädikate umwandelt, die einen Vergleich mit dem Maximum bzw. Minimum der Unterabfrage darstellen. \sql{$C_n$ $\theta$ any(select $C_m$ from $R_i$ where P)} wird für $\theta \in {<,<=,>,>=}$ transformiert in \sql{$C_n$ $\theta$ (select AGGR($C_n$) from $R_i$ where P)}. Wobei hier gilt
\begin{math}
AGGR = 
\begin{cases}
min&\quad\text{falls}\ \theta < oder \leq, \\
max&\quad\text{falls}\ \theta > oder \geq. 
\end{cases}
\end{math}

Im Spezialfall \sql{$C_n$ = any(select $C_m$ from $R_i$ where P)} wird das Prädikat durch das semantisch äquivalente Prädikat \sql{$C_n$ in (select $C_m$ from $R_i$ where P)} ersetzt.

\section{Algorithmus \textbf{NEST-N-J}}
Ziel des Algorithmus ist es, ein geschachteltes Prädikat in eine semantische äquivalente entschachtelte Form zu überführen. Dafür wird die Konjunktion der WHERE-Klauseln gebildet und um ein Join-Prädikat ergänzt, das aus dem ursprünglich geschachtelten Prädikat abgleitet ist.
Alle FROM-Klausel kombinieren. Die resultierende FROM-Klausel umfasst alle Relationen des inneren und des äußeren Abfrageblocks\\
Die Konjunktion der WHERE-Klauseln bilden.\\
Das geschachtelte Prädikat \begin{math}[R_i.C_h \operatorname{op}\ (\texttt{SELECT} R_j.C_m \dots)]\end{math} ersetzen durch ein neues Join-Prädikat \begin{math}[R_i.C_h \operatorname{\emph{new-op}} R_j.C_m]\end{math}, das mit der restlichen WHERE-Klausel per Konjunktion verbunden ist\\
Die SELECT-Klausel des äußersten Abfrageblocks behalten\\

\begin{lstlisting}
select §$A_1 ,\dots,A_n$§ 
from §$R_1 ,\dots,R_m$§ 
where §$P_1,\dots,P_l,$§ 
	§$X\operatorname{\theta}\ ($§
		select 
			§$T_i.B$§ 
		from 
			§$T_1 ,\dots,T_s$§ 
		where 
			§$Q_1,\dots,Q_r$§
	§$)$§
\end{lstlisting}

wird transformiert in 

\begin{lstlisting}
select §$A_1,\dots,A_n$§
from §$R_1,\dots,R_m,T_1,\dots,T_s$§
where §$P_1,\dots,P_l$§,
	§$Q_1,\dots,Q_r$§
	§$X\operatorname{\theta^'}T_i.B$§
\end{lstlisting}

\begin{math}
X \subset\{A_1,\ldots,A_n\} \\[1em]
\theta \in \{\operatorname{IN},\operatorname{NOT\ IN},=,\not=,>,\geq,<,\leq\} \\[1em]
\theta^{'} = 
\begin{cases}
=&\quad\text{falls}\ \theta = \operatorname{IN}, \\
\not=&\quad\text{falls}\ \theta = \operatorname{NOT\ IN}, \\
\theta&\quad\text{sonst}.
\end{cases}
\end{math}

\section{Algorithmus \textbf{NEST-JA2}}
Um die Auswertung der Aggregation nicht bei jedem Tupel der äußeren Relation durchführen zu müssen, wird mit temporären Tabellen gearbeitet. Es wird die Aggregation über die inneren Relationen gruppiert nach Werten des Join-Attributs der äußeren Spalte vorausberechnet. Da die temporären Relationen persistent abgelegt werden, fällt der Aufwand für ihr Anlegen nur einmal an. Ab der zweiten Ausführung kann auf die bestehenden temporären Relationen zugegriffen werden.
1. temporäre Relation = Projektion der äußeren Relation(en) auf die Join-Spalten und Restriktion durch \emph{simple} Prädikate, die in der äußeren WHERE-Klausel enthalten sind\\
2. temporäre Relation = Join aus 1. temporärer und innerer/en Relationen, falls Aggregationsfunktion = COUNT, dann müssen die simplen Prädikate auf die innere Relation vor dem Join angewandt werden. Ist die Aggregationsfunktion COUNT(*), dann muss COUNT über die/eine Join-Spalte ausgeführt werden. Das Join-Prädikat muss den selben Operator enthalten, wie die ursprüngliche geschachtelte Abfrage. Der Join-Operator in der ursprünglichen Abfrage muss in \emph{=} geändert werden. In der SELECT-Klausel muss die Join-Spalte der äußeren Relation anstelle der Inneren Relation verwendet werden\\

\begin{lstlisting}
select §$A_1,\dots,A_n$§
from §$R_1,\dots,R_m$§
where §$P_1 (R_1 ),\dots,P_k (R_1 )$§,
	§$P_1 ,\ldots,P_l,$§,
	§$R_i.X \operatorname{\theta}\ ($§
		select §$\operatorname{AGGR}(T_j.A)$§
		from §$T_1 ,\dots,T_s$§			
		where §$Q_1 ,\dots,Q_r$§,
			pred§$[R_1.Y \operatorname{op} T_1.Z]$§
	§$)$§
\end{lstlisting}

Die Projektion der äußeren Relation

\begin{lstlisting}
TEMP1 = (
	select distinct §$R_1.Y$§
	from §$R_1$§
	where	§$P_1(R_1),\dots,P_k(R_1)$§
	)
\end{lstlisting}

\begin{lstlisting}
TEMP2 = (
	select §$T_j.A,T_1.Z$§
	from §$T_1,\dots,T_s$§
	where §$Q_1,\dots,Q_r$§
	)
\end{lstlisting}

\begin{lstlisting}
TEMP3 = (
	select §$T_1.Y,\operatorname{AGGR}(T_j.A)$§ as AggrResult
  from TEMP1, TEMP2
  where pred§$[R_1.Y \operatorname{op} T_1.Z]$§
  group by
  	§$T_1.Y$§
  §$)$§
\end{lstlisting}

\begin{lstlisting}
TEMP3 = (
	select §$T_1.Y,\operatorname{AGGR}(T_j.A)$§ as AggrResult
  from TEMP1 outer join TEMP2
    on pred§$[R_1.Y \operatorname{op} T_1.Z]$§
  group by
  	§$T_1.Y$§
  §$)$§
\end{lstlisting}

\begin{lstlisting}
select §$A_1,\dots,A_n$§
from §$R_1,\dots,R_m$§,TEMP3
where §$P_1,\dots,P_l,$§
	§$R_i.X \operatorname{\theta}$§ TEMP3.AggrResult, 
	§$R_1.Y=$§Temp3.Z
\end{lstlisting}

\begin{math}\theta \in\{=,\not=,>,\geq,<,\leq\}\end{math}

allgemeiner Algorithmus zur Entschachtelung mit temporären Tabellen, auf der Basis von Join- und Outerjoin-Operatoren und temporären Tabellen,


Begriffserklärung Schachtelunsgtiefe

Schritte des Optimierers
\begin{itemize}
	\item Query-Rewriting
	\item Schema-Lookup
	\item Abfrageplan-Ermittlung 
	\item Übersetzung Plan in ausführbare Syntax
\end{itemize}


durch vorhanden Operatoren in \textsc{Secondo} fast vollständig umsetzbar, nur Erweiterung um Full-Outerjoin-Operator notwendig\\
Vergleich nested-iteration/dekorrelierter Plan wird \underline{nicht} implementiert:\\
Für den Vergleich der Kosten müsste die komplette Selektivitäts- und Kostenbestimmung für die notwendigen temporären Relationen simuliert werden (**ausführlicher beschreiben**)\\
kann nicht für alle Formen von Subqueries genutzt werden (Beispiele)\\
Ergebnis sollte eine Abfrage der Schachtelungstiefe 0 sein. Der Optimierer 

Schema-Lookup erweitern\\



%
% EOF
%
%