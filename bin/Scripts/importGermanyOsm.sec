/*
0 Preparations

Preparations: 

  * get the OSM-file and put it to correct position, adapt path below

  * create and open database

  * restore Workers

*/


# create database arnsberg5

# open database arnsberg5

# restore WorkersNewton from WorkersNewton


/*
1 Set Parameters

*/

let Workers = WorkersNewton

let NWorkers = 40

let NDatabases = 20

let Slots = 170	



/*
1 Divide Osm-File

*/

query divide_osm2('/home/ralf/Daten/germany-latest.osm', 
 "osmsub", NWorkers)

# query divide_osm2('/home/ralf/Daten/arnsberg-regbez-latest.osm', 
#   "osmsub", NWorkers)


# file has 2.7 GB
# creates files osmsub_0, ..., osmsub_13 in secondo/bin
# arnsberg 2:02 minutes. About 2606 / 122 = 21.36 MB per second.
#
# germany 43:12 min = 2592 seconds
# germany newton: 2291

# germany has 54.9 GB => 2495 seconds = 42 minutes 

# copying 54.88 GB takes less than 20 minutes. 52340 MB / 1200 
# = 43.6 MB / second

/*
2 Start Workers

*/


query Workers feed extend[Started: connect(.Host, .Port, .Config)] 
  consume

/*
3 Open Database on Workers

Also create the database if necessary.

*/
if isDBObject("dbname") then delete dbname endif

let dbname = getDatabaseName()

# query intstream(0, (NWorkers - 1)) namedtransformstream[Server] 
# extend[Cmd: 'close database'] prcmd[Server, Cmd] sortby[Server] consume

# query intstream(0, (NDatabases - 1)) namedtransformstream[Server] 
# extend[Cmd: 'delete database ' + dbname] prcmd[Server, Cmd] sortby[Server] consume

query intstream(0, (NDatabases - 1)) namedtransformstream[Server] 
extend[Cmd: 'create database ' + dbname] prcmd[Server, Cmd] sortby[Server] consume

query intstream(0, (NWorkers - 1)) namedtransformstream[Server] 
extend[Cmd: 'open database ' + dbname] prcmd[Server, Cmd] sortby[Server] consume


/*
4 Transfer Subfiles

*/
query intstream(0, (NWorkers - 1)) namedtransformstream[Server] 
extend[LocalFile: "osmsub_" + num2string(.Server)] 
extend[RemoteFile: .LocalFile] 
psendFile[Server, LocalFile, RemoteFile] consume

# arnsberg 75.31 seconds, 16.59 CPU
# germany 26:53 min = 1613 sec
# germany newton: 1537 sec = 25:37 min

/*
5 Import OSM Data on Workers

*/
let quote = '\''

query intstream(0, (NWorkers - 1)) namedtransformstream[Server] extend[Cmd:
  'query fullosmimport(secondoHome()' + " + " + quote +  "/"  + 
  getSendFolder(.Server) + "/osmsub_" 
  + num2string(.Server) + quote + ', "City", ' + num2string(.Server) + ')'] 
  prcmd[Server, Cmd] consume

# arnsberg 3:12 min
# germany 83:02 min = 4981 seconds
# germany newton: 959 sec = 15:59 min

/*
Terminate use of low level algebra operations by disconnecting from workers.

*/
query disconnect()


/*
6 Create DArrays on Top of Distributed Objects

*/
(let CityNodes_type = (
  (rel (tuple ((NodeId longint) (Lat real) (Lon real)))) 
  () )
)

(let CityNodeTags_type = (
  (rel (tuple ((NodeIdInTag longint) (NodeTagKey text) 
  (NodeTagValue text))))
  () )
)

(let CityWays_type = (
  (rel (tuple ((WayId longint) (NodeCounter int) (NodeRef longint)))) 
  () )
)

(let CityWayTags_type = (
  (rel (tuple ((WayIdInTag longint) (WayTagKey text) 
  (WayTagValue text)))) 
  () )
)

(let CityRelations_type = (
  (rel (tuple ((RelId longint) (RefCounter int) (MemberType text) 
  (MemberRef longint) (MemberRole text)))) 
  () )
)

(let CityRelationTags_type = (
  (rel (tuple ((RelIdInTag longint) (RelTagKey text) 
  (RelTagValue text)))) 
  () )
)


let CityNodesB0 = Workers feed 
  createDArray["CityNodes", NWorkers, CityNodes_type, TRUE]

let CityNodeTagsB0 = Workers feed 
  createDArray["CityNodeTags", NWorkers, CityNodeTags_type, TRUE]

let CityWaysB0 = Workers feed 
  createDArray["CityWays", NWorkers, CityWays_type, TRUE]

let CityWayTagsB0 = Workers feed 
  createDArray["CityWayTags", NWorkers, CityWayTags_type, TRUE]

let CityRelationsB0 = Workers feed 
  createDArray["CityRelations", NWorkers, CityRelations_type, TRUE]

let CityRelationTagsB0 = Workers feed 
  createDArray["CityRelationTags", NWorkers, CityRelationTags_type, TRUE]

# about 4.1 seconds per array

/*
7 Prepare Cost Measurements

*/

let ControlWorkers = intstream(0, NWorkers - 1) transformstream  
  ddistribute3["ControlWorkers", NWorkers, TRUE, Workers]  
  dloop["", . feed extract[Elem]]

@%Scripts/DistCost.sec


/*
8 Redistribute Nodes, Ways, and WayTags

*/
update LastCommand := distCostReset(ControlWorkers)

let CityNodesB1_NodeId = CityNodesB0 partitionF["", . feed, 
  hashvalue(..NodeId, 999997), Slots]
  collect2["CityNodesB1", 1238]

let Cost1 = distCostSave(ControlWorkers);
update LastCommand := distCostReset(ControlWorkers)

# 39:47 min = 2387 seconds
# germany newton: 355 sec = 5:55 min


let CityWaysB1_NodeRef = CityWaysB0 partitionF["", . feed, 
    hashvalue(..NodeRef, 999997), Slots] 
  collect2["CityWaysB1", 1238]

let Cost2 = distCostSave(ControlWorkers);
update LastCommand := distCostReset(ControlWorkers)

# 80:01 min
# germany newton: 842 sec = 14:02 min


let CityWayTagsB1_WayIdInTag = CityWayTagsB0 partitionF["", . feed, 
  hashvalue(..WayIdInTag, 999997), Slots]
  collect2["CityWayTagsB1", 1238]

let Cost3 = distCostSave(ControlWorkers);
update LastCommand := distCostReset(ControlWorkers)

# 2888 + 352.8 seconds = 48:08 min  + 5:53 min
# germany newton: 597 sec = 9:57 min

/*
9 Assign New NodeIds to Nodes Clustered Spatially per Slot

*/
query CityNodesB1_NodeId dloop["", . feed count] getValue

# all values about 4.8 million, all less than 5 million.


let ControlSlots = intstream(0, Slots - 1) transformstream 
  ddistribute3["ControlSlots", Slots, TRUE, Workers] 
  dloop["", . feed extract[Elem]]

update LastCommand := distCostReset(ControlWorkers)

/*
Disjoint numbering of nodes.

*/

let CityNodesNewB1_NodeId = CityNodesB1_NodeId ControlSlots dmap2["CityNodesNewB1", 
  . feed
  extend[Easting: .Lon * 1000000, Northing: .Lat * 1000000]
  extend[Box: rectangle2(.Easting, .Easting, .Northing, .Northing)]
  sortby[Box] 
  projectextend[NodeId;  Pos: makepoint(.Lon, .Lat)]
  addcounter[NodeIdNew, (.. * 5000000) + 1] , 1238]

let Cost5 = distCostSave(ControlWorkers);
update LastCommand := distCostReset(ControlWorkers)

# germany newton: 241 sec = 4:01 min


/*
10 Construct Ways

----
let Ways =
  CityNodesNew feed
  CityWays feed itHashJoin[NodeId, NodeRef] sortby[WayId, NodeCounter] nest[WayId; NodeList]
    extend[Curve  : .NodeList afeed projecttransformstream[Pos] collect_line[TRUE]] 
  CityWayTags feed nest[WayIdInTag; WayInfo] itHashJoin[WayId, WayIdInTag]
  extend[Box: bbox(.Curve scale[1000000.0])]
  sortby[Box]
  remove[Box]
  consume
----

*/

let WaysB1_WayId = CityNodesNewB1_NodeId CityWaysB1_NodeRef dmap2["",
  . feed
  .. feed itHashJoin[NodeId, NodeRef], 1238] 
  partitionF["", . feed, hashvalue(..WayId, 999997), 0]

# arnsberg: 43.29 seconds
# germany newton: 580 sec = 9:40 min, 590 sec = 9:50 min

let WaysB2_WayId = WaysB1_WayId
  collect2["WaysB2", 1238]

# arnsberg: 13.26 seconds
# germany newton: 350 sec = 5:50 min, 328 sec = 5:28 min


# let Cost6 = distCostSave(ControlWorkers);
update LastCommand := distCostReset(ControlWorkers)


let WaysB3_WayId = WaysB2_WayId CityWayTagsB1_WayIdInTag dmap2["", 
  . feed sortby[WayId, NodeCounter] nest[WayId; NodeList]
    extend[Curve  : .NodeList afeed projecttransformstream[Pos] collect_line[TRUE]]
  .. feed sortby[WayIdInTag] nest[WayIdInTag; WayInfo] 
  itHashJoin[WayId, WayIdInTag]
  extend[Box: bbox(.Curve scale[1000000.0])]
  sortby[Box]
  remove[Box]
  consume, 1238]

delete Cost8;
let Cost8 = distCostSave(ControlWorkers);
update LastCommand := distCostReset(ControlWorkers)

# 1:21min (81.3981sec)
# germany newton: 40:16 min = 2416 sec


let Commands = SEC2COMMANDS



















