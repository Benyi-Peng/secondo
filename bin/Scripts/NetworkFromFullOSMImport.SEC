###############################################################################
# Creates a network from data imported by fullosmimport from open street map   #
# osm-File.                                                                    #
################################################################################

###############################################################################
# Create and open database                                                   #
###############################################################################

create database mpDB;

open database mpDB;

###############################################################################
# Set import parameter                                                        #
###############################################################################

let SOURCEFILE = '/home/jandt/Downloads/OSM-Dateien/mecklenburg-vorpommern.osm';

let TABLEPREFIX = "Osm";

###############################################################################
# import osm data from file                                                   #
###############################################################################

query fullosmimport(SOURCEFILE, TABLEPREFIX);

###############################################################################
# Connect Spatial Information for nodes and ways                              #
###############################################################################

let SpatialPosOfNodes =
   OsmNodes feed
   projectextend [NodeId; NodePos: makepoint(.Lon,.Lat)]
consume;

let SpatialWayCurveSimple =
  OsmWays feed
  SpatialPosOfNodes feed
  hashjoin[NodeRef, NodeId, 99997]
  project[WayId, NodeCounter, NodePos]
  sortby [WayId, NodeCounter]
  groupby[WayId; WayCurve: group feed projecttransformstream[NodePos] collect_sline[TRUE]]
consume;

let SpatialWayCurveComplex =
  OsmWays feed
  SpatialWayCurveSimple feed 
    filter[not(isdefined(.WayCurve))] {s}
  hashjoin[WayId, WayId_s]
  project[WayId, NodeCounter, NodeRef]
  SpatialPosOfNodes feed
  hashjoin[NodeRef, NodeId, 99997]
  project[WayId, NodeCounter, NodePos]
  sortby [WayId, NodeCounter]
  groupby[WayId; WayCurve: group feed projecttransformstream[NodePos] collect_line[TRUE],
                 StartPointCurve: group feed head[1] extract[NodePos]]
  projectextendstream[WayId, StartPointCurve; WayC: .WayCurve longlines]
  addcounter[PartNo,1]
  projectextend[WayId, PartNo, StartPointCurve,
    WayC; StartPoint: getstartpoint(.WayC),
      EndPoint: getendpoint(.WayC)]
  sortby[WayId, PartNo]
  extend_last[PrevEndPoint: ..EndPoint :: [const point value(0.0 0.0)]]
  sortby[WayId, PartNo]
  projectextend[WayId; WayCurve: ifthenelse(.StartPointCurve = .StartPoint, .WayC,
                                 ifthenelse(.StartPoint = .PrevEndPoint, .WayC,
                                     set_startsmaller(.WayC, not(get_startsmaller(.WayC)))))]
consume;

let SpatialWayCurve =
  (SpatialWayCurveSimple feed filter [isdefined(.WayCurve)])
  (SpatialWayCurveComplex feed)
  concat
consume;

################################################################################
# Collect tag information by identfier                                         #
################################################################################

let NestedNodeRel =
  SpatialPosOfNodes feed
  OsmNodeTags feed
  hashjoin[NodeId,NodeIdInTag]
  project[NodeId, NodePos, NodeTagKey, NodeTagValue]
  sortby[NodeId, NodePos, NodeTagKey, NodeTagValue]
  rdup
  nest [NodeId, NodePos; NodeInfo]
consume;

let NestedWayRel =
  SpatialWayCurve feed
  OsmWayTags feed
  hashjoin [WayId, WayIdInTag]
  project[WayId, WayCurve, WayTagKey, WayTagValue]
  sortby[WayId, WayCurve, WayTagKey, WayTagValue]
  rdup
  nest[WayId, WayCurve; WayInfo]
  projectextend[WayId, WayInfo; WayC: .WayCurve,
    ChangeDirection: ifthenelse(.WayInfo afeed filter [.WayTagKey = "oneway"]
                                               filter [.WayTagValue = "-1"]
                                            count > 0,
                                TRUE, FALSE)]
  projectextend[WayId, WayInfo; WayCurve: set_startsmaller(.WayC,
                                 ifthenelse(.ChangeDirection,
                                    not(get_startsmaller(.WayC)),
                                    get_startsmaller(.WayC)))]
consume;

let NestedRelationRel =
  OsmRelations feed
  OsmRelationTags feed
  hashjoin[RelId, RelIdInTag]
  project[RelId, RefCounter, MemberRef, MemberType, MemberRole, RelTagKey, RelTagValue]
  sortby[RelId, RefCounter,  MemberRef, MemberType, MemberRole, RelTagKey, RelTagValue]
  rdup
  nest [RelId, RefCounter, MemberRef, MemberType, MemberRole; RefInfo]
  nest [RelId; RelInfo]
consume;

################################################################################
# Build roads defined by relations defined by osm                              #
################################################################################

let RoadParts = 
  NestedWayRel feed
  filter [.WayInfo afeed
    filter[.WayTagKey = "highway"]
    filter[(.WayTagValue contains "living") or
           (.WayTagValue contains "motorway") or
           (.WayTagValue contains "path") or
           (.WayTagValue contains "primary") or
           (.WayTagValue contains "residential") or
           (.WayTagValue contains "road") or
           (.WayTagValue contains "secondary") or
           (.WayTagValue contains "service") or
           (.WayTagValue contains "tertiary") or
           (.WayTagValue contains "trunk") or
           (.WayTagValue contains "track") or
           (.WayTagValue contains "unclassified")]
    count > 0]
consume;

let RoadsByRef =
  RoadParts feed
  filter[.WayInfo afeed
    filter[.WayTagKey = "ref"]
    count > 0]
  filter[.WayInfo afeed
    filter[.WayTagKey = "highway"]
    filter[not(.WayTagValue contains "link")]
    count > 0]
  unnest[WayInfo]
  filter[.WayTagKey = "ref"]
  projectextendstream[WayId, WayCurve; RefToken: tokenize(' '+.WayTagValue,";/")]
  projectextend[WayId, WayCurve; Ref: trim(toObject('"'+.RefToken +'"',"a"))]
  sortby[Ref, WayCurve]
  groupby[Ref; RoadC: group feed projecttransformstream[WayCurve] collect_line[TRUE]]
  projectextendstream[Ref; RoadCurve: .RoadC longlines]
consume;

let RoadsByName =
  RoadParts feed
  filter[.WayInfo afeed
    filter[.WayTagKey = "name"]
    count > 0]
  filter[.WayInfo afeed
    filter[.WayTagKey = "ref"]
    count = 0]
  filter[.WayInfo afeed
    filter[.WayTagKey = "highway"]
    filter[not(.WayTagValue contains "link")]
    count > 0]
  unnest[WayInfo]
  filter[.WayTagKey = "name"]
  projectextend[WayId, WayCurve; Name: trim(toObject('"'+.WayTagValue +'"',"a"))]
  sortby[Name, WayCurve]
  groupby[Name; RoadC: group feed projecttransformstream[WayCurve] collect_line[TRUE]]
  projectextendstream[Name; RoadCurve: .RoadC longlines]
consume;

let RoadLinks =
  RoadParts feed
  filter[.WayInfo afeed
    filter[.WayTagKey = "highway"]
    filter[.WayTagValue contains "link"]
    count > 0]
  unnest[WayInfo]
  filter[.WayTagKey = "highway"]
  filter[.WayTagValue contains "link"]
  project[WayId, WayCurve]
  sortby[WayId, WayCurve]
  groupby[WayId; RoadC: group feed projecttransformstream[WayCurve] collect_line[TRUE]]
  projectextendstream[WayId; RoadCurve: .RoadC longlines]
consume;

let RoadRest =
  RoadParts feed
  filter[.WayInfo afeed
    filter[.WayTagKey contains "ref"]
    count = 0]
  filter [.WayInfo afeed
    filter[.WayTagKey contains "name"]
    count = 0]
  filter [.WayInfo afeed
    filter[.WayTagKey = "highway"]
    filter[.WayTagValue contains "link"]
    count = 0]
  unnest[WayInfo]
  filter[.WayTagKey = "highway"]
  project[WayId, WayCurve]
  sortby[WayId, WayCurve]
  groupby[WayId; RoadC: group feed projecttransformstream[WayCurve] collect_line[TRUE]]
  projectextendstream[WayId; RoadCurve: .RoadC longlines]
consume;

let Roads =
  ((RoadsByRef feed projectextend[;Name: .Ref, Curve: .RoadCurve])
   (RoadsByName feed projectextend[;Name: .Name, Curve: .RoadCurve])
   concat)
  ((RoadLinks feed projectextend[;Name: num2string(.WayId), Curve: .RoadCurve])
   (RoadRest feed projectextend[;Name: num2string(.WayId), Curve: .RoadCurve])
   concat)
  concat
  extend[CurvLength: size(.Curve)]
  sortby [CurvLength desc]
  addcounter[Rid,1]
consume;

###############################################################################
# Build Junctions                                                             #
###############################################################################

let ExtendedRoadParts =
  RoadParts feed
  projectextend[WayId; StartPoint: getstartpoint(.WayCurve),
     EndPoint: getendpoint(.WayCurve)]
consume;

let CrossingPtsTmp =
   RoadParts feed
   unnest[WayInfo]
   filter[.WayTagKey = "layer"]
   projectextend[WayId, WayCurve; Layer: .WayTagValue] {s1}
   RoadParts feed
   unnest[WayInfo]
   filter[.WayTagKey = "layer"]
   projectextend[WayId, WayCurve; Layer: .WayTagValue] {s2}
   itSpatialJoin [WayCurve_s1, WayCurve_s2, 4 ,8]
   filter[(.Layer_s1 = .Layer_s2)]
   filter[.WayId_s1 < .WayId_s2]
   filter[.WayCurve_s1 intersects .WayCurve_s2]
   projectextendstream[WayId_s1,
      WayId_s2; Pt: components(crossings(.WayCurve_s1, .WayCurve_s2))]
   filter[isdefined(.Pt)]
   projectextend[Pt; WayId1: .WayId_s1,
    WayId2: .WayId_s2]
consume;

let CrossingsAndRoadPartEndPoints =
  ((ExtendedRoadParts feed projectextend[WayId; Point: .StartPoint])
  (ExtendedRoadParts feed projectextend[WayId; Point: .EndPoint])
  concat)
  ((CrossingPtsTmp feed projectextend[; WayId: .WayId1, Point: .Pt])
  (CrossingPtsTmp feed projectextend[; WayId: .WayId2, Point: .Pt])
  concat)
  concat
  sortby[WayId, Point]
  rdup
consume;

let JunctionIds =
  CrossingsAndRoadPartEndPoints feed
  project[Point]
  sortby [Point]
  rdup
  addcounter[Jid,1]
consume;

let JunctionPositionsOnRoads =
  CrossingsAndRoadPartEndPoints feed
    filter[isdefined(.Point)]{p1}
  JunctionIds feed
    filter[isdefined(.Point)]{j}
  itSpatialJoin[Point_p1,Point_j,4,8]
  filter [.Point_p1 = .Point_j]
  projectextend[;Jid: .Jid_j,
    Point: .Point_j,
    WayId: .WayId_p1]
  RoadParts feed {w}
  hashjoin[WayId, WayId_w]
  projectextend[Jid, Point,
    WayId; WayCurve: .WayCurve_w,
    WayStartPoint: getstartpoint(.WayCurve_w),
    WayEndPoint: getendpoint(.WayCurve_w)]
  Roads feed {r1}
  itSpatialJoin[Point,Curve_r1,4,8]
  filter[.Point inside .Curve_r1]
  filter[.WayStartPoint inside .Curve_r1]
  filter[.WayEndPoint inside .Curve_r1]
  filter[.WayCurve inside .Curve_r1]
  projectextend[Jid, Point, WayId; Rid: .Rid_r1,
    RMeas: atpoint(.Curve_r1,.Point),
    WayStartPosOnRoute: atpoint(.Curve_r1, .WayStartPoint),
    WayEndPosOnRoute: atpoint(.Curve_r1, .WayEndPoint)]
  sortby[Jid, Point, WayId, Rid, RMeas, WayStartPosOnRoute, WayEndPosOnRoute]
  rdup
consume;

let JunctionRoadPairs =
  JunctionPositionsOnRoads feed {j1}
  JunctionPositionsOnRoads feed {j2}
  hashjoin[Jid_j1, Jid_j2]
  filter[.Rid_j1 <= .Rid_j2]
  projectextend[;Jid: .Jid_j1,
    Point: .Point_j1,
    R1id: .Rid_j1,
    R1Meas: .RMeas_j1,
    R2id: .Rid_j2,
    R2Meas: .RMeas_j2,
    CC: 65535,
    WayId1: .WayId_j1,
    Way1StartPosOnRoute: .WayStartPosOnRoute_j1,
    Way1EndPosOnRoute: .WayEndPosOnRoute_j1,
    WayId2: .WayId_j2,
    Way2StartPosOnRoute: .WayStartPosOnRoute_j2,
    Way2EndPosOnRoute: .WayEndPosOnRoute_j2]
  sortby [Jid, R1id, R1Meas, R2id, R2Meas, CC, Way1StartPosOnRoute,
    Way1EndPosOnRoute, Way2StartPosOnRoute, Way2EndPosOnRoute, WayId1, WayId2]
  krduph[Jid, R1id, R1Meas, R2id, R2Meas, CC, Way1StartPosOnRoute,
    Way1EndPosOnRoute, Way2StartPosOnRoute, Way2EndPosOnRoute]
consume;


###############################################################################
# Compute correct Connectivity Code                                           #
###############################################################################
# Select Onewaycurves                                                         #
###############################################################################
let RoadEndPoints =
    JunctionRoadPairs feed
    sortby [Jid, R1id, R1Meas, R2id, R2Meas]
    groupby [Jid; C: group feed count]
    filter [.C = 1] {s}
    JunctionRoadPairs feed
    hashjoin[Jid_s, Jid]
    filter[.R1id = .R2id]
    filter[.WayId1 = .WayId2]
    projectextend[Jid, R1id, R1Meas, R2id,
      R2Meas; NewCC: ifthenelse(.R1Meas = 0, 16, 1)]
consume;

let OneWayCurveIds =
  NestedWayRel feed
  filter[.WayInfo afeed
    filter[.WayTagKey = "oneway"]
    count > 0]
  project[WayId]
consume;

let JunctionsWithOneWayOnRouteA =
  JunctionRoadPairs feed
    filter[.R1id # .R2id]
    filter[.WayId1 # .WayId2]
  OneWayCurveIds feed
  hashjoin[WayId1, WayId]
  projectextend[Jid, R1id, R1Meas, R2id,
    R2Meas; NewCC: ifthenelse(.Way1StartPosOnRoute < .Way1EndPosOnRoute,
                     ifthenelse(.R1Meas = .Way1EndPosOnRoute,    .CC binand 56797,
                       ifthenelse(.R1Meas = .Way1StartPosOnRoute, .CC binand 65295,
                                                                 .CC binand 56589)),
                     ifthenelse(.R1Meas = .Way1EndPosOnRoute,    .CC binand 61166,
                       ifthenelse(.R1Meas = .Way1StartPosOnRoute,.CC binand 65520,
                                                                 .CC binand 61152)))]
consume;

let JunctionsWithOneWayOnRouteB =
  JunctionRoadPairs feed
    filter [.R1id # .R2id]
    filter [.WayId1 # .WayId2]
  OneWayCurveIds feed
  hashjoin[WayId2, WayId]
  projectextend[Jid, R1id, R1Meas, R2id,
    R2Meas; NewCC: ifthenelse(.Way2StartPosOnRoute < .Way2EndPosOnRoute,
                     ifthenelse(.R2Meas = .Way2EndPosOnRoute,     .CC binand 30583,
                       ifthenelse(.R2Meas = .Way2StartPosOnRoute, .CC binand 4095,
                                                                  .CC binand 1911)),
                     ifthenelse(.R2Meas = .Way2EndPosOnRoute,     .CC binand 48095,
                       ifthenelse(.R2Meas = .Way2StartPosOnRoute, .CC binand 61695,
                                                                  .CC binand 45243)))]
consume;

################################################################################
# Build Relation of Restrictions for way connections                           #
################################################################################

let ViaNodesRel =
  NestedRelationRel feed
  filter [.RelInfo afeed
    filter [.RefInfo afeed
      filter [.RelTagKey contains "restriction"]
      count > 0]
    count > 0]
  unnest [RelInfo]
  filter[.MemberRole = "via"]
  filter [.MemberType = "node"]
  SpatialPosOfNodes feed
  hashjoin[MemberRef,NodeId]
  projectextend[RelId, NodeId,
    NodePos; RelTagVal: .RefInfo afeed extract [RelTagValue]]
consume;

let ViaWaysRel =
  NestedRelationRel feed
  filter [.RelInfo afeed
    filter [.RefInfo afeed
      filter [.RelTagKey contains "restriction"]
      count > 0]
    count > 0]
  unnest [RelInfo]
  filter [.MemberRole = "via"]
  filter [.MemberType = "way"]
  SpatialWayCurve feed
  hashjoin[MemberRef, WayId]
  projectextend[RelId, WayId,
    WayCurve; RelTagVal: .RefInfo afeed extract [RelTagValue]]
consume;

let FromWaysRel =
  NestedRelationRel feed
  filter [.RelInfo afeed
    filter [.RefInfo afeed
      filter [.RelTagKey contains "restriction"]
      count > 0]
    count > 0]
  unnest [RelInfo]
  filter [.MemberRole = "from"]
  SpatialWayCurve feed
  hashjoin[MemberRef, WayId]
  project[RelId, WayId, WayCurve]
consume;

let ToWaysRel =
  NestedRelationRel feed
  filter [.RelInfo afeed
    filter [.RefInfo afeed
      filter [.RelTagKey contains "restriction"]
      count > 0]
    count > 0]
  unnest [RelInfo]
  filter [.MemberRole = "to"]
  SpatialWayCurve feed
  hashjoin[MemberRef, WayId]
  project[RelId, WayId, WayCurve]
consume;

let NodeRestrictions =
  ViaNodesRel feed {v}
  FromWaysRel feed {f}
  hashjoin[RelId_v, RelId_f]
  project [RelId_v, NodeId_v, NodePos_v, RelTagVal_v, WayId_f]
  ToWaysRel feed {t}
  hashjoin[RelId_v, RelId_t]
  project[NodeId_v, NodePos_v, RelTagVal_v, WayId_f, WayId_t]
  sortby [NodeId_v, NodePos_v, WayId_f, WayId_t, RelTagVal_v]
  rdup
consume;

let RestrictedJunctionsAA1 =
  JunctionRoadPairs feed
  NodeRestrictions feed
  itSpatialJoin[Point, NodePos_v,4,8]
  filter[.Point = .NodePos_v]
  filter[.WayId1 = .WayId_f]
  filter[.WayId2 = .WayId_t]
  filter [.R1id = .R2id]
  projectextend [Jid, R1id, R1Meas, R2id,
    R2Meas;NewCC: ifthenelse(.WayId1 = .WayId2,
                    ifthenelse(.Way1StartPosOnRoute < .Way1EndPosOnRoute,
                      ifthenelse(.Way1StartPosOnRoute = .R1Meas, .CC binand 65519,
                                                                 .CC binand 65533),
                      ifthenelse(.Way1StartPosOnRoute = .R1Meas, .CC binand 65533,
                                                                 .CC binand 65519)),
                    ifthenelse(.Way1StartPosOnRoute < .Way1EndPosOnRoute,
                      ifthenelse(.Way1StartPosOnRoute = .R1Meas,
                        ifthenelse(.RelTagVal_v contains "no",   .CC binand 65503,
                                                                 .CC binand 65327),
                        ifthenelse(.RelTagVal_v contains "no",   .CC binand 65534,
                                                                 .CC binand 65521)),
                      ifthenelse(.Way1StartPosOnRoute = .R1Meas,
                        ifthenelse(.RelTagVal_v contains "no",   .CC binand 65534,
                                                                 .CC binand 65521),
                        ifthenelse(.RelTagVal_v contains "no",   .CC binand 65503,
                                                                 .CC binand 65327))))]
  sortby[Jid, R1id, R1Meas, R2id, R2Meas, NewCC]
consume;

let RestrictedJunctionsAA2 =
  JunctionRoadPairs feed
  NodeRestrictions feed
  itSpatialJoin[Point, NodePos_v,4,8]
  filter[.Point = .NodePos_v]
  filter[.WayId2 = .WayId_f]
  filter[.WayId1 = .WayId_t]
  filter [.R1id = .R2id]
  projectextend [Jid, R1id, R1Meas, R2id,
    R2Meas;NewCC: ifthenelse(.WayId1 = .WayId2,
                    ifthenelse(.Way2StartPosOnRoute < .Way2EndPosOnRoute,
                      ifthenelse(.Way2StartPosOnRoute = .R2Meas, .CC binand 65519,
                                                                 .CC binand 65533),
                      ifthenelse(.Way2StartPosOnRoute = .R2Meas, .CC binand 65533,
                                                                 .CC binand 65519)),
                    ifthenelse(.Way2StartPosOnRoute < .Way2EndPosOnRoute,
                      ifthenelse(.Way2StartPosOnRoute = .R2Meas,
                        ifthenelse(.RelTagVal_v contains "no",   .CC binand 65503,
                                                                 .CC binand 65327),
                        ifthenelse(.RelTagVal_v contains "no",   .CC binand 65534,
                                                                 .CC binand 65521)),
                      ifthenelse(.Way2StartPosOnRoute = .R2Meas,
                        ifthenelse(.RelTagVal_v contains "no",   .CC binand 65534,
                                                                 .CC binand 65521),
                        ifthenelse(.RelTagVal_v contains "no",   .CC binand 65503,
                                                                 .CC binand 65327))))]
  sortby[Jid, R1id, R1Meas, R2id, R2Meas, NewCC]
consume;

let RestrictedJunctionsAB =
  JunctionRoadPairs feed
  NodeRestrictions feed
  itSpatialJoin[Point, NodePos_v,4,8]
  filter[.Point = .NodePos_v]
  filter[.WayId1 = .WayId_f]
  filter[.WayId2 = .WayId_t]
  filter[.R1id < .R2id]
  projectextend [Jid, R1id, R1Meas, R2id,
    R2Meas; NewCC: ifthenelse(.WayId1 = .WayId2, 0,
                   ifthenelse(.Way1StartPosOnRoute < .Way1EndPosOnRoute,
                     ifthenelse(.Way2StartPosOnRoute < .Way1EndPosOnRoute,
                       ifthenelse(.Way1StartPosOnRoute = .R1Meas,
                          ifthenelse(.Way2StartPosOnRoute = .R2Meas,
                            ifthenelse(.RelTagVal_v contains "no", .CC binand 65471,
                                                                   .CC binand 65359),
                            ifthenelse(.RelTagVal_v contains "no", .CC binand 65407,
                                                                   .CC binand 65423)),
                          ifthenelse(.Way2StartPosOnRoute = .R2Meas,
                            ifthenelse(.RelTagVal_v contains "no", .CC binand 65531,
                                                                   .CC binand 65524),
                            ifthenelse(.RelTagVal_v contains "no", .CC binand 65527,
                                                                   .CC binand 65528))),
                        ifthenelse(.Way1StartPosOnRoute = .R1Meas,
                          ifthenelse(.Way2StartPosOnRoute = .R2Meas,
                            ifthenelse(.RelTagVal_v contains "no", .CC binand 65407,
                                                                   .CC binand 65423),
                            ifthenelse(.RelTagVal_v contains "no", .CC binand 65471,
                                                                   .CC binand 65359)),
                          ifthenelse(.Way2StartPosOnRoute = .R2Meas,
                            ifthenelse(.RelTagVal_v contains "no", .CC binand 65527,
                                                                   .CC binand 65528),
                            ifthenelse(.RelTagVal_v contains "no", .CC binand 65531,
                                                                   .CC binand 65524)))),
                     ifthenelse(.Way2StartPosOnRoute < .Way1EndPosOnRoute,
                       ifthenelse(.Way1StartPosOnRoute = .R1Meas,
                          ifthenelse(.Way2StartPosOnRoute = .R2Meas,
                            ifthenelse(.RelTagVal_v contains "no", .CC binand 65531,
                                                                   .CC binand 655524),
                            ifthenelse(.RelTagVal_v contains "no", .CC binand 65527,
                                                                   .CC binand 65528)),
                          ifthenelse(.Way2StartPosOnRoute = .R2Meas,
                            ifthenelse(.RelTagVal_v contains "no", .CC binand 65471,
                                                                   .CC binand 65359),
                            ifthenelse(.RelTagVal_v contains "no", .CC binand 65407,
                                                                   .CC binand 65423))),
                        ifthenelse(.Way1StartPosOnRoute = .R1Meas,
                          ifthenelse(.Way2StartPosOnRoute = .R2Meas,
                            ifthenelse(.RelTagVal_v contains "no", .CC binand 65527,
                                                                   .CC binand 65528),
                            ifthenelse(.RelTagVal_v contains "no", .CC binand 65531,
                                                                   .CC binand 65524)),
                          ifthenelse(.Way2StartPosOnRoute = .R2Meas,
                            ifthenelse(.RelTagVal_v contains "no", .CC binand 65407,
                                                                   .CC binand 65423),
                            ifthenelse(.RelTagVal_v contains "no", .CC binand 65471,
                                                                   .CC binand 65359))))))]
  sortby[Jid, R1id, R1Meas, R2id, R2Meas, NewCC]
consume;

let RestrictedJunctionsBA =
  JunctionRoadPairs feed
  NodeRestrictions feed
  itSpatialJoin[Point, NodePos_v,4,8]
  filter[.Point = .NodePos_v]
  filter[.WayId2 = .WayId_f]
  filter[.WayId1 = .WayId_t]
  filter[.R1id < .R2id]
  projectextend [Jid, R1id, R1Meas, R2id,
    R2Meas; NewCC: ifthenelse(.WayId1 = .WayId2,0,
                   ifthenelse(.Way1StartPosOnRoute < .Way1EndPosOnRoute,
                     ifthenelse(.Way2StartPosOnRoute < .Way1EndPosOnRoute,
                       ifthenelse(.Way1StartPosOnRoute = .R1Meas,
                          ifthenelse(.Way2StartPosOnRoute = .R2Meas,
                            ifthenelse(.RelTagVal_v contains "no", .CC binand 61439,
                                                                   .CC binand 8191),
                            ifthenelse(.RelTagVal_v contains "no", .CC binand 65279,
                                                                   .CC binand 61951)),
                          ifthenelse(.Way2StartPosOnRoute = .R2Meas,
                            ifthenelse(.RelTagVal_v contains "no", .CC binand 57343,
                                                                   .CC binand 12287),
                            ifthenelse(.RelTagVal_v contains "no", .CC binand 65023,
                                                                   .CC binand 62207))),
                        ifthenelse(.Way1StartPosOnRoute = .R1Meas,
                          ifthenelse(.Way2StartPosOnRoute = .R2Meas,
                            ifthenelse(.RelTagVal_v contains "no", .CC binand 65279,
                                                                   .CC binand 61951),
                            ifthenelse(.RelTagVal_v contains "no", .CC binand 61439,
                                                                   .CC binand 8191)),
                          ifthenelse(.Way2StartPosOnRoute = .R2Meas,
                            ifthenelse(.RelTagVal_v contains "no", .CC binand 65023,
                                                                   .CC binand 62207),
                            ifthenelse(.RelTagVal_v contains "no", .CC binand 57343,
                                                                   .CC binand 12287)))),
                     ifthenelse(.Way2StartPosOnRoute < .Way1EndPosOnRoute,
                       ifthenelse(.Way1StartPosOnRoute = .R1Meas,
                          ifthenelse(.Way2StartPosOnRoute = .R2Meas,
                            ifthenelse(.RelTagVal_v contains "no", .CC binand 57343,
                                                                   .CC binand 12287),
                            ifthenelse(.RelTagVal_v contains "no", .CC binand 65023,
                                                                   .CC binand 62207)),
                          ifthenelse(.Way2StartPosOnRoute = .R2Meas,
                            ifthenelse(.RelTagVal_v contains "no", .CC binand 61439,
                                                                   .CC binand 8191),
                            ifthenelse(.RelTagVal_v contains "no", .CC binand 65279,
                                                                   .CC binand 61951))),
                        ifthenelse(.Way1StartPosOnRoute = .R1Meas,
                          ifthenelse(.Way2StartPosOnRoute = .R2Meas,
                            ifthenelse(.RelTagVal_v contains "no", .CC binand 65023,
                                                                   .CC binand 62207),
                            ifthenelse(.RelTagVal_v contains "no", .CC binand 57343,
                                                                   .CC binand 12287)),
                          ifthenelse(.Way2StartPosOnRoute = .R2Meas,
                            ifthenelse(.RelTagVal_v contains "no", .CC binand 65279,
                                                                   .CC binand 61951),
                            ifthenelse(.RelTagVal_v contains "no", .CC binand 61439,
                                                                   .CC binand 8191))))))]
  sortby[Jid, R1id, R1Meas, R2id, R2Meas, NewCC]
consume;

let Junctions =
  (((JunctionsWithOneWayOnRouteA feed)
    (JunctionsWithOneWayOnRouteB feed)
    concat)
   ((RestrictedJunctionsAA1 feed)
    (RestrictedJunctionsAA2 feed)
   concat)
  concat)
   (((RestrictedJunctionsAB feed)
    (RestrictedJunctionsBA feed)
   concat)
   (JunctionRoadPairs feed projectextend[Jid, R1id, R1Meas, R2id, R2Meas; NewCC: .CC])
   concat)
  concat
  project[Jid, R1id, R1Meas, R2id, R2Meas, NewCC]
  sortby[Jid, R1id, R1Meas, R2id, R2Meas]
  groupby[Jid, R1id, R1Meas, R2id,
    R2Meas; CC: group feed projecttransformstream[NewCC] binands]
consume;

###############################################################################
# Way Restrictions can not be encoded now in the network data format now      #
# Because we have no information from where the car comes before in the       #
# network data model                                                          #
###############################################################################

let WayRestrictions =
  ViaWaysRel feed {v}
  FromWaysRel feed {f}
  hashjoin[RelId_v, RelId_f]
  project [RelId_v, WayId_v, WayCurve_v, RelTagVal_v, WayId_f, WayCurve_f]
  ToWaysRel feed {t}
  hashjoin[RelId_v, RelId_t]
  project[WayId_v, WayCurve_v, RelTagVal_v, WayId_f, WayCurve_f, WayId_t, WayCurve_t]
  sortby[WayId_v, WayId_f, WayId_t, RelTagVal_v, WayCurve_v, WayCurve_f, WayCurve_t]
  rdup
consume;

##############################################################################
# Build network with all possible restrictions                               #
##############################################################################

let OsmNetwork = thenetwork(1, 0.0001,
    Roads feed projectextend[Rid, CurvLength, Curve; Dual: TRUE, StartS: get_startsmaller(.Curve)] consume,
    Junctions feed project [R1id, R1Meas, R2id, R2Meas, CC] consume);

close database;
quit;


