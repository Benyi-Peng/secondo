###############################################################################
# Creates a network from data imported by fullosmimport from open street map   #
# osm-File.                                                                    #
################################################################################

###############################################################################
# Create and open database                                                   #
###############################################################################

create database keDB;

open database keDB;

###############################################################################
# Set import parameter                                                        #
###############################################################################

let SOURCEFILE = '/home/jandt/Downloads/OSM-Dateien/KL_Enkenbach.osm';

###############################################################################
# import osm data from file                                                   #
###############################################################################

query fullosmimport(SOURCEFILE, "Osm");

################################################################################
# Extend taginformation with default values for needed but not yet set tags    #
################################################################################

let WayIdsWithoutTags =
  OsmWays feed
  project [WayId]
  sortby[WayId]
  OsmWayTags feed
  projectextend[;WayId: .WayIdInTag]
  sortby [WayId]
  rdup
  mergediff
consume;

let OsmWayTagsLayerExtended =
  OsmWayTags feed
  sortby [WayIdInTag]
  groupby [WayIdInTag; C: group feed
                            filter [.WayTagKey = "layer"]
                          count]
  filter [.C = 0]
  projectextend [WayIdInTag; WayTagKey: 'layer',
                  WayTagValue: '0']
consume;

let LayerTagForWayIdsWithoutTag =
  WayIdsWithoutTags feed
  projectextend[; WayIdInTag: .WayId,
    WayTagKey: 'layer',
    WayTagValue: '0']
consume;

let OsmWayTagNew =
  ((OsmWayTags feed)
  (OsmWayTagsLayerExtended feed)
  concat)
  (LayerTagForWayIdsWithoutTag feed)
  concat
consume;

###############################################################################
# Connect Spatial Information for nodes and ways                              #
###############################################################################

let SpatialPosOfNodes =
   OsmNodes feed
   projectextend [NodeId; NodePos: makepoint(.Lon,.Lat)]
consume;

let SpatialWayCurveSimple =
  OsmWays feed
  SpatialPosOfNodes feed
  hashjoin[NodeRef, NodeId, 99997]
  project[WayId, NodeCounter, NodePos]
  sortby [WayId, NodeCounter]
  groupby[WayId; WayCurve: group feed projecttransformstream[NodePos] collect_sline[TRUE]]
consume;

let SpatialWayCurveComplex =
  OsmWays feed
  SpatialWayCurveSimple feed 
    filter[not(isdefined(.WayCurve))] {s}
  hashjoin[WayId, WayId_s]
  project[WayId, NodeCounter, NodeRef]
  SpatialPosOfNodes feed
  hashjoin[NodeRef, NodeId, 99997]
  project[WayId, NodeCounter, NodePos]
  sortby [WayId, NodeCounter]
  groupby[WayId; WayCurve: group feed projecttransformstream[NodePos] collect_line[TRUE],
                 StartPointCurve: group feed head[1] extract[NodePos]]
  projectextendstream[WayId, StartPointCurve; WayC: .WayCurve longlines]
  addcounter[PartNo,1]
  projectextend[WayId, PartNo, StartPointCurve,
    WayC; StartPoint: getstartpoint(.WayC),
      EndPoint: getendpoint(.WayC)]
  sortby[WayId, PartNo]
  extend_last[PrevEndPoint: ..EndPoint :: [const point value(0.0 0.0)]]
  sortby[WayId, PartNo]
  projectextend[WayId; WayCurve: ifthenelse(.StartPointCurve = .StartPoint, .WayC,
                                 ifthenelse(.StartPoint = .PrevEndPoint, .WayC,
                                     set_startsmaller(.WayC, not(get_startsmaller(.WayC)))))]
consume;

let SpatialWayCurve =
  (SpatialWayCurveSimple feed filter [isdefined(.WayCurve)])
  (SpatialWayCurveComplex feed)
  concat
  filter [isdefined(.WayCurve)]
consume;

################################################################################
# Collect tag information by identfier                                         #
################################################################################

let NestedNodeRel =
  SpatialPosOfNodes feed
  OsmNodeTags feed
  hashjoin[NodeId,NodeIdInTag]
  project[NodeId, NodePos, NodeTagKey, NodeTagValue]
  sortby[NodeId, NodePos, NodeTagKey, NodeTagValue]
  rdup
  nest [NodeId, NodePos; NodeInfo]
consume;

let NestedWayRel =
  SpatialWayCurve feed
  OsmWayTagNew feed
  hashjoin [WayId, WayIdInTag]
  project[WayId, WayCurve, WayTagKey, WayTagValue]
  sortby[WayId, WayCurve, WayTagKey, WayTagValue]
  rdup
  nest[WayId, WayCurve; WayInfo]
  projectextend[WayId, WayInfo; WayC: .WayCurve,
    ChangeDirection: ifthenelse(.WayInfo afeed filter [.WayTagKey = "oneway"]
                                               filter [.WayTagValue = "-1"]
                                            count > 0,
                                TRUE, FALSE)]
  projectextend[WayId, WayInfo; WayCurve: ifthenelse(.ChangeDirection,
                        set_startsmaller(.WayC, not(get_startsmaller(.WayC))),
                        .WayC)]
consume;

let NestedRelationRel =
  OsmRelations feed
  OsmRelationTags feed
  hashjoin[RelId, RelIdInTag]
  project[RelId, RefCounter, MemberRef, MemberType, MemberRole, RelTagKey, RelTagValue]
  sortby[RelId, RefCounter,  MemberRef, MemberType, MemberRole, RelTagKey, RelTagValue]
  rdup
  nest [RelId, RefCounter, MemberRef, MemberType, MemberRole; RefInfo]
  nest [RelId; RelInfo]
consume;

################################################################################
# Build roads defined by relations defined by osm                              #
################################################################################

let RoadParts = 
  NestedWayRel feed
  filter [.WayInfo afeed
    filter[.WayTagKey = "highway"]
    filter[(.WayTagValue contains "living") or
           (.WayTagValue contains "motorway") or
           (.WayTagValue contains "path") or
           (.WayTagValue contains "primary") or
           (.WayTagValue contains "residential") or
           (.WayTagValue contains "road") or
           (.WayTagValue contains "secondary") or
           (.WayTagValue contains "service") or
           (.WayTagValue contains "tertiary") or
           (.WayTagValue contains "trunk") or
           (.WayTagValue contains "track") or
           (.WayTagValue contains "unclassified") or
           (.WayTagValue contains "pedestrian")]
    count > 0]
  filter [isdefined(.WayCurve)]
  filter [not(isempty(.WayCurve))]
consume;

let RoadsByRefH1 =
  RoadParts feed
  filter[not(iscycle(.WayCurve))]
  filter[.WayInfo afeed
    filter[.WayTagKey = "oneway"]
    count = 0]
  filter[.WayInfo afeed
    filter[.WayTagKey = "ref"]
    count > 0]
  filter[.WayInfo afeed
    filter[.WayTagKey = "highway"]
    filter[not(.WayTagValue contains "link")]
    count > 0]
  unnest[WayInfo]
  filter[.WayTagKey = "ref"]
  projectextendstream[WayId, WayCurve; RefToken: tokenize(' '+.WayTagValue,";/")]
  projectextend[WayId, WayCurve; Ref: trim(toObject('"'+.RefToken +'"',"a"))]
  sortby[Ref, WayCurve]
consume;

let RoadsByRefSimpleH1 =
  RoadsByRefH1 feed
  sortby[Ref, WayCurve]
  groupby[Ref; C: group feed count]
consume;

let RoadsByRefSimpleH2 =
  RoadsByRefSimpleH1 feed
  filter [.C = 1] {r1}
  RoadsByRefH1 feed {r2}
  hashjoin[Ref_r1, Ref_r2]
  projectextend[; Ref: .Ref_r1,
    RoadCurve: .WayCurve_r2]
consume;

let RoadsByRefSimpleH3 = 
  RoadsByRefSimpleH1 feed
  filter [.C > 1] {r1}
  RoadsByRefH1 feed {r2}
  hashjoin[Ref_r1, Ref_r2]
  projectextend[; Ref: .Ref_r2,
    WayCurve: .WayCurve_r2]
  sortby[Ref, WayCurve]
  groupby[Ref; RoadC: group feed projecttransformstream[WayCurve] collect_sline[TRUE]]
  projectextend[Ref; RoadCurve: .RoadC]
consume;

let RoadsByRefSimple =
  (RoadsByRefSimpleH2 feed)
  (RoadsByRefSimpleH3 feed)
  concat
  sortby[Ref, RoadCurve]
consume;

let RoadsByRefComplex =
  RoadsByRefH1 feed
  sortby[Ref, WayCurve]
  RoadsByRefSimple feed
    filter[not(isdefined(.RoadCurve))] {s}
  hashjoin[Ref, Ref_s]
  projectextend[Ref, WayCurve; StartPoint: getstartpoint(.WayCurve)]
  sortby[Ref, WayCurve, StartPoint]
  groupby[Ref; RoadC: group feed projecttransformstream[WayCurve] collect_line[TRUE],
               StartPointCurve: group feed head[1] extract[StartPoint]]
  projectextendstream[Ref, StartPointCurve; RoadCur: .RoadC longlines]
  addcounter[PartNo,1]
  projectextend[Ref, PartNo, StartPointCurve,
    RoadCur; StartPoint: getstartpoint(.RoadCur),
      EndPoint: getendpoint(.RoadCur)]
  sortby[Ref, PartNo]
  extend_last[PrevEndPoint: ..EndPoint :: [const point value(0.0 0.0)]]
  sortby[Ref, PartNo]
  projectextend[Ref; RoadCurve: ifthenelse(.StartPointCurve = .StartPoint, .RoadCur,
                               ifthenelse(.StartPoint = .PrevEndPoint, .RoadCur,
                                     set_startsmaller(.RoadCur, not(get_startsmaller(.RoadCur)))))]
consume;

let RoadsByRef =
  (RoadsByRefSimple feed filter [isdefined(.RoadCurve)])
  (RoadsByRefComplex feed)
  concat
  filter [isdefined(.RoadCurve)]
consume;

let RoadsByNameH1 =
  RoadParts feed
  filter[not(iscycle(.WayCurve))]
  filter[.WayInfo afeed
    filter[.WayTagKey = "oneway"]
    count = 0]
  filter[.WayInfo afeed
    filter[.WayTagKey = "name"]
    count > 0]
  filter[.WayInfo afeed
    filter[.WayTagKey = "ref"]
    count = 0]
  filter[.WayInfo afeed
    filter[.WayTagKey = "highway"]
    filter[not(.WayTagValue contains "link")]
    count > 0]
  unnest[WayInfo]
  filter[.WayTagKey = "name"]
  projectextend[WayId, WayCurve; Name: trim(toObject('"'+.WayTagValue +'"',"a"))]
  sortby[Name, WayCurve]
consume;

let RoadsByNameSimpleH1 =
  RoadsByNameH1 feed
  sortby[Name, WayCurve]
  groupby[Name; C: group feed count]
consume;

let RoadsByNameSimpleH2 =
  RoadsByNameSimpleH1 feed
  filter [.C = 1] {r1}
  RoadsByNameH1 feed {r2}
  hashjoin[Name_r1, Name_r2]
  projectextend[;Name: .Name_r1,
    RoadCurve: .WayCurve_r2]
consume;

let RoadsByNameSimpleH3 =
  RoadsByNameSimpleH1 feed
  filter [.C > 1] {r1}
  RoadsByNameH1 feed {r2}
  hashjoin[Name_r1, Name_r2]
  projectextend[; Name: .Name_r1, WayCurve: .WayCurve_r2]
  sortby[Name, WayCurve]
  groupby[Name; RoadC: group feed projecttransformstream[WayCurve] collect_sline[TRUE]]
  projectextend[Name; RoadCurve: .RoadC]
consume;

let RoadsByNameSimple =
  (RoadsByNameSimpleH2 feed)
  (RoadsByNameSimpleH3 feed)
   concat
   sortby[Name, RoadCurve]
consume;

let RoadsByNameComplex =
  RoadsByNameH1 feed
  RoadsByNameSimple feed
    filter[not(isdefined(.RoadCurve))] {s}
  hashjoin[Name, Name_s]
  projectextend[Name, WayCurve; StartPoint: getstartpoint(.WayCurve)]
  sortby[Name, WayCurve, StartPoint]
  groupby[Name; RoadC: group feed projecttransformstream[WayCurve] collect_line[TRUE],
               StartPointCurve: group feed head[1] extract[StartPoint]]
  projectextendstream[Name, StartPointCurve; RoadCur: .RoadC longlines]
  addcounter[PartNo,1]
  projectextend[Name, PartNo, StartPointCurve,
    RoadCur; StartPoint: getstartpoint(.RoadCur),
      EndPoint: getendpoint(.RoadCur)]
  sortby[Name, PartNo]
  extend_last[PrevEndPoint: ..EndPoint :: [const point value(0.0 0.0)]]
  sortby[Name, PartNo]
  projectextend[Name; RoadCurve: ifthenelse(.StartPointCurve = .StartPoint, .RoadCur,
                                   ifthenelse(.StartPoint = .PrevEndPoint, .RoadCur,
                                     set_startsmaller(.RoadCur, not(get_startsmaller(.RoadCur)))))]
consume;

let RoadsByName =
  (RoadsByNameSimple feed filter [isdefined(.RoadCurve)])
  (RoadsByNameComplex feed)
  concat
  filter [isdefined(.RoadCurve)]
consume;

let RoadLinksH1 =
  RoadParts feed
  filter[not(iscycle(.WayCurve))]
  filter[.WayInfo afeed
    filter[.WayTagKey = "oneway"]
    count = 0]
  filter[.WayInfo afeed
    filter[.WayTagKey = "highway"]
    filter[.WayTagValue contains "link"]
    count > 0]
  unnest[WayInfo]
  filter[.WayTagKey = "highway"]
  filter[.WayTagValue contains "link"]
  project[WayId, WayCurve]
  sortby[WayId, WayCurve]
consume;

let RoadLinksSimpleH1 =
  RoadLinksH1 feed
  sortby[WayId, WayCurve]
  groupby[WayId; C: group feed count]
consume;

let RoadLinksSimpleH2  =
  RoadLinksSimpleH1 feed
  filter [.C = 1] {r1}
  RoadLinksH1 feed {r2}
  hashjoin [WayId_r1, WayId_r2]
  projectextend[; WayId: .WayId_r1,
    RoadCurve: .WayCurve_r2]
consume;

let RoadLinksSimpleH3 =
  RoadLinksSimpleH1 feed
  filter [.C > 1] {r1}
  RoadLinksH1 feed {r2}
  hashjoin [WayId_r1, WayId_r2]
  projectextend[;  WayId: .WayId_r1,
    WayCurve: .WayCurve_r2]
  sortby[WayId, WayCurve]
  groupby[WayId; RoadC: group feed projecttransformstream[WayCurve] collect_sline[TRUE]]
  projectextend[WayId; RoadCurve: .RoadC]
consume;

let RoadLinksSimple =
  (RoadLinksSimpleH2 feed)
  (RoadLinksSimpleH3 feed)
  concat
  sortby[WayId, RoadCurve]
consume;

let RoadLinksComplex =
  RoadLinksH1 feed
  RoadLinksSimple feed
    filter[not(isdefined(.RoadCurve))] {s}
  hashjoin[WayId, WayId_s]
  projectextend[WayId, WayCurve; StartPoint: getstartpoint(.WayCurve)]
  sortby[WayId, WayCurve, StartPoint]
  groupby[WayId; RoadC: group feed projecttransformstream[WayCurve] collect_line[TRUE],
               StartPointCurve: group feed head[1] extract[StartPoint]]
  projectextendstream[WayId, StartPointCurve; RoadCur: .RoadC longlines]
  addcounter[PartNo,1]
  projectextend[WayId, PartNo, StartPointCurve,
    RoadCur; StartPoint: getstartpoint(.RoadCur),
      EndPoint: getendpoint(.RoadCur)]
  sortby[WayId, PartNo]
  extend_last[PrevEndPoint: ..EndPoint :: [const point value(0.0 0.0)]]
  sortby[WayId, PartNo]
  projectextend[WayId; RoadCurve: ifthenelse(.StartPointCurve = .StartPoint, .RoadCur,
                                    ifthenelse(.StartPoint = .PrevEndPoint, .RoadCur,
                                       set_startsmaller(.RoadCur, not(get_startsmaller(.RoadCur)))))]
consume;

let RoadLinks =
  (RoadLinksSimple feed filter [isdefined(.RoadCurve)])
  (RoadLinksComplex feed)
  concat
  filter [isdefined(.RoadCurve)]
consume;

let RoadRestH1 =
  RoadParts feed
  filter[not(iscycle(.WayCurve))]
  filter[.WayInfo afeed
    filter[.WayTagKey = "oneway"]
    count = 0]
  filter[.WayInfo afeed
    filter[.WayTagKey contains "ref"]
    count = 0]
  filter [.WayInfo afeed
    filter[.WayTagKey contains "name"]
    count = 0]
  filter [.WayInfo afeed
    filter[.WayTagKey = "highway"]
    filter[.WayTagValue contains "link"]
    count = 0]
  unnest[WayInfo]
  filter[.WayTagKey = "highway"]
  project[WayId, WayCurve]
  sortby[WayId, WayCurve]
consume;

let RoadRestSimpleH1 =
  RoadRestH1 feed
  sortby[WayId, WayCurve]
  groupby[WayId; C: group feed count]
consume;

let RoadRestSimpleH2 =
  RoadRestSimpleH1 feed
  filter [.C = 1] {r1}
  RoadRestH1 feed {r2}
  hashjoin[WayId_r1, WayId_r2]
  projectextend[; WayId: .WayId_r1,
    RoadCurve: .WayCurve_r2]
consume;

let RoadRestSimpleH3 =
  RoadRestSimpleH1 feed
  filter [.C > 1] {r1}
  RoadRestH1 feed {r2}
  hashjoin[WayId_r1, WayId_r2]
  projectextend[; WayId: .WayId_r1,
    WayCurve: .WayCurve_r2]
  sortby[WayId, WayCurve]
  groupby[WayId; RoadC: group feed projecttransformstream[WayCurve] collect_sline[TRUE]]
  projectextend[WayId; RoadCurve: .RoadC]
consume;

let RoadRestSimple =
  (RoadRestSimpleH2 feed)
  (RoadRestSimpleH3 feed)
  concat
  sortby[WayId, RoadCurve]
consume;

let RoadRestComplex =
  RoadRestH1 feed
  RoadRestSimple feed
    filter[not(isdefined(.RoadCurve))] {s}
  hashjoin[WayId, WayId_s]
  projectextend[WayId, WayCurve; StartPoint: getstartpoint(.WayCurve)]
  sortby[WayId, WayCurve, StartPoint]
  groupby[WayId; RoadC: group feed projecttransformstream[WayCurve] collect_line[TRUE],
               StartPointCurve: group feed head[1] extract[StartPoint]]
  projectextendstream[WayId, StartPointCurve; RoadCur: .RoadC longlines]
  addcounter[PartNo,1]
  projectextend[WayId, PartNo, StartPointCurve,
    RoadCur; StartPoint: getstartpoint(.RoadCur),
      EndPoint: getendpoint(.RoadCur)]
  sortby[WayId, PartNo]
  extend_last[PrevEndPoint: ..EndPoint :: [const point value(0.0 0.0)]]
  sortby[WayId, PartNo]
  projectextend[WayId; RoadCurve: ifthenelse(.StartPointCurve = .StartPoint, .RoadCur,
                               ifthenelse(.StartPoint = .PrevEndPoint, .RoadCur,
                                     set_startsmaller(.RoadCur, not(get_startsmaller(.RoadCur)))))]
consume;

let RoadRest =
  (RoadRestSimple feed filter [isdefined(.RoadCurve)])
  (RoadRestComplex feed)
  concat
  filter [isdefined(.RoadCurve)]
consume;

let RoadsByOneway =
  RoadParts feed
  filter [not(iscycle(.WayCurve))]
  filter [.WayInfo afeed
    filter [.WayTagKey = "oneway"]
    count > 0]
  projectextend[; Name: num2string(.WayId), Curve: .WayCurve]
consume;
  
let RoadsByCycle =
  RoadParts feed
  filter[iscycle(.WayCurve)]
  projectextend[;Name: num2string(.WayId),
    Curve: set_startsmaller(.WayCurve, TRUE)]
consume;

let Roads =
  ( ( (RoadsByRef feed
         projectextend[;Name: .Ref, Curve: .RoadCurve])
      (RoadsByName feed
         projectextend[;Name: .Name, Curve: .RoadCurve])
      concat)
    ( (RoadLinks feed
         projectextend[;Name: num2string(.WayId), Curve: .RoadCurve])
      (RoadRest feed
         projectextend[;Name: num2string(.WayId), Curve: .RoadCurve])
      concat)
    concat)
  ( (RoadsByCycle feed)
    (RoadsByOneway feed)
    concat)
  concat
  filter [isdefined(.Curve)]
  extend[CurvLength: size(.Curve)]
  sortby [CurvLength desc]
  addcounter[Rid,1]
consume;

###############################################################################
# Build Junctions                                                             #
###############################################################################

let ExtendedRoadParts =
  RoadParts feed
  projectextend[WayId; StartPoint: getstartpoint(.WayCurve),
     EndPoint: getendpoint(.WayCurve)]
consume;

let CrossingPtsTmpH1 =
   RoadParts feed
   unnest[WayInfo]
   filter[.WayTagKey = "layer"]
   projectextend[WayId, WayCurve; Layer: .WayTagValue]
consume;

let CrossingPtsTmp =
   CrossingPtsTmpH1 feed {s1}
   CrossingPtsTmpH1 feed {s2}
   itSpatialJoin [WayCurve_s1, WayCurve_s2, 4 ,8]
   filter[(.Layer_s1 = .Layer_s2)]
   filter[.WayId_s1 < .WayId_s2]
   filter[.WayCurve_s1 intersects .WayCurve_s2]
   projectextendstream[WayId_s1,
      WayId_s2; Pt: components(crossings(.WayCurve_s1, .WayCurve_s2))]
   filter[isdefined(.Pt)]
   projectextend[Pt; WayId1: .WayId_s1,
    WayId2: .WayId_s2]
consume;

let CrossingsAndRoadPartEndPoints =
  ((ExtendedRoadParts feed projectextend[WayId; Point: .StartPoint])
  (ExtendedRoadParts feed projectextend[WayId; Point: .EndPoint])
  concat)
  ((CrossingPtsTmp feed projectextend[; WayId: .WayId1, Point: .Pt])
  (CrossingPtsTmp feed projectextend[; WayId: .WayId2, Point: .Pt])
  concat)
  concat
  sortby[WayId, Point]
  krduph[WayId, Point]
consume;

let RoadEnds =
  Roads feed
  projectextend[Rid; StartPoint: getstartpoint(.Curve),
    EndPoint: getendpoint(.Curve)]
consume;

let RoadEndPointsA =
  (RoadEnds feed projectextend[Rid; Point: .StartPoint])
  (RoadEnds feed projectextend[Rid; Point: .EndPoint])
  concat
  sortby[Rid, Point]
  rdup
consume;

let AddJuncs =
  RoadEndPointsA feed
    project[Point]
    sortby[Point]
  CrossingsAndRoadPartEndPoints feed
    project[Point]
    sortby[Point]
  mergediff
consume;

let JunctionIds =
  (CrossingsAndRoadPartEndPoints feed project[Point])
  (AddJuncs feed)
  concat
  sortby [Point]
  rdup
  filter [isdefined(.Point)]
  addcounter[Jid,1]
consume;

let JunctionPositionsOnRoads1 =
  CrossingsAndRoadPartEndPoints feed
    filter[isdefined(.Point)]{p1}
  JunctionIds feed
    filter[isdefined(.Point)]{j}
  itSpatialJoin[Point_p1,Point_j,4,8]
  filter [.Point_p1 = .Point_j]
  projectextend[;Jid: .Jid_j,
    Point: .Point_j,
    WayId: .WayId_p1]
  RoadParts feed {w}
  hashjoin[WayId, WayId_w]
  projectextend[Jid, Point,
    WayId; WayCurve: .WayCurve_w,
    WayStartPoint: getstartpoint(.WayCurve_w),
    WayEndPoint: getendpoint(.WayCurve_w)]
  Roads feed {r1}
  itSpatialJoin[Point,Curve_r1,4,8]
  filter[.Point inside .Curve_r1]
  filter[.WayStartPoint inside .Curve_r1]
  filter[.WayEndPoint inside .Curve_r1]
  filter[.WayCurve inside .Curve_r1]
  projectextend[Jid, Point, WayId; Rid: .Rid_r1,
    RMeas: atpoint(.Curve_r1,.Point),
    WayStartPosOnRoute: atpoint(.Curve_r1, .WayStartPoint),
    WayEndPosOnRoute: atpoint(.Curve_r1, .WayEndPoint)]
  sortby[Jid, Point, WayId, Rid, RMeas, WayStartPosOnRoute, WayEndPosOnRoute]
  rdup
consume;


let JunctionPositionsOnRoads2 =
  CrossingsAndRoadPartEndPoints feed
    filter[isdefined(.Point)]{p1}
  JunctionIds feed
    filter[isdefined(.Point)]{j}
  itSpatialJoin[Point_p1,Point_j,4,8]
  filter [.Point_p1 = .Point_j]
  projectextend[;Jid: .Jid_j,
    Point: .Point_j,
    WayId: .WayId_p1]
  sortby[Jid, Point, WayId]
  JunctionPositionsOnRoads1 feed
  project[Jid, Point, WayId]
  sortby[Jid, Point, WayId]
  mergediff
  RoadParts feed {w}
  hashjoin[WayId, WayId_w]
  projectextend[Jid, Point,
    WayId; WayCurve: .WayCurve_w,
    WayStartPoint: getstartpoint(.WayCurve_w),
    WayEndPoint: getendpoint(.WayCurve_w)]
  Roads feed {r1}
  itSpatialJoin[Point,Curve_r1,4,8]
  filter[.Point inside .Curve_r1]
  projectextend[Jid, Point, WayId; Rid: .Rid_r1,
    RMeas: atpoint(.Curve_r1,.Point),
    WayStartPosOnRoute: atpoint(.Curve_r1, getstartpoint(intersection(.WayCurve, .Curve_r1))),
    WayEndPosOnRoute: atpoint(.Curve_r1, getendpoint(intersection(.WayCurve, .Curve_r1)))]
  sortby[Jid, Point, WayId, Rid, RMeas, WayStartPosOnRoute, WayEndPosOnRoute]
  rdup
consume;

let JunctionPositionsOnRoads =
  (JunctionPositionsOnRoads1 feed)
  (JunctionPositionsOnRoads2 feed)
  concat
consume;

let JunctionsAtRoadEnds =
  RoadEndPointsA feed filter[isdefined(.Point)] {r}
  JunctionIds feed filter [isdefined(.Point)] {j}
  itSpatialJoin[Point_r,Point_j,4,8]
  filter [.Point_r = .Point_j]
  projectextend[; Jid: .Jid_j,
     Point: .Point_j,
     Rid: .Rid_r]
  Roads feed {r1}
  hashjoin[Rid, Rid_r1]
  projectextend[Jid, Point, Rid; RMeas: atpoint(.Curve_r1,.Point)]
  sortby [Jid, Point, Rid, RMeas]
  rdup
consume;

let JunctionsAtRoadEndPairs =
  JunctionsAtRoadEnds feed {j1}
  JunctionsAtRoadEnds feed {j2}
  hashjoin[Jid_j1, Jid_j2]
  filter  [.Rid_j1 <= .Rid_j2]
  filter [.RMeas_j1 # .RMeas_j2]
  projectextend [;Jid: .Jid_j1,
    R1id: .Rid_j1,
    R1Meas: .RMeas_j1,
    R2id: .Rid_j2,
    R2Meas: .RMeas_j2,
    NewCC: 65535]
   sortby [Jid, R1id, R1Meas, R2id, R2Meas, NewCC]
   krduph[Jid, R1id, R1Meas, R2id, R2Meas, NewCC]
consume;

let JunctionRoadPairs =
  JunctionPositionsOnRoads feed {j1}
  JunctionPositionsOnRoads feed {j2}
  hashjoin[Jid_j1, Jid_j2]
  filter[.Rid_j1 <= .Rid_j2]
  projectextend[;Jid: .Jid_j1,
    Point: .Point_j1,
    R1id: .Rid_j1,
    R1Meas: .RMeas_j1,
    R2id: .Rid_j2,
    R2Meas: .RMeas_j2,
    CC: 65535,
    WayId1: .WayId_j1,
    Way1StartPosOnRoute: .WayStartPosOnRoute_j1,
    Way1EndPosOnRoute: .WayEndPosOnRoute_j1,
    WayId2: .WayId_j2,
    Way2StartPosOnRoute: .WayStartPosOnRoute_j2,
    Way2EndPosOnRoute: .WayEndPosOnRoute_j2]
  sortby [Jid, R1id, R1Meas, R2id, R2Meas, CC, Way1StartPosOnRoute,
    Way1EndPosOnRoute, Way2StartPosOnRoute, Way2EndPosOnRoute, WayId1, WayId2]
  krduph[Jid, R1id, R1Meas, R2id, R2Meas, CC, Way1StartPosOnRoute,
    Way1EndPosOnRoute, Way2StartPosOnRoute, Way2EndPosOnRoute]
consume;


###############################################################################
# Compute correct Connectivity Code                                           #
###############################################################################
# Select Onewaycurves                                                         #
###############################################################################
let RoadEndPoints =
    JunctionRoadPairs feed
    sortby [Jid, R1id, R1Meas, R2id, R2Meas]
    groupby [Jid; C: group feed count]
    filter [.C = 1] {s}
    JunctionRoadPairs feed
    hashjoin[Jid_s, Jid]
    filter[.R1id = .R2id]
    filter[.WayId1 = .WayId2]
    projectextend[Jid, R1id, R1Meas, R2id,
      R2Meas; NewCC: ifthenelse(.R1Meas = 0, 16, 2)]
consume;

let OneWayCurveIds =
  NestedWayRel feed
  filter[.WayInfo afeed
    filter[.WayTagKey = "oneway"]
    count > 0]
  project[WayId]
consume;

let MotorWayCurveIds =
  NestedWayRel feed
  filter[.WayInfo afeed
    filter [.WayTagKey = "highway"]
    filter [.WayTagValue = "motorway"]
    count > 0]
  project [WayId]
consume;

let RoundaboutWayCurveIds =
  NestedWayRel feed
  filter [.WayInfo afeed
    filter [.WayTagKey = "junction"]
    filter [.WayTagValue = "roundabout"]
    count > 0]
  project [WayId]
consume;

let OneWayIds =
  ((OneWayCurveIds feed)
  (MotorWayCurveIds feed)
  concat)
  (RoundaboutWayCurveIds feed)
  concat
  sortby [WayId]
  rdup
consume;

let JunctionsOfOnewaysSameRID1 =
  JunctionRoadPairs feed
    filter[.R1id = .R2id]
    filter[.WayId1 # .WayId2]
  OneWayIds feed
  hashjoin[WayId1, WayId]
  projectextend[Jid, R1id, R1Meas, R2id,
    R2Meas; NewCC: ifthenelse(.Way1StartPosOnRoute < .Way1EndPosOnRoute,
                     ifthenelse(.R1Meas = .Way1EndPosOnRoute,    .CC binand 21845,
                       ifthenelse(.R1Meas = .Way1StartPosOnRoute, .CC binand 3855,
                                                                 .CC binand 1285)),
                     ifthenelse(.R1Meas = .Way1EndPosOnRoute,    .CC binand 43690,
                       ifthenelse(.R1Meas = .Way1StartPosOnRoute,.CC binand 61680,
                                                                 .CC binand 41120)))]
consume;

let JunctionsOfOnewaysSameRID2 =
  JunctionRoadPairs feed
  filter [.R1id = .R2id]
  filter [.WayId1 # .WayId2]
  OneWayIds feed
  hashjoin[WayId2, WayId]
  projectextend[Jid, R1id, R1Meas, R2id,
    R2Meas; NewCC: ifthenelse(.Way2StartPosOnRoute < .Way2EndPosOnRoute,
                     ifthenelse(.R2Meas = .Way2EndPosOnRoute,    .CC binand 21845,
                      ifthenelse(.R2Meas = .Way2StartPosOnRoute, .CC binand 3855,
                                                                 .CC binand 1285)),
                    ifthenelse(.R2Meas = .Way2EndPosOnRoute,     .CC binand 43690,
                      ifthenelse(.R2Meas = .Way2StartPosOnRoute, .CC binand 61680,
                                                                 .CC binand 41120)))]
consume;

let JunctionsWithOneWayOnRouteA =
  JunctionRoadPairs feed
    filter[.R1id < .R2id]
    filter[.WayId1 # .WayId2]
  OneWayIds feed
  hashjoin[WayId1, WayId]
  projectextend[Jid, R1id, R1Meas, R2id,
    R2Meas; NewCC: ifthenelse(.Way1StartPosOnRoute < .Way1EndPosOnRoute,
                     ifthenelse(.R1Meas = .Way1EndPosOnRoute,    .CC binand 56797,
                       ifthenelse(.R1Meas = .Way1StartPosOnRoute, .CC binand 65295,
                                                                 .CC binand 56589)),
                     ifthenelse(.R1Meas = .Way1EndPosOnRoute,    .CC binand 61166,
                       ifthenelse(.R1Meas = .Way1StartPosOnRoute,.CC binand 65520,
                                                                 .CC binand 61152)))]
consume;

let JunctionsWithOneWayOnRouteB =
  JunctionRoadPairs feed
    filter[.R1id < .R2id]
    filter [.WayId1 # .WayId2]
  OneWayIds feed
  hashjoin[WayId2, WayId]
  projectextend[Jid, R1id, R1Meas, R2id,
    R2Meas; NewCC: ifthenelse(.Way2StartPosOnRoute < .Way2EndPosOnRoute,
                     ifthenelse(.R2Meas = .Way2EndPosOnRoute,     .CC binand 30583,
                       ifthenelse(.R2Meas = .Way2StartPosOnRoute, .CC binand 4095,
                                                                  .CC binand 1911)),
                     ifthenelse(.R2Meas = .Way2EndPosOnRoute,     .CC binand 48095,
                       ifthenelse(.R2Meas = .Way2StartPosOnRoute, .CC binand 61695,
                                                                  .CC binand 45243)))]
consume;

################################################################################
# Build Relation of Restrictions for way connections                           #
################################################################################

let ViaNodesRel =
  NestedRelationRel feed
  filter [.RelInfo afeed
    filter [.RefInfo afeed
      filter [.RelTagKey contains "restriction"]
      count > 0]
    count > 0]
  unnest [RelInfo]
  filter[.MemberRole = "via"]
  filter [.MemberType = "node"]
  SpatialPosOfNodes feed
  hashjoin[MemberRef,NodeId]
  projectextend[RelId, NodeId,
    NodePos; RelTagVal: .RefInfo afeed extract [RelTagValue]]
consume;

let ViaWaysRel =
  NestedRelationRel feed
  filter [.RelInfo afeed
    filter [.RefInfo afeed
      filter [.RelTagKey contains "restriction"]
      count > 0]
    count > 0]
  unnest [RelInfo]
  filter [.MemberRole = "via"]
  filter [.MemberType = "way"]
  SpatialWayCurve feed
  hashjoin[MemberRef, WayId]
  projectextend[RelId, WayId,
    WayCurve; RelTagVal: .RefInfo afeed extract [RelTagValue]]
consume;

let FromWaysRel =
  NestedRelationRel feed
  filter [.RelInfo afeed
    filter [.RefInfo afeed
      filter [.RelTagKey contains "restriction"]
      count > 0]
    count > 0]
  unnest [RelInfo]
  filter [.MemberRole = "from"]
  SpatialWayCurve feed
  hashjoin[MemberRef, WayId]
  project[RelId, WayId, WayCurve]
consume;

let ToWaysRel =
  NestedRelationRel feed
  filter [.RelInfo afeed
    filter [.RefInfo afeed
      filter [.RelTagKey contains "restriction"]
      count > 0]
    count > 0]
  unnest [RelInfo]
  filter [.MemberRole = "to"]
  SpatialWayCurve feed
  hashjoin[MemberRef, WayId]
  project[RelId, WayId, WayCurve]
consume;

let NodeRestrictions =
  ViaNodesRel feed {v}
  FromWaysRel feed {f}
  hashjoin[RelId_v, RelId_f]
  project [RelId_v, NodeId_v, NodePos_v, RelTagVal_v, WayId_f]
  ToWaysRel feed {t}
  hashjoin[RelId_v, RelId_t]
  project[NodeId_v, NodePos_v, RelTagVal_v, WayId_f, WayId_t]
  sortby [NodeId_v, NodePos_v, WayId_f, WayId_t, RelTagVal_v]
  rdup
consume;

let RestrictedJunctionsAA1 =
  JunctionRoadPairs feed
  NodeRestrictions feed
  itSpatialJoin[Point, NodePos_v,4,8]
  filter[.Point = .NodePos_v]
  filter[.WayId1 = .WayId_f]
  filter[.WayId2 = .WayId_t]
  filter [.R1id = .R2id]
  projectextend [Jid, R1id, R1Meas, R2id,
    R2Meas;NewCC: ifthenelse(.WayId1 = .WayId2,
                    ifthenelse(.Way1StartPosOnRoute < .Way1EndPosOnRoute,
                      ifthenelse(.Way1StartPosOnRoute = .R1Meas, .CC binand 65519,
                                                                 .CC binand 65533),
                      ifthenelse(.Way1StartPosOnRoute = .R1Meas, .CC binand 65533,
                                                                 .CC binand 65519)),
                    ifthenelse(.Way1StartPosOnRoute < .Way1EndPosOnRoute,
                      ifthenelse(.Way1StartPosOnRoute = .R1Meas,
                        ifthenelse(.RelTagVal_v contains "no",   .CC binand 65503,
                                                                 .CC binand 65327),
                        ifthenelse(.RelTagVal_v contains "no",   .CC binand 65534,
                                                                 .CC binand 65521)),
                      ifthenelse(.Way1StartPosOnRoute = .R1Meas,
                        ifthenelse(.RelTagVal_v contains "no",   .CC binand 65534,
                                                                 .CC binand 65521),
                        ifthenelse(.RelTagVal_v contains "no",   .CC binand 65503,
                                                                 .CC binand 65327))))]
  sortby[Jid, R1id, R1Meas, R2id, R2Meas, NewCC]
consume;

let RestrictedJunctionsAA2 =
  JunctionRoadPairs feed
  NodeRestrictions feed
  itSpatialJoin[Point, NodePos_v,4,8]
  filter[.Point = .NodePos_v]
  filter[.WayId2 = .WayId_f]
  filter[.WayId1 = .WayId_t]
  filter [.R1id = .R2id]
  projectextend [Jid, R1id, R1Meas, R2id,
    R2Meas;NewCC: ifthenelse(.WayId1 = .WayId2,
                    ifthenelse(.Way2StartPosOnRoute < .Way2EndPosOnRoute,
                      ifthenelse(.Way2StartPosOnRoute = .R2Meas, .CC binand 65519,
                                                                 .CC binand 65533),
                      ifthenelse(.Way2StartPosOnRoute = .R2Meas, .CC binand 65533,
                                                                 .CC binand 65519)),
                    ifthenelse(.Way2StartPosOnRoute < .Way2EndPosOnRoute,
                      ifthenelse(.Way2StartPosOnRoute = .R2Meas,
                        ifthenelse(.RelTagVal_v contains "no",   .CC binand 65503,
                                                                 .CC binand 65327),
                        ifthenelse(.RelTagVal_v contains "no",   .CC binand 65534,
                                                                 .CC binand 65521)),
                      ifthenelse(.Way2StartPosOnRoute = .R2Meas,
                        ifthenelse(.RelTagVal_v contains "no",   .CC binand 65534,
                                                                 .CC binand 65521),
                        ifthenelse(.RelTagVal_v contains "no",   .CC binand 65503,
                                                                 .CC binand 65327))))]
  sortby[Jid, R1id, R1Meas, R2id, R2Meas, NewCC]
consume;

let RestrictedJunctionsAB =
  JunctionRoadPairs feed
  NodeRestrictions feed
  itSpatialJoin[Point, NodePos_v,4,8]
  filter[.Point = .NodePos_v]
  filter[.WayId1 = .WayId_f]
  filter[.WayId2 = .WayId_t]
  filter[.R1id < .R2id]
  projectextend [Jid, R1id, R1Meas, R2id,
    R2Meas; NewCC: ifthenelse(.WayId1 = .WayId2, 0,
                   ifthenelse(.Way1StartPosOnRoute < .Way1EndPosOnRoute,
                     ifthenelse(.Way2StartPosOnRoute < .Way1EndPosOnRoute,
                       ifthenelse(.Way1StartPosOnRoute = .R1Meas,
                          ifthenelse(.Way2StartPosOnRoute = .R2Meas,
                            ifthenelse(.RelTagVal_v contains "no", .CC binand 65471,
                                                                   .CC binand 65359),
                            ifthenelse(.RelTagVal_v contains "no", .CC binand 65407,
                                                                   .CC binand 65423)),
                          ifthenelse(.Way2StartPosOnRoute = .R2Meas,
                            ifthenelse(.RelTagVal_v contains "no", .CC binand 65531,
                                                                   .CC binand 65524),
                            ifthenelse(.RelTagVal_v contains "no", .CC binand 65527,
                                                                   .CC binand 65528))),
                        ifthenelse(.Way1StartPosOnRoute = .R1Meas,
                          ifthenelse(.Way2StartPosOnRoute = .R2Meas,
                            ifthenelse(.RelTagVal_v contains "no", .CC binand 65407,
                                                                   .CC binand 65423),
                            ifthenelse(.RelTagVal_v contains "no", .CC binand 65471,
                                                                   .CC binand 65359)),
                          ifthenelse(.Way2StartPosOnRoute = .R2Meas,
                            ifthenelse(.RelTagVal_v contains "no", .CC binand 65527,
                                                                   .CC binand 65528),
                            ifthenelse(.RelTagVal_v contains "no", .CC binand 65531,
                                                                   .CC binand 65524)))),
                     ifthenelse(.Way2StartPosOnRoute < .Way1EndPosOnRoute,
                       ifthenelse(.Way1StartPosOnRoute = .R1Meas,
                          ifthenelse(.Way2StartPosOnRoute = .R2Meas,
                            ifthenelse(.RelTagVal_v contains "no", .CC binand 65531,
                                                                   .CC binand 655524),
                            ifthenelse(.RelTagVal_v contains "no", .CC binand 65527,
                                                                   .CC binand 65528)),
                          ifthenelse(.Way2StartPosOnRoute = .R2Meas,
                            ifthenelse(.RelTagVal_v contains "no", .CC binand 65471,
                                                                   .CC binand 65359),
                            ifthenelse(.RelTagVal_v contains "no", .CC binand 65407,
                                                                   .CC binand 65423))),
                        ifthenelse(.Way1StartPosOnRoute = .R1Meas,
                          ifthenelse(.Way2StartPosOnRoute = .R2Meas,
                            ifthenelse(.RelTagVal_v contains "no", .CC binand 65527,
                                                                   .CC binand 65528),
                            ifthenelse(.RelTagVal_v contains "no", .CC binand 65531,
                                                                   .CC binand 65524)),
                          ifthenelse(.Way2StartPosOnRoute = .R2Meas,
                            ifthenelse(.RelTagVal_v contains "no", .CC binand 65407,
                                                                   .CC binand 65423),
                            ifthenelse(.RelTagVal_v contains "no", .CC binand 65471,
                                                                   .CC binand 65359))))))]
  sortby[Jid, R1id, R1Meas, R2id, R2Meas, NewCC]
consume;

let RestrictedJunctionsBA =
  JunctionRoadPairs feed
  NodeRestrictions feed
  itSpatialJoin[Point, NodePos_v,4,8]
  filter[.Point = .NodePos_v]
  filter[.WayId2 = .WayId_f]
  filter[.WayId1 = .WayId_t]
  filter[.R1id < .R2id]
  projectextend [Jid, R1id, R1Meas, R2id,
    R2Meas; NewCC: ifthenelse(.WayId1 = .WayId2,0,
                   ifthenelse(.Way1StartPosOnRoute < .Way1EndPosOnRoute,
                     ifthenelse(.Way2StartPosOnRoute < .Way1EndPosOnRoute,
                       ifthenelse(.Way1StartPosOnRoute = .R1Meas,
                          ifthenelse(.Way2StartPosOnRoute = .R2Meas,
                            ifthenelse(.RelTagVal_v contains "no", .CC binand 61439,
                                                                   .CC binand 8191),
                            ifthenelse(.RelTagVal_v contains "no", .CC binand 65279,
                                                                   .CC binand 61951)),
                          ifthenelse(.Way2StartPosOnRoute = .R2Meas,
                            ifthenelse(.RelTagVal_v contains "no", .CC binand 57343,
                                                                   .CC binand 12287),
                            ifthenelse(.RelTagVal_v contains "no", .CC binand 65023,
                                                                   .CC binand 62207))),
                        ifthenelse(.Way1StartPosOnRoute = .R1Meas,
                          ifthenelse(.Way2StartPosOnRoute = .R2Meas,
                            ifthenelse(.RelTagVal_v contains "no", .CC binand 65279,
                                                                   .CC binand 61951),
                            ifthenelse(.RelTagVal_v contains "no", .CC binand 61439,
                                                                   .CC binand 8191)),
                          ifthenelse(.Way2StartPosOnRoute = .R2Meas,
                            ifthenelse(.RelTagVal_v contains "no", .CC binand 65023,
                                                                   .CC binand 62207),
                            ifthenelse(.RelTagVal_v contains "no", .CC binand 57343,
                                                                   .CC binand 12287)))),
                     ifthenelse(.Way2StartPosOnRoute < .Way1EndPosOnRoute,
                       ifthenelse(.Way1StartPosOnRoute = .R1Meas,
                          ifthenelse(.Way2StartPosOnRoute = .R2Meas,
                            ifthenelse(.RelTagVal_v contains "no", .CC binand 57343,
                                                                   .CC binand 12287),
                            ifthenelse(.RelTagVal_v contains "no", .CC binand 65023,
                                                                   .CC binand 62207)),
                          ifthenelse(.Way2StartPosOnRoute = .R2Meas,
                            ifthenelse(.RelTagVal_v contains "no", .CC binand 61439,
                                                                   .CC binand 8191),
                            ifthenelse(.RelTagVal_v contains "no", .CC binand 65279,
                                                                   .CC binand 61951))),
                        ifthenelse(.Way1StartPosOnRoute = .R1Meas,
                          ifthenelse(.Way2StartPosOnRoute = .R2Meas,
                            ifthenelse(.RelTagVal_v contains "no", .CC binand 65023,
                                                                   .CC binand 62207),
                            ifthenelse(.RelTagVal_v contains "no", .CC binand 57343,
                                                                   .CC binand 12287)),
                          ifthenelse(.Way2StartPosOnRoute = .R2Meas,
                            ifthenelse(.RelTagVal_v contains "no", .CC binand 65279,
                                                                   .CC binand 61951),
                            ifthenelse(.RelTagVal_v contains "no", .CC binand 61439,
                                                                   .CC binand 8191))))))]
  sortby[Jid, R1id, R1Meas, R2id, R2Meas, NewCC]
consume;

let Junctions =
  ( ( ( (JunctionsWithOneWayOnRouteA feed)
        (JunctionsWithOneWayOnRouteB feed)
        concat)
      ( (RestrictedJunctionsAA1 feed)
        (RestrictedJunctionsAA2 feed)
        concat)
      concat)
    ( ( (RestrictedJunctionsAB feed)
        (RestrictedJunctionsBA feed)
        concat)
      ( (JunctionsOfOnewaysSameRID1 feed)
        (JunctionsOfOnewaysSameRID2 feed)
        concat)
      concat)
    concat)
  ( ( (RoadEndPoints feed)
      (JunctionsAtRoadEndPairs feed)
      concat)
    (JunctionRoadPairs feed projectextend[Jid, R1id, R1Meas, R2id, R2Meas; NewCC: .CC])
    concat)
  concat
  project[Jid, R1id, R1Meas, R2id, R2Meas, NewCC]
  sortby[Jid, R1id, R1Meas, R2id, R2Meas]
  groupby[Jid, R1id, R1Meas, R2id,
    R2Meas; CC: group feed projecttransformstream[NewCC] binands]
consume;

###############################################################################
# Way Restrictions can not be encoded now in the network data format now      #
# Because we have no information from where the car comes before in the       #
# network data model                                                          #
###############################################################################

let WayRestrictions =
  ViaWaysRel feed {v}
  FromWaysRel feed {f}
  hashjoin[RelId_v, RelId_f]
  project [RelId_v, WayId_v, WayCurve_v, RelTagVal_v, WayId_f, WayCurve_f]
  ToWaysRel feed {t}
  hashjoin[RelId_v, RelId_t]
  project[WayId_v, WayCurve_v, RelTagVal_v, WayId_f, WayCurve_f, WayId_t, WayCurve_t]
  sortby[WayId_v, WayId_f, WayId_t, RelTagVal_v, WayCurve_v, WayCurve_f, WayCurve_t]
  rdup
consume;

##############################################################################
# Build network with all possible restrictions                               #
##############################################################################

let KENetwork = thenetwork(1, 0.0001,
    Roads feed projectextend[Rid, CurvLength, Curve; Dual: FALSE, StartS: get_startsmaller(.Curve)] consume,
    Junctions feed project [R1id, R1Meas, R2id, R2Meas, CC] consume);

close database;

##################
# Just for testing network quality
######

open database kedb;

let t1 = mapmatchmht(KENetwork, 'Trk_KL_Uni_Enkenbach2.xml');

close database;

quit;


